[*] Start mutation process:
   - targets: graph1.py
   - tests: ./ALL-SMART
[*] 90 tests passed:
   - test_graph1_WHOLE_SUITE [0.06105 s]
   - test_graph1_MOSA [0.05398 s]
   - test_graph1_MIO [0.05708 s]
   - test_graph1_DYNAMOSA [0.06112 s]
[*] Start mutants generation and execution:
   - [#   1] AOD graph1: 
--------------------------------------------------------------------------------
   57:         visited = [0] * self.verticies
   58:         
   59:         def valid(node):
   60:             
-  61:             if visited[node] == -1:
+  61:             if visited[node] == 1:
   62:                 return False
   63:             elif visited[node] == 1:
   64:                 return True
   65:             visited[node] = -1
--------------------------------------------------------------------------------
[0.10024 s] killed by ALL-SMART/test_graph1_MIO.py::test_case_7

def test_case_7():
        bool_0 = True
        graph_0 = module_0.Graph(bool_0)
        bool_1 = False
        var_0 = graph_0.add_edge(bool_1, bool_1)
        assert graph_0.graph == {False: [False]}
>       var_1 = graph_0.has_cycle()

ALL-SMART/test_graph1_MIO.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graph1:77: in has_cycle
    ???
graph1:67: in valid
    ???
graph1:67: in valid
    ???
E   RecursionError: maximum recursion depth exceeded in comparison
!!! Recursion detected (same locals & position)
   - [#   2] AOD graph1: 
--------------------------------------------------------------------------------
   61:             if visited[node] == -1:
   62:                 return False
   63:             elif visited[node] == 1:
   64:                 return True
-  65:             visited[node] = -1
+  65:             visited[node] = 1
   66:             for neighbor in self.graph[node]:
   67:                 if not (valid(neighbor)):
   68:                     return False
   69:             return True
--------------------------------------------------------------------------------
[0.09377 s] killed by ALL-SMART/test_graph1_MIO.py::test_case_7

def test_case_7():
        bool_0 = True
        graph_0 = module_0.Graph(bool_0)
        bool_1 = False
        var_0 = graph_0.add_edge(bool_1, bool_1)
        assert graph_0.graph == {False: [False]}
        var_1 = graph_0.has_cycle()
>       assert var_1 is True
E       AssertionError

ALL-SMART/test_graph1_MIO.py:56: AssertionError
   - [#   3] AOR graph1: 
--------------------------------------------------------------------------------
   53:             False if the graph is acyclic.
   54: 
   55:         '''
   56:         
-  57:         visited = [0] * self.verticies
+  57:         visited = [0] / self.verticies
   58:         
   59:         def valid(node):
   60:             
   61:             if visited[node] == -1:
--------------------------------------------------------------------------------
[0.09310 s] incompetent

TypeError: graph1:57: TypeError: unsupported operand type(s) for /: 'list' and 'int'

   - [#   4] AOR graph1: 
--------------------------------------------------------------------------------
   53:             False if the graph is acyclic.
   54: 
   55:         '''
   56:         
-  57:         visited = [0] * self.verticies
+  57:         visited = [0] // self.verticies
   58:         
   59:         def valid(node):
   60:             
   61:             if visited[node] == -1:
--------------------------------------------------------------------------------
[0.09099 s] incompetent

TypeError: graph1:57: TypeError: unsupported operand type(s) for //: 'list' and 'int'

   - [#   5] AOR graph1: 
--------------------------------------------------------------------------------
   53:             False if the graph is acyclic.
   54: 
   55:         '''
   56:         
-  57:         visited = [0] * self.verticies
+  57:         visited = [0] ** self.verticies
   58:         
   59:         def valid(node):
   60:             
   61:             if visited[node] == -1:
--------------------------------------------------------------------------------
[0.09207 s] incompetent

TypeError: graph1:57: TypeError: unsupported operand type(s) for ** or pow(): 'list' and 'int'

   - [#   6] AOR graph1: 
--------------------------------------------------------------------------------
   57:         visited = [0] * self.verticies
   58:         
   59:         def valid(node):
   60:             
-  61:             if visited[node] == -1:
+  61:             if visited[node] == +1:
   62:                 return False
   63:             elif visited[node] == 1:
   64:                 return True
   65:             visited[node] = -1
--------------------------------------------------------------------------------
[0.09822 s] killed by ALL-SMART/test_graph1_MIO.py::test_case_7

def test_case_7():
        bool_0 = True
        graph_0 = module_0.Graph(bool_0)
        bool_1 = False
        var_0 = graph_0.add_edge(bool_1, bool_1)
        assert graph_0.graph == {False: [False]}
>       var_1 = graph_0.has_cycle()

ALL-SMART/test_graph1_MIO.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graph1:77: in has_cycle
    ???
graph1:67: in valid
    ???
graph1:67: in valid
    ???
E   RecursionError: maximum recursion depth exceeded in comparison
!!! Recursion detected (same locals & position)
   - [#   7] AOR graph1: 
--------------------------------------------------------------------------------
   61:             if visited[node] == -1:
   62:                 return False
   63:             elif visited[node] == 1:
   64:                 return True
-  65:             visited[node] = -1
+  65:             visited[node] = +1
   66:             for neighbor in self.graph[node]:
   67:                 if not (valid(neighbor)):
   68:                     return False
   69:             return True
--------------------------------------------------------------------------------
[0.11555 s] killed by ALL-SMART/test_graph1_MIO.py::test_case_7

def test_case_7():
        bool_0 = True
        graph_0 = module_0.Graph(bool_0)
        bool_1 = False
        var_0 = graph_0.add_edge(bool_1, bool_1)
        assert graph_0.graph == {False: [False]}
        var_1 = graph_0.has_cycle()
>       assert var_1 is True
E       AssertionError

ALL-SMART/test_graph1_MIO.py:56: AssertionError
   - [#   8] AOR graph1: 
--------------------------------------------------------------------------------
  127:         self.val = val
  128:         self.adjacent = {}
  129:     
  130:     def __str__(self):
- 131:         return (str(self.val) + ' adjacent: ') + str([x for x in self.adjacent])
+ 131:         return (str(self.val) - ' adjacent: ') + str([x for x in self.adjacent])
  132:     
  133:     def add_adjacent(self, node, weight=0):
  134:         self.adjacent[node] = weight
  135:     
--------------------------------------------------------------------------------
[0.09417 s] incompetent

TypeError: graph1:131: TypeError: unsupported operand type(s) for -: 'str' and 'str'

   - [#   9] AOR graph1: 
--------------------------------------------------------------------------------
  127:         self.val = val
  128:         self.adjacent = {}
  129:     
  130:     def __str__(self):
- 131:         return (str(self.val) + ' adjacent: ') + str([x for x in self.adjacent])
+ 131:         return (str(self.val) + ' adjacent: ') - str([x for x in self.adjacent])
  132:     
  133:     def add_adjacent(self, node, weight=0):
  134:         self.adjacent[node] = weight
  135:     
--------------------------------------------------------------------------------
[0.09519 s] incompetent

TypeError: graph1:131: TypeError: unsupported operand type(s) for -: 'str' and 'str'

   - [#  10] CDI graph1: 
--------------------------------------------------------------------------------
    1: from collections import defaultdict, deque
    2: 
    3: class GraphNode:
    4:     
-   5:     def __init__(self, val):
-   6:         self.val = val
-   7:         self.adjacent_list = set()
-   8:     
+   5:     @classmethod
+   6:     def __init__(self, val):
+   7:         self.val = val
+   8:         self.adjacent_list = set()
    9:     def add_adjacent(self, node):
   10:         self.adjacent_list.add(node)
   11:     
   12:     def remove_adjacent(self, node):
--------------------------------------------------------------------------------
[0.11583 s] survived
   - [#  11] CDI graph1: 
--------------------------------------------------------------------------------
    5:     def __init__(self, val):
    6:         self.val = val
    7:         self.adjacent_list = set()
    8:     
-   9:     def add_adjacent(self, node):
-  10:         self.adjacent_list.add(node)
-  11:     
+   9:     @classmethod
+  10:     def add_adjacent(self, node):
+  11:         self.adjacent_list.add(node)
   12:     def remove_adjacent(self, node):
   13:         self.adjacent_list.remove(node)
   14: 
   15: class Graph:
--------------------------------------------------------------------------------
[0.10725 s] killed by ALL-SMART/test_graph1_MIO.py::test_case_25

def test_case_25():
        int_0 = 5852
        graph_node_0 = module_0.GraphNode(int_0)
>       var_0 = graph_node_0.add_adjacent(graph_node_0)

ALL-SMART/test_graph1_MIO.py:151: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <class 'graph1.GraphNode'>
node = <graph1.GraphNode object at 0x78ae56803610>

>   ???
E   AttributeError: type object 'GraphNode' has no attribute 'adjacent_list'

graph1:11: AttributeError
   - [#  12] CDI graph1: 
--------------------------------------------------------------------------------
    8:     
    9:     def add_adjacent(self, node):
   10:         self.adjacent_list.add(node)
   11:     
-  12:     def remove_adjacent(self, node):
-  13:         self.adjacent_list.remove(node)
-  14: 
+  12:     @classmethod
+  13:     def remove_adjacent(self, node):
+  14:         self.adjacent_list.remove(node)
   15: class Graph:
   16:     '''
   17:     A directed graph represented with an adjacency list.
   18:     '''
--------------------------------------------------------------------------------
[0.11871 s] survived
   - [#  13] CDI graph1: 
--------------------------------------------------------------------------------
   16:     '''
   17:     A directed graph represented with an adjacency list.
   18:     '''
   19:     
-  20:     def __init__(self, verticies):
-  21:         self.graph = {}
-  22:         self.verticies = verticies
-  23:     
+  20:     @classmethod
+  21:     def __init__(self, verticies):
+  22:         self.graph = {}
+  23:         self.verticies = verticies
   24:     def add_edge(self, source, destination):
   25:         '''
   26:         Add an edge to the graph.
   27: 
--------------------------------------------------------------------------------
[0.14201 s] incompetent

TypeError: graph1:57: TypeError: can't multiply sequence by non-int of type 'NoneType'

   - [#  14] CDI graph1: 
--------------------------------------------------------------------------------
   20:     def __init__(self, verticies):
   21:         self.graph = {}
   22:         self.verticies = verticies
   23:     
-  24:     def add_edge(self, source, destination):
-  25:         '''
-  26:         Add an edge to the graph.
-  27: 
-  28:         Add an edge pointing from source vertex
-  29:         to destination vertex.
-  30: 
-  31:         Args:
-  32:             source: the source vertex
-  33:             destination: the destination vertex
-  34: 
-  35:         '''
-  36:         if len(self.graph) > self.verticies:
-  37:             raise IndexError('Too many verticies in graph.')
-  38:         
-  39:         if source in self.graph:
-  40:             self.graph[source].append(destination)
-  41:         else:
-  42:             self.graph[source] = [destination]
-  43:         
-  44:         if destination not in self.graph:
-  45:             self.graph[destination] = []
-  46:     
+  24:     @classmethod
+  25:     def add_edge(self, source, destination):
+  26:         '''
+  27:         Add an edge to the graph.
+  28: 
+  29:         Add an edge pointing from source vertex
+  30:         to destination vertex.
+  31: 
+  32:         Args:
+  33:             source: the source vertex
+  34:             destination: the destination vertex
+  35: 
+  36:         '''
+  37:         if len(self.graph) > self.verticies:
+  38:             raise IndexError('Too many verticies in graph.')
+  39:         
+  40:         if source in self.graph:
+  41:             self.graph[source].append(destination)
+  42:         else:
+  43:             self.graph[source] = [destination]
+  44:         
+  45:         if destination not in self.graph:
+  46:             self.graph[destination] = []
   47:     def has_cycle(self):
   48:         '''
   49:         Detect if a graph has a cycle.
   50: 
--------------------------------------------------------------------------------
[0.08441 s] killed by ALL-SMART/test_graph1_MIO.py::test_case_0

def test_case_0():
        int_0 = 3280
        graph_0 = module_0.Graph(int_0)
>       var_0 = graph_0.add_edge(graph_0, int_0)

ALL-SMART/test_graph1_MIO.py:8: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <class 'graph1.Graph'>, source = <graph1.Graph object at 0x78ae5616a350>
destination = 3280

>   ???
E   AttributeError: type object 'Graph' has no attribute 'graph'

graph1:37: AttributeError
   - [#  15] CDI graph1: 
--------------------------------------------------------------------------------
   43:         
   44:         if destination not in self.graph:
   45:             self.graph[destination] = []
   46:     
-  47:     def has_cycle(self):
-  48:         '''
-  49:         Detect if a graph has a cycle.
-  50: 
-  51:         Returns:
-  52:             True if the graph has a cycle and
-  53:             False if the graph is acyclic.
-  54: 
-  55:         '''
-  56:         
-  57:         visited = [0] * self.verticies
-  58:         
-  59:         def valid(node):
-  60:             
-  61:             if visited[node] == -1:
-  62:                 return False
-  63:             elif visited[node] == 1:
-  64:                 return True
-  65:             visited[node] = -1
-  66:             for neighbor in self.graph[node]:
-  67:                 if not (valid(neighbor)):
-  68:                     return False
-  69:             return True
-  70:         
-  71:         for node in range(self.verticies):
-  72:             
+  47:     @classmethod
+  48:     def has_cycle(self):
+  49:         '''
+  50:         Detect if a graph has a cycle.
+  51: 
+  52:         Returns:
+  53:             True if the graph has a cycle and
+  54:             False if the graph is acyclic.
+  55: 
+  56:         '''
+  57:         
+  58:         visited = [0] * self.verticies
+  59:         
+  60:         def valid(node):
+  61:             
+  62:             if visited[node] == -1:
+  63:                 return False
+  64:             elif visited[node] == 1:
+  65:                 return True
+  66:             visited[node] = -1
+  67:             for neighbor in self.graph[node]:
+  68:                 if not (valid(neighbor)):
+  69:                     return False
+  70:             return True
+  71:         
+  72:         for node in range(self.verticies):
   73:             
   74:             
-  75:             if not (visited[node]):
-  76:                 
-  77:                 if valid(node):
-  78:                     
-  79:                     visited = list(map((lambda x: (abs(x))), visited))
-  80:                 else:
-  81:                     
-  82:                     return True
-  83:         
-  84:         return False
-  85:     
+  75:             
+  76:             if not (visited[node]):
+  77:                 
+  78:                 if valid(node):
+  79:                     
+  80:                     visited = list(map((lambda x: (abs(x))), visited))
+  81:                 else:
+  82:                     
+  83:                     return True
+  84:         
+  85:         return False
   86:     def topological_sort(self):
   87:         """
   88:         Sort the graph topologically.
   89: 
--------------------------------------------------------------------------------
[0.11508 s] killed by ALL-SMART/test_graph1_MIO.py::test_case_5

def test_case_5():
        int_0 = -3972
        graph_0 = module_0.Graph(int_0)
>       var_0 = graph_0.has_cycle()

ALL-SMART/test_graph1_MIO.py:37: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <class 'graph1.Graph'>

>   ???
E   AttributeError: type object 'Graph' has no attribute 'verticies'

graph1:58: AttributeError
   - [#  16] CDI graph1: 
--------------------------------------------------------------------------------
   82:                     return True
   83:         
   84:         return False
   85:     
-  86:     def topological_sort(self):
-  87:         """
-  88:         Sort the graph topologically.
-  89: 
-  90:         A topological sort lists nodes in such a way
-  91:         that every node 's' in 's' -> 'd' directed pairs
-  92:         is listed before 'd.'  This will not work in a 
-  93:         graph that contains cycles.
-  94: 
-  95:         The algorithm looks at every node, and does a
-  96:         dfs for each node adjacent to the node and then adds
-  97:         the originating node to a stack once all adjacent
-  98:         nodes have been searched.  In the end, the stack
-  99:         will be in order of a possible topological sort.
- 100: 
- 101:         Topological sorts are not necessarily unique.
- 102: 
- 103:         Returns:
- 104:             A list of vertices in a topological ordering.
- 105: 
- 106:         """
- 107:         visited = set()
- 108:         stack = deque()
- 109:         
- 110:         def dfs(vertex):
- 111:             visited.add(vertex)
- 112:             for j in self.graph[vertex]:
- 113:                 if j not in visited:
- 114:                     dfs(j)
- 115:             
- 116:             stack.appendleft(vertex)
- 117:         
- 118:         for (key, _) in self.graph.items():
- 119:             if key not in visited:
- 120:                 dfs(key)
- 121:         
- 122:         return list(stack)
- 123: 
+  86:     @classmethod
+  87:     def topological_sort(self):
+  88:         """
+  89:         Sort the graph topologically.
+  90: 
+  91:         A topological sort lists nodes in such a way
+  92:         that every node 's' in 's' -> 'd' directed pairs
+  93:         is listed before 'd.'  This will not work in a 
+  94:         graph that contains cycles.
+  95: 
+  96:         The algorithm looks at every node, and does a
+  97:         dfs for each node adjacent to the node and then adds
+  98:         the originating node to a stack once all adjacent
+  99:         nodes have been searched.  In the end, the stack
+ 100:         will be in order of a possible topological sort.
+ 101: 
+ 102:         Topological sorts are not necessarily unique.
+ 103: 
+ 104:         Returns:
+ 105:             A list of vertices in a topological ordering.
+ 106: 
+ 107:         """
+ 108:         visited = set()
+ 109:         stack = deque()
+ 110:         
+ 111:         def dfs(vertex):
+ 112:             visited.add(vertex)
+ 113:             for j in self.graph[vertex]:
+ 114:                 if j not in visited:
+ 115:                     dfs(j)
+ 116:             
+ 117:             stack.appendleft(vertex)
+ 118:         
+ 119:         for (key, _) in self.graph.items():
+ 120:             if key not in visited:
+ 121:                 dfs(key)
+ 122:         
+ 123:         return list(stack)
  124: class WeightedGraphNode:
  125:     
  126:     def __init__(self, val):
  127:         self.val = val
--------------------------------------------------------------------------------
[0.09723 s] killed by ALL-SMART/test_graph1_MIO.py::test_case_9

def test_case_9():
        int_0 = 1135
        graph_0 = module_0.Graph(int_0)
        var_0 = graph_0.add_edge(int_0, int_0)
        assert graph_0.graph == {1135: [1135]}
>       var_1 = graph_0.topological_sort()

ALL-SMART/test_graph1_MIO.py:70: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <class 'graph1.Graph'>

>   ???
E   AttributeError: type object 'Graph' has no attribute 'graph'

graph1:119: AttributeError
   - [#  17] CDI graph1: 
--------------------------------------------------------------------------------
  122:         return list(stack)
  123: 
  124: class WeightedGraphNode:
  125:     
- 126:     def __init__(self, val):
- 127:         self.val = val
- 128:         self.adjacent = {}
- 129:     
+ 126:     @classmethod
+ 127:     def __init__(self, val):
+ 128:         self.val = val
+ 129:         self.adjacent = {}
  130:     def __str__(self):
  131:         return (str(self.val) + ' adjacent: ') + str([x for x in self.adjacent])
  132:     
  133:     def add_adjacent(self, node, weight=0):
--------------------------------------------------------------------------------
[0.11653 s] survived
   - [#  18] CDI graph1: 
--------------------------------------------------------------------------------
  126:     def __init__(self, val):
  127:         self.val = val
  128:         self.adjacent = {}
  129:     
- 130:     def __str__(self):
- 131:         return (str(self.val) + ' adjacent: ') + str([x for x in self.adjacent])
- 132:     
+ 130:     @classmethod
+ 131:     def __str__(self):
+ 132:         return (str(self.val) + ' adjacent: ') + str([x for x in self.adjacent])
  133:     def add_adjacent(self, node, weight=0):
  134:         self.adjacent[node] = weight
  135:     
  136:     def remove_adjacent(self, node):
--------------------------------------------------------------------------------
[0.09493 s] killed by ALL-SMART/test_graph1_MIO.py::test_case_12

def test_case_12():
        weighted_graph_0 = module_0.WeightedGraph()
        none_type_0 = None
        var_0 = weighted_graph_0.add_edge(none_type_0, none_type_0)
>       var_1 = weighted_graph_0.__str__()

ALL-SMART/test_graph1_MIO.py:88: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graph1:145: in __str__
    ???
graph1:145: in <listcomp>
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <class 'graph1.WeightedGraphNode'>

>   ???
E   AttributeError: type object 'WeightedGraphNode' has no attribute 'val'

graph1:132: AttributeError
   - [#  19] CDI graph1: 
--------------------------------------------------------------------------------
  129:     
  130:     def __str__(self):
  131:         return (str(self.val) + ' adjacent: ') + str([x for x in self.adjacent])
  132:     
- 133:     def add_adjacent(self, node, weight=0):
- 134:         self.adjacent[node] = weight
- 135:     
+ 133:     @classmethod
+ 134:     def add_adjacent(self, node, weight=0):
+ 135:         self.adjacent[node] = weight
  136:     def remove_adjacent(self, node):
  137:         del self.adjacent[node]
  138: 
  139: class WeightedGraph:
--------------------------------------------------------------------------------
[0.11968 s] killed by ALL-SMART/test_graph1_MIO.py::test_case_12

def test_case_12():
        weighted_graph_0 = module_0.WeightedGraph()
        none_type_0 = None
>       var_0 = weighted_graph_0.add_edge(none_type_0, none_type_0)

ALL-SMART/test_graph1_MIO.py:87: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graph1:156: in add_edge
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <class 'graph1.WeightedGraphNode'>, node = None, weight = 0

>   ???
E   AttributeError: type object 'WeightedGraphNode' has no attribute 'adjacent'

graph1:135: AttributeError
   - [#  20] CDI graph1: 
--------------------------------------------------------------------------------
  132:     
  133:     def add_adjacent(self, node, weight=0):
  134:         self.adjacent[node] = weight
  135:     
- 136:     def remove_adjacent(self, node):
- 137:         del self.adjacent[node]
- 138: 
+ 136:     @classmethod
+ 137:     def remove_adjacent(self, node):
+ 138:         del self.adjacent[node]
  139: class WeightedGraph:
  140:     
  141:     def __init__(self):
  142:         self.vertices = {}
--------------------------------------------------------------------------------
[0.10623 s] killed by ALL-SMART/test_graph1_MIO.py::test_case_21

def test_case_21():
        weighted_graph_0 = module_0.WeightedGraph()
        var_0 = weighted_graph_0.add_edge(weighted_graph_0, weighted_graph_0)
>       var_1 = weighted_graph_0.remove_edge(weighted_graph_0, weighted_graph_0)

ALL-SMART/test_graph1_MIO.py:135: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graph1:164: in remove_edge
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <class 'graph1.WeightedGraphNode'>
node = <graph1.WeightedGraph object at 0x78ae5621e4a0>

>   ???
E   AttributeError: type object 'WeightedGraphNode' has no attribute 'adjacent'

graph1:138: AttributeError
   - [#  21] CDI graph1: 
--------------------------------------------------------------------------------
  137:         del self.adjacent[node]
  138: 
  139: class WeightedGraph:
  140:     
- 141:     def __init__(self):
- 142:         self.vertices = {}
- 143:     
+ 141:     @classmethod
+ 142:     def __init__(self):
+ 143:         self.vertices = {}
  144:     def __str__(self):
  145:         return ', '.join([node.__str__() for node in self.vertices.values()])
  146:     
  147:     def add_vertex(self, val):
--------------------------------------------------------------------------------
[0.12071 s] survived
   - [#  22] CDI graph1: 
--------------------------------------------------------------------------------
  140:     
  141:     def __init__(self):
  142:         self.vertices = {}
  143:     
- 144:     def __str__(self):
- 145:         return ', '.join([node.__str__() for node in self.vertices.values()])
- 146:     
+ 144:     @classmethod
+ 145:     def __str__(self):
+ 146:         return ', '.join([node.__str__() for node in self.vertices.values()])
  147:     def add_vertex(self, val):
  148:         vertex = WeightedGraphNode(val)
  149:         self.vertices[val] = vertex
  150:     
--------------------------------------------------------------------------------
[0.12110 s] killed by ALL-SMART/test_graph1_MIO.py::test_case_12

def test_case_12():
        weighted_graph_0 = module_0.WeightedGraph()
        none_type_0 = None
        var_0 = weighted_graph_0.add_edge(none_type_0, none_type_0)
>       var_1 = weighted_graph_0.__str__()

ALL-SMART/test_graph1_MIO.py:88: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <class 'graph1.WeightedGraph'>

>   ???
E   AttributeError: type object 'WeightedGraph' has no attribute 'vertices'

graph1:146: AttributeError
   - [#  23] CDI graph1: 
--------------------------------------------------------------------------------
  143:     
  144:     def __str__(self):
  145:         return ', '.join([node.__str__() for node in self.vertices.values()])
  146:     
- 147:     def add_vertex(self, val):
- 148:         vertex = WeightedGraphNode(val)
- 149:         self.vertices[val] = vertex
- 150:     
+ 147:     @classmethod
+ 148:     def add_vertex(self, val):
+ 149:         vertex = WeightedGraphNode(val)
+ 150:         self.vertices[val] = vertex
  151:     def add_edge(self, src, dst, weight=0):
  152:         if src not in self.vertices:
  153:             self.add_vertex(src)
  154:         if dst not in self.vertices:
--------------------------------------------------------------------------------
[0.10084 s] killed by ALL-SMART/test_graph1_MIO.py::test_case_12

def test_case_12():
        weighted_graph_0 = module_0.WeightedGraph()
        none_type_0 = None
>       var_0 = weighted_graph_0.add_edge(none_type_0, none_type_0)

ALL-SMART/test_graph1_MIO.py:87: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graph1:153: in add_edge
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <class 'graph1.WeightedGraph'>, val = None

>   ???
E   AttributeError: type object 'WeightedGraph' has no attribute 'vertices'

graph1:150: AttributeError
   - [#  24] CDI graph1: 
--------------------------------------------------------------------------------
  147:     def add_vertex(self, val):
  148:         vertex = WeightedGraphNode(val)
  149:         self.vertices[val] = vertex
  150:     
- 151:     def add_edge(self, src, dst, weight=0):
- 152:         if src not in self.vertices:
- 153:             self.add_vertex(src)
- 154:         if dst not in self.vertices:
- 155:             self.add_vertex(dst)
- 156:         self.vertices[src].add_adjacent(dst, weight)
- 157:     
+ 151:     @classmethod
+ 152:     def add_edge(self, src, dst, weight=0):
+ 153:         if src not in self.vertices:
+ 154:             self.add_vertex(src)
+ 155:         if dst not in self.vertices:
+ 156:             self.add_vertex(dst)
+ 157:         self.vertices[src].add_adjacent(dst, weight)
  158:     def remove_edge(self, src, dst):
  159:         if src not in self.vertices:
  160:             return
  161:         if dst not in self.vertices:
--------------------------------------------------------------------------------
[0.10184 s] killed by ALL-SMART/test_graph1_MIO.py::test_case_12

def test_case_12():
        weighted_graph_0 = module_0.WeightedGraph()
        none_type_0 = None
>       var_0 = weighted_graph_0.add_edge(none_type_0, none_type_0)

ALL-SMART/test_graph1_MIO.py:87: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <class 'graph1.WeightedGraph'>, src = None, dst = None, weight = 0

>   ???
E   AttributeError: type object 'WeightedGraph' has no attribute 'vertices'

graph1:153: AttributeError
   - [#  25] CDI graph1: 
--------------------------------------------------------------------------------
  154:         if dst not in self.vertices:
  155:             self.add_vertex(dst)
  156:         self.vertices[src].add_adjacent(dst, weight)
  157:     
- 158:     def remove_edge(self, src, dst):
- 159:         if src not in self.vertices:
- 160:             return
- 161:         if dst not in self.vertices:
- 162:             return
- 163:         if dst in self.vertices[src].adjacent:
- 164:             self.vertices[src].remove_adjacent(dst)
+ 158:     @classmethod
+ 159:     def remove_edge(self, src, dst):
+ 160:         if src not in self.vertices:
+ 161:             return
+ 162:         if dst not in self.vertices:
+ 163:             return
+ 164:         if dst in self.vertices[src].adjacent:
+ 165:             self.vertices[src].remove_adjacent(dst)
--------------------------------------------------------------------------------
[0.10152 s] killed by ALL-SMART/test_graph1_MIO.py::test_case_19

def test_case_19():
        weighted_graph_0 = module_0.WeightedGraph()
        var_0 = weighted_graph_0.add_vertex(weighted_graph_0)
>       var_1 = weighted_graph_0.remove_edge(weighted_graph_0, var_0)

ALL-SMART/test_graph1_MIO.py:124: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <class 'graph1.WeightedGraph'>
src = <graph1.WeightedGraph object at 0x78ae564934c0>, dst = None

>   ???
E   AttributeError: type object 'WeightedGraph' has no attribute 'vertices'

graph1:160: AttributeError
   - [#  26] COD graph1: 
--------------------------------------------------------------------------------
   40:             self.graph[source].append(destination)
   41:         else:
   42:             self.graph[source] = [destination]
   43:         
-  44:         if destination not in self.graph:
+  44:         if destination in self.graph:
   45:             self.graph[destination] = []
   46:     
   47:     def has_cycle(self):
   48:         '''
--------------------------------------------------------------------------------
[0.08839 s] killed by ALL-SMART/test_graph1_MIO.py::test_case_0

def test_case_0():
        int_0 = 3280
        graph_0 = module_0.Graph(int_0)
        var_0 = graph_0.add_edge(graph_0, int_0)
>       assert len(graph_0.graph) == 2
E       AssertionError

ALL-SMART/test_graph1_MIO.py:9: AssertionError
   - [#  27] COD graph1: 
--------------------------------------------------------------------------------
   63:             elif visited[node] == 1:
   64:                 return True
   65:             visited[node] = -1
   66:             for neighbor in self.graph[node]:
-  67:                 if not (valid(neighbor)):
+  67:                 if valid(neighbor):
   68:                     return False
   69:             return True
   70:         
   71:         for node in range(self.verticies):
--------------------------------------------------------------------------------
[0.09074 s] killed by ALL-SMART/test_graph1_MIO.py::test_case_7

def test_case_7():
        bool_0 = True
        graph_0 = module_0.Graph(bool_0)
        bool_1 = False
        var_0 = graph_0.add_edge(bool_1, bool_1)
        assert graph_0.graph == {False: [False]}
        var_1 = graph_0.has_cycle()
>       assert var_1 is True
E       AssertionError

ALL-SMART/test_graph1_MIO.py:56: AssertionError
   - [#  28] COD graph1: 
--------------------------------------------------------------------------------
   71:         for node in range(self.verticies):
   72:             
   73:             
   74:             
-  75:             if not (visited[node]):
+  75:             if visited[node]:
   76:                 
   77:                 if valid(node):
   78:                     
   79:                     visited = list(map((lambda x: (abs(x))), visited))
--------------------------------------------------------------------------------
[0.09656 s] killed by ALL-SMART/test_graph1_MIO.py::test_case_7

def test_case_7():
        bool_0 = True
        graph_0 = module_0.Graph(bool_0)
        bool_1 = False
        var_0 = graph_0.add_edge(bool_1, bool_1)
        assert graph_0.graph == {False: [False]}
        var_1 = graph_0.has_cycle()
>       assert var_1 is True
E       AssertionError

ALL-SMART/test_graph1_MIO.py:56: AssertionError
   - [#  29] COD graph1: 
--------------------------------------------------------------------------------
  109:         
  110:         def dfs(vertex):
  111:             visited.add(vertex)
  112:             for j in self.graph[vertex]:
- 113:                 if j not in visited:
+ 113:                 if j in visited:
  114:                     dfs(j)
  115:             
  116:             stack.appendleft(vertex)
  117:         
--------------------------------------------------------------------------------
[0.12055 s] killed by ALL-SMART/test_graph1_MIO.py::test_case_9

def test_case_9():
        int_0 = 1135
        graph_0 = module_0.Graph(int_0)
        var_0 = graph_0.add_edge(int_0, int_0)
        assert graph_0.graph == {1135: [1135]}
>       var_1 = graph_0.topological_sort()

ALL-SMART/test_graph1_MIO.py:70: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graph1:120: in topological_sort
    ???
graph1:114: in dfs
    ???
graph1:114: in dfs
    ???
E   RecursionError: maximum recursion depth exceeded while calling a Python object
!!! Recursion detected (same locals & position)
   - [#  30] COD graph1: 
--------------------------------------------------------------------------------
  115:             
  116:             stack.appendleft(vertex)
  117:         
  118:         for (key, _) in self.graph.items():
- 119:             if key not in visited:
+ 119:             if key in visited:
  120:                 dfs(key)
  121:         
  122:         return list(stack)
  123: 
--------------------------------------------------------------------------------
[0.16193 s] killed by ALL-SMART/test_graph1_MOSA.py::test_case_22

def test_case_22():
        bool_0 = True
        int_0 = 23
        graph_0 = module_0.Graph(int_0)
        bool_1 = False
        var_0 = graph_0.add_edge(bool_0, bool_1)
        assert graph_0.graph == {True: [False], False: []}
        var_1 = graph_0.topological_sort()
        graph_1 = module_0.Graph(var_1)
>       assert graph_1.verticies == [True, False]
E       AssertionError

ALL-SMART/test_graph1_MOSA.py:190: AssertionError
   - [#  31] COD graph1: 
--------------------------------------------------------------------------------
  148:         vertex = WeightedGraphNode(val)
  149:         self.vertices[val] = vertex
  150:     
  151:     def add_edge(self, src, dst, weight=0):
- 152:         if src not in self.vertices:
+ 152:         if src in self.vertices:
  153:             self.add_vertex(src)
  154:         if dst not in self.vertices:
  155:             self.add_vertex(dst)
  156:         self.vertices[src].add_adjacent(dst, weight)
--------------------------------------------------------------------------------
[0.09701 s] killed by ALL-SMART/test_graph1_MIO.py::test_case_16

def test_case_16():
        none_type_0 = None
        weighted_graph_0 = module_0.WeightedGraph()
>       var_0 = weighted_graph_0.add_edge(none_type_0, weighted_graph_0)

ALL-SMART/test_graph1_MIO.py:108: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <graph1.WeightedGraph object at 0x78ae56276770>, src = None
dst = <graph1.WeightedGraph object at 0x78ae56276770>, weight = 0

>   ???
E   KeyError: None

graph1:156: KeyError
   - [#  32] COD graph1: 
--------------------------------------------------------------------------------
  150:     
  151:     def add_edge(self, src, dst, weight=0):
  152:         if src not in self.vertices:
  153:             self.add_vertex(src)
- 154:         if dst not in self.vertices:
+ 154:         if dst in self.vertices:
  155:             self.add_vertex(dst)
  156:         self.vertices[src].add_adjacent(dst, weight)
  157:     
  158:     def remove_edge(self, src, dst):
--------------------------------------------------------------------------------
[0.09980 s] killed by ALL-SMART/test_graph1_MIO.py::test_case_16

def test_case_16():
        none_type_0 = None
        weighted_graph_0 = module_0.WeightedGraph()
        var_0 = weighted_graph_0.add_edge(none_type_0, weighted_graph_0)
>       assert len(weighted_graph_0.vertices) == 2
E       AssertionError

ALL-SMART/test_graph1_MIO.py:109: AssertionError
   - [#  33] COD graph1: 
--------------------------------------------------------------------------------
  155:             self.add_vertex(dst)
  156:         self.vertices[src].add_adjacent(dst, weight)
  157:     
  158:     def remove_edge(self, src, dst):
- 159:         if src not in self.vertices:
+ 159:         if src in self.vertices:
  160:             return
  161:         if dst not in self.vertices:
  162:             return
  163:         if dst in self.vertices[src].adjacent:
--------------------------------------------------------------------------------
[0.11840 s] survived
   - [#  34] COD graph1: 
--------------------------------------------------------------------------------
  157:     
  158:     def remove_edge(self, src, dst):
  159:         if src not in self.vertices:
  160:             return
- 161:         if dst not in self.vertices:
+ 161:         if dst in self.vertices:
  162:             return
  163:         if dst in self.vertices[src].adjacent:
  164:             self.vertices[src].remove_adjacent(dst)
--------------------------------------------------------------------------------
[0.11515 s] survived
   - [#  35] COI graph1: 
--------------------------------------------------------------------------------
   32:             source: the source vertex
   33:             destination: the destination vertex
   34: 
   35:         '''
-  36:         if len(self.graph) > self.verticies:
+  36:         if not (len(self.graph) > self.verticies):
   37:             raise IndexError('Too many verticies in graph.')
   38:         
   39:         if source in self.graph:
   40:             self.graph[source].append(destination)
--------------------------------------------------------------------------------
[0.08929 s] killed by ALL-SMART/test_graph1_MIO.py::test_case_0

def test_case_0():
        int_0 = 3280
        graph_0 = module_0.Graph(int_0)
>       var_0 = graph_0.add_edge(graph_0, int_0)

ALL-SMART/test_graph1_MIO.py:8: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <graph1.Graph object at 0x78ae56406620>
source = <graph1.Graph object at 0x78ae56406620>, destination = 3280

>   ???
E   IndexError: Too many verticies in graph.

graph1:37: IndexError
   - [#  36] COI graph1: 
--------------------------------------------------------------------------------
   35:         '''
   36:         if len(self.graph) > self.verticies:
   37:             raise IndexError('Too many verticies in graph.')
   38:         
-  39:         if source in self.graph:
+  39:         if not (source in self.graph):
   40:             self.graph[source].append(destination)
   41:         else:
   42:             self.graph[source] = [destination]
   43:         
--------------------------------------------------------------------------------
[0.08848 s] killed by ALL-SMART/test_graph1_MIO.py::test_case_0

def test_case_0():
        int_0 = 3280
        graph_0 = module_0.Graph(int_0)
>       var_0 = graph_0.add_edge(graph_0, int_0)

ALL-SMART/test_graph1_MIO.py:8: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <graph1.Graph object at 0x78ae564fd9c0>
source = <graph1.Graph object at 0x78ae564fd9c0>, destination = 3280

>   ???
E   KeyError: <graph1.Graph object at 0x78ae564fd9c0>

graph1:40: KeyError
   - [#  37] COI graph1: 
--------------------------------------------------------------------------------
   35:         '''
   36:         if len(self.graph) > self.verticies:
   37:             raise IndexError('Too many verticies in graph.')
   38:         
-  39:         if source in self.graph:
+  39:         if source not in self.graph:
   40:             self.graph[source].append(destination)
   41:         else:
   42:             self.graph[source] = [destination]
   43:         
--------------------------------------------------------------------------------
[0.09436 s] killed by ALL-SMART/test_graph1_MIO.py::test_case_0

def test_case_0():
        int_0 = 3280
        graph_0 = module_0.Graph(int_0)
>       var_0 = graph_0.add_edge(graph_0, int_0)

ALL-SMART/test_graph1_MIO.py:8: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <graph1.Graph object at 0x78ae562d1450>
source = <graph1.Graph object at 0x78ae562d1450>, destination = 3280

>   ???
E   KeyError: <graph1.Graph object at 0x78ae562d1450>

graph1:40: KeyError
   - [#  38] COI graph1: 
--------------------------------------------------------------------------------
   40:             self.graph[source].append(destination)
   41:         else:
   42:             self.graph[source] = [destination]
   43:         
-  44:         if destination not in self.graph:
+  44:         if not (destination not in self.graph):
   45:             self.graph[destination] = []
   46:     
   47:     def has_cycle(self):
   48:         '''
--------------------------------------------------------------------------------
[0.08771 s] killed by ALL-SMART/test_graph1_MIO.py::test_case_0

def test_case_0():
        int_0 = 3280
        graph_0 = module_0.Graph(int_0)
        var_0 = graph_0.add_edge(graph_0, int_0)
>       assert len(graph_0.graph) == 2
E       AssertionError

ALL-SMART/test_graph1_MIO.py:9: AssertionError
   - [#  39] COI graph1: 
--------------------------------------------------------------------------------
   57:         visited = [0] * self.verticies
   58:         
   59:         def valid(node):
   60:             
-  61:             if visited[node] == -1:
+  61:             if not (visited[node] == -1):
   62:                 return False
   63:             elif visited[node] == 1:
   64:                 return True
   65:             visited[node] = -1
--------------------------------------------------------------------------------
[0.09526 s] killed by ALL-SMART/test_graph1_MIO.py::test_case_6

def test_case_6():
        bool_0 = True
        graph_0 = module_0.Graph(bool_0)
        bool_1 = False
        var_0 = graph_0.add_edge(graph_0, bool_1)
        assert len(graph_0.graph) == 2
        var_1 = graph_0.has_cycle()
>       assert var_1 is False
E       AssertionError

ALL-SMART/test_graph1_MIO.py:47: AssertionError
   - [#  40] COI graph1: 
--------------------------------------------------------------------------------
   59:         def valid(node):
   60:             
   61:             if visited[node] == -1:
   62:                 return False
-  63:             elif visited[node] == 1:
+  63:             elif not (visited[node] == 1):
   64:                 return True
   65:             visited[node] = -1
   66:             for neighbor in self.graph[node]:
   67:                 if not (valid(neighbor)):
--------------------------------------------------------------------------------
[0.08952 s] killed by ALL-SMART/test_graph1_MIO.py::test_case_7

def test_case_7():
        bool_0 = True
        graph_0 = module_0.Graph(bool_0)
        bool_1 = False
        var_0 = graph_0.add_edge(bool_1, bool_1)
        assert graph_0.graph == {False: [False]}
        var_1 = graph_0.has_cycle()
>       assert var_1 is True
E       AssertionError

ALL-SMART/test_graph1_MIO.py:56: AssertionError
   - [#  41] COI graph1: 
--------------------------------------------------------------------------------
   63:             elif visited[node] == 1:
   64:                 return True
   65:             visited[node] = -1
   66:             for neighbor in self.graph[node]:
-  67:                 if not (valid(neighbor)):
+  67:                 if not ((not (valid(neighbor)))):
   68:                     return False
   69:             return True
   70:         
   71:         for node in range(self.verticies):
--------------------------------------------------------------------------------
[0.09570 s] killed by ALL-SMART/test_graph1_MIO.py::test_case_7

def test_case_7():
        bool_0 = True
        graph_0 = module_0.Graph(bool_0)
        bool_1 = False
        var_0 = graph_0.add_edge(bool_1, bool_1)
        assert graph_0.graph == {False: [False]}
        var_1 = graph_0.has_cycle()
>       assert var_1 is True
E       AssertionError

ALL-SMART/test_graph1_MIO.py:56: AssertionError
   - [#  42] COI graph1: 
--------------------------------------------------------------------------------
   71:         for node in range(self.verticies):
   72:             
   73:             
   74:             
-  75:             if not (visited[node]):
+  75:             if not ((not (visited[node]))):
   76:                 
   77:                 if valid(node):
   78:                     
   79:                     visited = list(map((lambda x: (abs(x))), visited))
--------------------------------------------------------------------------------
[0.09561 s] killed by ALL-SMART/test_graph1_MIO.py::test_case_7

def test_case_7():
        bool_0 = True
        graph_0 = module_0.Graph(bool_0)
        bool_1 = False
        var_0 = graph_0.add_edge(bool_1, bool_1)
        assert graph_0.graph == {False: [False]}
        var_1 = graph_0.has_cycle()
>       assert var_1 is True
E       AssertionError

ALL-SMART/test_graph1_MIO.py:56: AssertionError
   - [#  43] COI graph1: 
--------------------------------------------------------------------------------
   73:             
   74:             
   75:             if not (visited[node]):
   76:                 
-  77:                 if valid(node):
+  77:                 if not (valid(node)):
   78:                     
   79:                     visited = list(map((lambda x: (abs(x))), visited))
   80:                 else:
   81:                     
--------------------------------------------------------------------------------
[0.09422 s] killed by ALL-SMART/test_graph1_MIO.py::test_case_6

def test_case_6():
        bool_0 = True
        graph_0 = module_0.Graph(bool_0)
        bool_1 = False
        var_0 = graph_0.add_edge(graph_0, bool_1)
        assert len(graph_0.graph) == 2
        var_1 = graph_0.has_cycle()
>       assert var_1 is False
E       AssertionError

ALL-SMART/test_graph1_MIO.py:47: AssertionError
   - [#  44] COI graph1: 
--------------------------------------------------------------------------------
  109:         
  110:         def dfs(vertex):
  111:             visited.add(vertex)
  112:             for j in self.graph[vertex]:
- 113:                 if j not in visited:
+ 113:                 if not (j not in visited):
  114:                     dfs(j)
  115:             
  116:             stack.appendleft(vertex)
  117:         
--------------------------------------------------------------------------------
[0.10212 s] killed by ALL-SMART/test_graph1_MIO.py::test_case_9

def test_case_9():
        int_0 = 1135
        graph_0 = module_0.Graph(int_0)
        var_0 = graph_0.add_edge(int_0, int_0)
        assert graph_0.graph == {1135: [1135]}
>       var_1 = graph_0.topological_sort()

ALL-SMART/test_graph1_MIO.py:70: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graph1:120: in topological_sort
    ???
graph1:114: in dfs
    ???
graph1:114: in dfs
    ???
E   RecursionError: maximum recursion depth exceeded while calling a Python object
!!! Recursion detected (same locals & position)
   - [#  45] COI graph1: 
--------------------------------------------------------------------------------
  115:             
  116:             stack.appendleft(vertex)
  117:         
  118:         for (key, _) in self.graph.items():
- 119:             if key not in visited:
+ 119:             if not (key not in visited):
  120:                 dfs(key)
  121:         
  122:         return list(stack)
  123: 
--------------------------------------------------------------------------------
[0.16405 s] killed by ALL-SMART/test_graph1_MOSA.py::test_case_22

def test_case_22():
        bool_0 = True
        int_0 = 23
        graph_0 = module_0.Graph(int_0)
        bool_1 = False
        var_0 = graph_0.add_edge(bool_0, bool_1)
        assert graph_0.graph == {True: [False], False: []}
        var_1 = graph_0.topological_sort()
        graph_1 = module_0.Graph(var_1)
>       assert graph_1.verticies == [True, False]
E       AssertionError

ALL-SMART/test_graph1_MOSA.py:190: AssertionError
   - [#  46] COI graph1: 
--------------------------------------------------------------------------------
  148:         vertex = WeightedGraphNode(val)
  149:         self.vertices[val] = vertex
  150:     
  151:     def add_edge(self, src, dst, weight=0):
- 152:         if src not in self.vertices:
+ 152:         if not (src not in self.vertices):
  153:             self.add_vertex(src)
  154:         if dst not in self.vertices:
  155:             self.add_vertex(dst)
  156:         self.vertices[src].add_adjacent(dst, weight)
--------------------------------------------------------------------------------
[0.09971 s] killed by ALL-SMART/test_graph1_MIO.py::test_case_16

def test_case_16():
        none_type_0 = None
        weighted_graph_0 = module_0.WeightedGraph()
>       var_0 = weighted_graph_0.add_edge(none_type_0, weighted_graph_0)

ALL-SMART/test_graph1_MIO.py:108: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <graph1.WeightedGraph object at 0x78ae56501660>, src = None
dst = <graph1.WeightedGraph object at 0x78ae56501660>, weight = 0

>   ???
E   KeyError: None

graph1:156: KeyError
   - [#  47] COI graph1: 
--------------------------------------------------------------------------------
  150:     
  151:     def add_edge(self, src, dst, weight=0):
  152:         if src not in self.vertices:
  153:             self.add_vertex(src)
- 154:         if dst not in self.vertices:
+ 154:         if not (dst not in self.vertices):
  155:             self.add_vertex(dst)
  156:         self.vertices[src].add_adjacent(dst, weight)
  157:     
  158:     def remove_edge(self, src, dst):
--------------------------------------------------------------------------------
[0.09941 s] killed by ALL-SMART/test_graph1_MIO.py::test_case_16

def test_case_16():
        none_type_0 = None
        weighted_graph_0 = module_0.WeightedGraph()
        var_0 = weighted_graph_0.add_edge(none_type_0, weighted_graph_0)
>       assert len(weighted_graph_0.vertices) == 2
E       AssertionError

ALL-SMART/test_graph1_MIO.py:109: AssertionError
   - [#  48] COI graph1: 
--------------------------------------------------------------------------------
  155:             self.add_vertex(dst)
  156:         self.vertices[src].add_adjacent(dst, weight)
  157:     
  158:     def remove_edge(self, src, dst):
- 159:         if src not in self.vertices:
+ 159:         if not (src not in self.vertices):
  160:             return
  161:         if dst not in self.vertices:
  162:             return
  163:         if dst in self.vertices[src].adjacent:
--------------------------------------------------------------------------------
[0.11683 s] survived
   - [#  49] COI graph1: 
--------------------------------------------------------------------------------
  157:     
  158:     def remove_edge(self, src, dst):
  159:         if src not in self.vertices:
  160:             return
- 161:         if dst not in self.vertices:
+ 161:         if not (dst not in self.vertices):
  162:             return
  163:         if dst in self.vertices[src].adjacent:
  164:             self.vertices[src].remove_adjacent(dst)
--------------------------------------------------------------------------------
[0.11753 s] survived
   - [#  50] COI graph1: 
--------------------------------------------------------------------------------
  159:         if src not in self.vertices:
  160:             return
  161:         if dst not in self.vertices:
  162:             return
- 163:         if dst in self.vertices[src].adjacent:
+ 163:         if not (dst in self.vertices[src].adjacent):
  164:             self.vertices[src].remove_adjacent(dst)
--------------------------------------------------------------------------------
[0.10853 s] killed by ALL-SMART/test_graph1_MIO.py::test_case_20

def test_case_20():
        weighted_graph_0 = module_0.WeightedGraph()
        var_0 = weighted_graph_0.add_vertex(weighted_graph_0)
>       var_1 = weighted_graph_0.remove_edge(weighted_graph_0, weighted_graph_0)

ALL-SMART/test_graph1_MIO.py:130: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graph1:164: in remove_edge
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <graph1.WeightedGraphNode object at 0x78ae563417e0>
node = <graph1.WeightedGraph object at 0x78ae56343bb0>

>   ???
E   KeyError: <graph1.WeightedGraph object at 0x78ae56343bb0>

graph1:137: KeyError
   - [#  51] COI graph1: 
--------------------------------------------------------------------------------
  159:         if src not in self.vertices:
  160:             return
  161:         if dst not in self.vertices:
  162:             return
- 163:         if dst in self.vertices[src].adjacent:
+ 163:         if dst not in self.vertices[src].adjacent:
  164:             self.vertices[src].remove_adjacent(dst)
--------------------------------------------------------------------------------
[0.10435 s] killed by ALL-SMART/test_graph1_MIO.py::test_case_20

def test_case_20():
        weighted_graph_0 = module_0.WeightedGraph()
        var_0 = weighted_graph_0.add_vertex(weighted_graph_0)
>       var_1 = weighted_graph_0.remove_edge(weighted_graph_0, weighted_graph_0)

ALL-SMART/test_graph1_MIO.py:130: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graph1:164: in remove_edge
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <graph1.WeightedGraphNode object at 0x78ae56158640>
node = <graph1.WeightedGraph object at 0x78ae56158d30>

>   ???
E   KeyError: <graph1.WeightedGraph object at 0x78ae56158d30>

graph1:137: KeyError
   - [#  52] OIL graph1: 
--------------------------------------------------------------------------------
   65:             visited[node] = -1
   66:             for neighbor in self.graph[node]:
   67:                 if not (valid(neighbor)):
   68:                     return False
-  69:             return True
-  70:         
+  69:                 break
+  70:             return True
   71:         for node in range(self.verticies):
   72:             
   73:             
   74:             
--------------------------------------------------------------------------------
[0.11886 s] survived
   - [#  53] OIL graph1: 
--------------------------------------------------------------------------------
   78:                     
   79:                     visited = list(map((lambda x: (abs(x))), visited))
   80:                 else:
   81:                     
-  82:                     return True
+  82:                     return Truebreak
   83:         
   84:         return False
   85:     
   86:     def topological_sort(self):
--------------------------------------------------------------------------------
[0.11672 s] survived
   - [#  54] OIL graph1: 
--------------------------------------------------------------------------------
  111:             visited.add(vertex)
  112:             for j in self.graph[vertex]:
  113:                 if j not in visited:
  114:                     dfs(j)
- 115:             
+ 115:                 break
  116:             stack.appendleft(vertex)
  117:         
  118:         for (key, _) in self.graph.items():
  119:             if key not in visited:
--------------------------------------------------------------------------------
[0.11671 s] survived
   - [#  55] OIL graph1: 
--------------------------------------------------------------------------------
  117:         
  118:         for (key, _) in self.graph.items():
  119:             if key not in visited:
  120:                 dfs(key)
- 121:         
+ 121:             break
  122:         return list(stack)
  123: 
  124: class WeightedGraphNode:
  125:     
--------------------------------------------------------------------------------
[0.11771 s] survived
   - [#  56] RIL graph1: 
--------------------------------------------------------------------------------
   62:                 return False
   63:             elif visited[node] == 1:
   64:                 return True
   65:             visited[node] = -1
-  66:             for neighbor in self.graph[node]:
+  66:             for neighbor in reversed(self.graph[node]):
   67:                 if not (valid(neighbor)):
   68:                     return False
   69:             return True
   70:         
--------------------------------------------------------------------------------
[0.11892 s] survived
   - [#  57] RIL graph1: 
--------------------------------------------------------------------------------
   67:                 if not (valid(neighbor)):
   68:                     return False
   69:             return True
   70:         
-  71:         for node in range(self.verticies):
+  71:         for node in reversed(range(self.verticies)):
   72:             
   73:             
   74:             
   75:             if not (visited[node]):
--------------------------------------------------------------------------------
[0.14178 s] killed by ALL-SMART/test_graph1_MOSA.py::test_case_21

def test_case_21():
        bool_0 = True
        weighted_graph_node_0 = module_0.WeightedGraphNode(bool_0)
        int_0 = 23
        graph_0 = module_0.Graph(int_0)
        var_0 = graph_0.topological_sort()
        bool_1 = False
        var_1 = graph_0.add_edge(bool_1, bool_1)
        assert graph_0.graph == {False: [False]}
        var_2 = graph_0.topological_sort()
        var_3 = graph_0.add_edge(bool_1, bool_1)
        assert graph_0.graph == {False: [False, False]}
        graph_1 = module_0.Graph(var_3)
>       var_4 = graph_0.has_cycle()

ALL-SMART/test_graph1_MOSA.py:177: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graph1:77: in has_cycle
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

node = 22

>   ???
E   KeyError: 22

graph1:66: KeyError
   - [#  58] RIL graph1: 
--------------------------------------------------------------------------------
  108:         stack = deque()
  109:         
  110:         def dfs(vertex):
  111:             visited.add(vertex)
- 112:             for j in self.graph[vertex]:
+ 112:             for j in reversed(self.graph[vertex]):
  113:                 if j not in visited:
  114:                     dfs(j)
  115:             
  116:             stack.appendleft(vertex)
--------------------------------------------------------------------------------
[0.11969 s] survived
   - [#  59] RIL graph1: 
--------------------------------------------------------------------------------
  114:                     dfs(j)
  115:             
  116:             stack.appendleft(vertex)
  117:         
- 118:         for (key, _) in self.graph.items():
+ 118:         for (key, _) in reversed(self.graph.items()):
  119:             if key not in visited:
  120:                 dfs(key)
  121:         
  122:         return list(stack)
--------------------------------------------------------------------------------
[0.12014 s] survived
   - [#  60] ROR graph1: 
--------------------------------------------------------------------------------
   32:             source: the source vertex
   33:             destination: the destination vertex
   34: 
   35:         '''
-  36:         if len(self.graph) > self.verticies:
+  36:         if len(self.graph) < self.verticies:
   37:             raise IndexError('Too many verticies in graph.')
   38:         
   39:         if source in self.graph:
   40:             self.graph[source].append(destination)
--------------------------------------------------------------------------------
[0.11390 s] killed by ALL-SMART/test_graph1_MIO.py::test_case_0

def test_case_0():
        int_0 = 3280
        graph_0 = module_0.Graph(int_0)
>       var_0 = graph_0.add_edge(graph_0, int_0)

ALL-SMART/test_graph1_MIO.py:8: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <graph1.Graph object at 0x78ae56409b70>
source = <graph1.Graph object at 0x78ae56409b70>, destination = 3280

>   ???
E   IndexError: Too many verticies in graph.

graph1:37: IndexError
   - [#  61] ROR graph1: 
--------------------------------------------------------------------------------
   32:             source: the source vertex
   33:             destination: the destination vertex
   34: 
   35:         '''
-  36:         if len(self.graph) > self.verticies:
+  36:         if len(self.graph) >= self.verticies:
   37:             raise IndexError('Too many verticies in graph.')
   38:         
   39:         if source in self.graph:
   40:             self.graph[source].append(destination)
--------------------------------------------------------------------------------
[0.11184 s] killed by ALL-SMART/test_graph1_WHOLE_SUITE.py::test_case_7

def test_case_7():
        bool_0 = False
        graph_0 = module_0.Graph(bool_0)
        graph_1 = module_0.Graph(bool_0)
        var_0 = graph_1.topological_sort()
        weighted_graph_0 = module_0.WeightedGraph()
        var_1 = graph_1.topological_sort()
>       var_2 = graph_0.add_edge(bool_0, bool_0)

ALL-SMART/test_graph1_WHOLE_SUITE.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <graph1.Graph object at 0x78ae562b46d0>, source = False
destination = False

>   ???
E   IndexError: Too many verticies in graph.

graph1:37: IndexError
   - [#  62] ROR graph1: 
--------------------------------------------------------------------------------
   57:         visited = [0] * self.verticies
   58:         
   59:         def valid(node):
   60:             
-  61:             if visited[node] == -1:
+  61:             if visited[node] != -1:
   62:                 return False
   63:             elif visited[node] == 1:
   64:                 return True
   65:             visited[node] = -1
--------------------------------------------------------------------------------
[0.09541 s] killed by ALL-SMART/test_graph1_MIO.py::test_case_6

def test_case_6():
        bool_0 = True
        graph_0 = module_0.Graph(bool_0)
        bool_1 = False
        var_0 = graph_0.add_edge(graph_0, bool_1)
        assert len(graph_0.graph) == 2
        var_1 = graph_0.has_cycle()
>       assert var_1 is False
E       AssertionError

ALL-SMART/test_graph1_MIO.py:47: AssertionError
   - [#  63] ROR graph1: 
--------------------------------------------------------------------------------
   59:         def valid(node):
   60:             
   61:             if visited[node] == -1:
   62:                 return False
-  63:             elif visited[node] == 1:
+  63:             elif visited[node] != 1:
   64:                 return True
   65:             visited[node] = -1
   66:             for neighbor in self.graph[node]:
   67:                 if not (valid(neighbor)):
--------------------------------------------------------------------------------
[0.09393 s] killed by ALL-SMART/test_graph1_MIO.py::test_case_7

def test_case_7():
        bool_0 = True
        graph_0 = module_0.Graph(bool_0)
        bool_1 = False
        var_0 = graph_0.add_edge(bool_1, bool_1)
        assert graph_0.graph == {False: [False]}
        var_1 = graph_0.has_cycle()
>       assert var_1 is True
E       AssertionError

ALL-SMART/test_graph1_MIO.py:56: AssertionError
   - [#  64] SDI graph1: 
--------------------------------------------------------------------------------
    1: from collections import defaultdict, deque
    2: 
    3: class GraphNode:
    4:     
-   5:     def __init__(self, val):
-   6:         self.val = val
-   7:         self.adjacent_list = set()
-   8:     
+   5:     @staticmethod
+   6:     def __init__(self, val):
+   7:         self.val = val
+   8:         self.adjacent_list = set()
    9:     def add_adjacent(self, node):
   10:         self.adjacent_list.add(node)
   11:     
   12:     def remove_adjacent(self, node):
--------------------------------------------------------------------------------
[0.10761 s] incompetent

TypeError: /home/lucca/teste/python_experiments2/graph1/ALL-SMART/test_graph1_MIO.py:146: TypeError: GraphNode.__init__() missing 1 required positional argument: 'val'

   - [#  65] SDI graph1: 
--------------------------------------------------------------------------------
    5:     def __init__(self, val):
    6:         self.val = val
    7:         self.adjacent_list = set()
    8:     
-   9:     def add_adjacent(self, node):
-  10:         self.adjacent_list.add(node)
-  11:     
+   9:     @staticmethod
+  10:     def add_adjacent(self, node):
+  11:         self.adjacent_list.add(node)
   12:     def remove_adjacent(self, node):
   13:         self.adjacent_list.remove(node)
   14: 
   15: class Graph:
--------------------------------------------------------------------------------
[0.10914 s] incompetent

TypeError: /home/lucca/teste/python_experiments2/graph1/ALL-SMART/test_graph1_MIO.py:151: TypeError: GraphNode.add_adjacent() missing 1 required positional argument: 'node'

   - [#  66] SDI graph1: 
--------------------------------------------------------------------------------
    8:     
    9:     def add_adjacent(self, node):
   10:         self.adjacent_list.add(node)
   11:     
-  12:     def remove_adjacent(self, node):
-  13:         self.adjacent_list.remove(node)
-  14: 
+  12:     @staticmethod
+  13:     def remove_adjacent(self, node):
+  14:         self.adjacent_list.remove(node)
   15: class Graph:
   16:     '''
   17:     A directed graph represented with an adjacency list.
   18:     '''
--------------------------------------------------------------------------------
[0.11872 s] survived
   - [#  67] SDI graph1: 
--------------------------------------------------------------------------------
   16:     '''
   17:     A directed graph represented with an adjacency list.
   18:     '''
   19:     
-  20:     def __init__(self, verticies):
-  21:         self.graph = {}
-  22:         self.verticies = verticies
-  23:     
+  20:     @staticmethod
+  21:     def __init__(self, verticies):
+  22:         self.graph = {}
+  23:         self.verticies = verticies
   24:     def add_edge(self, source, destination):
   25:         '''
   26:         Add an edge to the graph.
   27: 
--------------------------------------------------------------------------------
[0.11015 s] incompetent

TypeError: /home/lucca/teste/python_experiments2/graph1/ALL-SMART/test_graph1_MIO.py:7: TypeError: Graph.__init__() missing 1 required positional argument: 'verticies'

   - [#  68] SDI graph1: 
--------------------------------------------------------------------------------
   20:     def __init__(self, verticies):
   21:         self.graph = {}
   22:         self.verticies = verticies
   23:     
-  24:     def add_edge(self, source, destination):
-  25:         '''
-  26:         Add an edge to the graph.
-  27: 
-  28:         Add an edge pointing from source vertex
-  29:         to destination vertex.
-  30: 
-  31:         Args:
-  32:             source: the source vertex
-  33:             destination: the destination vertex
-  34: 
-  35:         '''
-  36:         if len(self.graph) > self.verticies:
-  37:             raise IndexError('Too many verticies in graph.')
-  38:         
-  39:         if source in self.graph:
-  40:             self.graph[source].append(destination)
-  41:         else:
-  42:             self.graph[source] = [destination]
-  43:         
-  44:         if destination not in self.graph:
-  45:             self.graph[destination] = []
-  46:     
+  24:     @staticmethod
+  25:     def add_edge(self, source, destination):
+  26:         '''
+  27:         Add an edge to the graph.
+  28: 
+  29:         Add an edge pointing from source vertex
+  30:         to destination vertex.
+  31: 
+  32:         Args:
+  33:             source: the source vertex
+  34:             destination: the destination vertex
+  35: 
+  36:         '''
+  37:         if len(self.graph) > self.verticies:
+  38:             raise IndexError('Too many verticies in graph.')
+  39:         
+  40:         if source in self.graph:
+  41:             self.graph[source].append(destination)
+  42:         else:
+  43:             self.graph[source] = [destination]
+  44:         
+  45:         if destination not in self.graph:
+  46:             self.graph[destination] = []
   47:     def has_cycle(self):
   48:         '''
   49:         Detect if a graph has a cycle.
   50: 
--------------------------------------------------------------------------------
[0.08892 s] incompetent

TypeError: /home/lucca/teste/python_experiments2/graph1/ALL-SMART/test_graph1_MIO.py:8: TypeError: Graph.add_edge() missing 1 required positional argument: 'destination'

   - [#  69] SDI graph1: 
--------------------------------------------------------------------------------
   43:         
   44:         if destination not in self.graph:
   45:             self.graph[destination] = []
   46:     
-  47:     def has_cycle(self):
-  48:         '''
-  49:         Detect if a graph has a cycle.
-  50: 
-  51:         Returns:
-  52:             True if the graph has a cycle and
-  53:             False if the graph is acyclic.
-  54: 
-  55:         '''
-  56:         
-  57:         visited = [0] * self.verticies
-  58:         
-  59:         def valid(node):
-  60:             
-  61:             if visited[node] == -1:
-  62:                 return False
-  63:             elif visited[node] == 1:
-  64:                 return True
-  65:             visited[node] = -1
-  66:             for neighbor in self.graph[node]:
-  67:                 if not (valid(neighbor)):
-  68:                     return False
-  69:             return True
-  70:         
-  71:         for node in range(self.verticies):
-  72:             
+  47:     @staticmethod
+  48:     def has_cycle(self):
+  49:         '''
+  50:         Detect if a graph has a cycle.
+  51: 
+  52:         Returns:
+  53:             True if the graph has a cycle and
+  54:             False if the graph is acyclic.
+  55: 
+  56:         '''
+  57:         
+  58:         visited = [0] * self.verticies
+  59:         
+  60:         def valid(node):
+  61:             
+  62:             if visited[node] == -1:
+  63:                 return False
+  64:             elif visited[node] == 1:
+  65:                 return True
+  66:             visited[node] = -1
+  67:             for neighbor in self.graph[node]:
+  68:                 if not (valid(neighbor)):
+  69:                     return False
+  70:             return True
+  71:         
+  72:         for node in range(self.verticies):
   73:             
   74:             
-  75:             if not (visited[node]):
-  76:                 
-  77:                 if valid(node):
-  78:                     
-  79:                     visited = list(map((lambda x: (abs(x))), visited))
-  80:                 else:
-  81:                     
-  82:                     return True
-  83:         
-  84:         return False
-  85:     
+  75:             
+  76:             if not (visited[node]):
+  77:                 
+  78:                 if valid(node):
+  79:                     
+  80:                     visited = list(map((lambda x: (abs(x))), visited))
+  81:                 else:
+  82:                     
+  83:                     return True
+  84:         
+  85:         return False
   86:     def topological_sort(self):
   87:         """
   88:         Sort the graph topologically.
   89: 
--------------------------------------------------------------------------------
[0.09198 s] incompetent

TypeError: /home/lucca/teste/python_experiments2/graph1/ALL-SMART/test_graph1_MIO.py:37: TypeError: Graph.has_cycle() missing 1 required positional argument: 'self'

   - [#  70] SDI graph1: 
--------------------------------------------------------------------------------
   82:                     return True
   83:         
   84:         return False
   85:     
-  86:     def topological_sort(self):
-  87:         """
-  88:         Sort the graph topologically.
-  89: 
-  90:         A topological sort lists nodes in such a way
-  91:         that every node 's' in 's' -> 'd' directed pairs
-  92:         is listed before 'd.'  This will not work in a 
-  93:         graph that contains cycles.
-  94: 
-  95:         The algorithm looks at every node, and does a
-  96:         dfs for each node adjacent to the node and then adds
-  97:         the originating node to a stack once all adjacent
-  98:         nodes have been searched.  In the end, the stack
-  99:         will be in order of a possible topological sort.
- 100: 
- 101:         Topological sorts are not necessarily unique.
- 102: 
- 103:         Returns:
- 104:             A list of vertices in a topological ordering.
- 105: 
- 106:         """
- 107:         visited = set()
- 108:         stack = deque()
- 109:         
- 110:         def dfs(vertex):
- 111:             visited.add(vertex)
- 112:             for j in self.graph[vertex]:
- 113:                 if j not in visited:
- 114:                     dfs(j)
- 115:             
- 116:             stack.appendleft(vertex)
- 117:         
- 118:         for (key, _) in self.graph.items():
- 119:             if key not in visited:
- 120:                 dfs(key)
- 121:         
- 122:         return list(stack)
- 123: 
+  86:     @staticmethod
+  87:     def topological_sort(self):
+  88:         """
+  89:         Sort the graph topologically.
+  90: 
+  91:         A topological sort lists nodes in such a way
+  92:         that every node 's' in 's' -> 'd' directed pairs
+  93:         is listed before 'd.'  This will not work in a 
+  94:         graph that contains cycles.
+  95: 
+  96:         The algorithm looks at every node, and does a
+  97:         dfs for each node adjacent to the node and then adds
+  98:         the originating node to a stack once all adjacent
+  99:         nodes have been searched.  In the end, the stack
+ 100:         will be in order of a possible topological sort.
+ 101: 
+ 102:         Topological sorts are not necessarily unique.
+ 103: 
+ 104:         Returns:
+ 105:             A list of vertices in a topological ordering.
+ 106: 
+ 107:         """
+ 108:         visited = set()
+ 109:         stack = deque()
+ 110:         
+ 111:         def dfs(vertex):
+ 112:             visited.add(vertex)
+ 113:             for j in self.graph[vertex]:
+ 114:                 if j not in visited:
+ 115:                     dfs(j)
+ 116:             
+ 117:             stack.appendleft(vertex)
+ 118:         
+ 119:         for (key, _) in self.graph.items():
+ 120:             if key not in visited:
+ 121:                 dfs(key)
+ 122:         
+ 123:         return list(stack)
  124: class WeightedGraphNode:
  125:     
  126:     def __init__(self, val):
  127:         self.val = val
--------------------------------------------------------------------------------
[0.09734 s] incompetent

TypeError: /home/lucca/teste/python_experiments2/graph1/ALL-SMART/test_graph1_MIO.py:70: TypeError: Graph.topological_sort() missing 1 required positional argument: 'self'

   - [#  71] SDI graph1: 
--------------------------------------------------------------------------------
  122:         return list(stack)
  123: 
  124: class WeightedGraphNode:
  125:     
- 126:     def __init__(self, val):
- 127:         self.val = val
- 128:         self.adjacent = {}
- 129:     
+ 126:     @staticmethod
+ 127:     def __init__(self, val):
+ 128:         self.val = val
+ 129:         self.adjacent = {}
  130:     def __str__(self):
  131:         return (str(self.val) + ' adjacent: ') + str([x for x in self.adjacent])
  132:     
  133:     def add_adjacent(self, node, weight=0):
--------------------------------------------------------------------------------
[0.09728 s] incompetent

TypeError: graph1:148: TypeError: WeightedGraphNode.__init__() missing 1 required positional argument: 'val'

   - [#  72] SDI graph1: 
--------------------------------------------------------------------------------
  126:     def __init__(self, val):
  127:         self.val = val
  128:         self.adjacent = {}
  129:     
- 130:     def __str__(self):
- 131:         return (str(self.val) + ' adjacent: ') + str([x for x in self.adjacent])
- 132:     
+ 130:     @staticmethod
+ 131:     def __str__(self):
+ 132:         return (str(self.val) + ' adjacent: ') + str([x for x in self.adjacent])
  133:     def add_adjacent(self, node, weight=0):
  134:         self.adjacent[node] = weight
  135:     
  136:     def remove_adjacent(self, node):
--------------------------------------------------------------------------------
[0.09870 s] incompetent

TypeError: graph1:145: TypeError: WeightedGraphNode.__str__() missing 1 required positional argument: 'self'

   - [#  73] SDI graph1: 
--------------------------------------------------------------------------------
  129:     
  130:     def __str__(self):
  131:         return (str(self.val) + ' adjacent: ') + str([x for x in self.adjacent])
  132:     
- 133:     def add_adjacent(self, node, weight=0):
- 134:         self.adjacent[node] = weight
- 135:     
+ 133:     @staticmethod
+ 134:     def add_adjacent(self, node, weight=0):
+ 135:         self.adjacent[node] = weight
  136:     def remove_adjacent(self, node):
  137:         del self.adjacent[node]
  138: 
  139: class WeightedGraph:
--------------------------------------------------------------------------------
[0.10144 s] killed by ALL-SMART/test_graph1_MIO.py::test_case_12

def test_case_12():
        weighted_graph_0 = module_0.WeightedGraph()
        none_type_0 = None
>       var_0 = weighted_graph_0.add_edge(none_type_0, none_type_0)

ALL-SMART/test_graph1_MIO.py:87: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graph1:156: in add_edge
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = None, node = 0, weight = 0

>   ???
E   AttributeError: 'NoneType' object has no attribute 'adjacent'

graph1:135: AttributeError
   - [#  74] SDI graph1: 
--------------------------------------------------------------------------------
  132:     
  133:     def add_adjacent(self, node, weight=0):
  134:         self.adjacent[node] = weight
  135:     
- 136:     def remove_adjacent(self, node):
- 137:         del self.adjacent[node]
- 138: 
+ 136:     @staticmethod
+ 137:     def remove_adjacent(self, node):
+ 138:         del self.adjacent[node]
  139: class WeightedGraph:
  140:     
  141:     def __init__(self):
  142:         self.vertices = {}
--------------------------------------------------------------------------------
[0.10602 s] incompetent

TypeError: graph1:164: TypeError: WeightedGraphNode.remove_adjacent() missing 1 required positional argument: 'node'

   - [#  75] SDI graph1: 
--------------------------------------------------------------------------------
  137:         del self.adjacent[node]
  138: 
  139: class WeightedGraph:
  140:     
- 141:     def __init__(self):
- 142:         self.vertices = {}
- 143:     
+ 141:     @staticmethod
+ 142:     def __init__(self):
+ 143:         self.vertices = {}
  144:     def __str__(self):
  145:         return ', '.join([node.__str__() for node in self.vertices.values()])
  146:     
  147:     def add_vertex(self, val):
--------------------------------------------------------------------------------
[0.09609 s] incompetent

TypeError: /home/lucca/teste/python_experiments2/graph1/ALL-SMART/test_graph1_MIO.py:85: TypeError: WeightedGraph.__init__() missing 1 required positional argument: 'self'

   - [#  76] SDI graph1: 
--------------------------------------------------------------------------------
  140:     
  141:     def __init__(self):
  142:         self.vertices = {}
  143:     
- 144:     def __str__(self):
- 145:         return ', '.join([node.__str__() for node in self.vertices.values()])
- 146:     
+ 144:     @staticmethod
+ 145:     def __str__(self):
+ 146:         return ', '.join([node.__str__() for node in self.vertices.values()])
  147:     def add_vertex(self, val):
  148:         vertex = WeightedGraphNode(val)
  149:         self.vertices[val] = vertex
  150:     
--------------------------------------------------------------------------------
[0.11781 s] incompetent

TypeError: /home/lucca/teste/python_experiments2/graph1/ALL-SMART/test_graph1_MIO.py:88: TypeError: WeightedGraph.__str__() missing 1 required positional argument: 'self'

   - [#  77] SDI graph1: 
--------------------------------------------------------------------------------
  143:     
  144:     def __str__(self):
  145:         return ', '.join([node.__str__() for node in self.vertices.values()])
  146:     
- 147:     def add_vertex(self, val):
- 148:         vertex = WeightedGraphNode(val)
- 149:         self.vertices[val] = vertex
- 150:     
+ 147:     @staticmethod
+ 148:     def add_vertex(self, val):
+ 149:         vertex = WeightedGraphNode(val)
+ 150:         self.vertices[val] = vertex
  151:     def add_edge(self, src, dst, weight=0):
  152:         if src not in self.vertices:
  153:             self.add_vertex(src)
  154:         if dst not in self.vertices:
--------------------------------------------------------------------------------
[0.09417 s] incompetent

TypeError: graph1:153: TypeError: WeightedGraph.add_vertex() missing 1 required positional argument: 'val'

   - [#  78] SDI graph1: 
--------------------------------------------------------------------------------
  147:     def add_vertex(self, val):
  148:         vertex = WeightedGraphNode(val)
  149:         self.vertices[val] = vertex
  150:     
- 151:     def add_edge(self, src, dst, weight=0):
- 152:         if src not in self.vertices:
- 153:             self.add_vertex(src)
- 154:         if dst not in self.vertices:
- 155:             self.add_vertex(dst)
- 156:         self.vertices[src].add_adjacent(dst, weight)
- 157:     
+ 151:     @staticmethod
+ 152:     def add_edge(self, src, dst, weight=0):
+ 153:         if src not in self.vertices:
+ 154:             self.add_vertex(src)
+ 155:         if dst not in self.vertices:
+ 156:             self.add_vertex(dst)
+ 157:         self.vertices[src].add_adjacent(dst, weight)
  158:     def remove_edge(self, src, dst):
  159:         if src not in self.vertices:
  160:             return
  161:         if dst not in self.vertices:
--------------------------------------------------------------------------------
[0.09571 s] incompetent

TypeError: /home/lucca/teste/python_experiments2/graph1/ALL-SMART/test_graph1_MIO.py:87: TypeError: WeightedGraph.add_edge() missing 1 required positional argument: 'dst'

   - [#  79] SDI graph1: 
--------------------------------------------------------------------------------
  154:         if dst not in self.vertices:
  155:             self.add_vertex(dst)
  156:         self.vertices[src].add_adjacent(dst, weight)
  157:     
- 158:     def remove_edge(self, src, dst):
- 159:         if src not in self.vertices:
- 160:             return
- 161:         if dst not in self.vertices:
- 162:             return
- 163:         if dst in self.vertices[src].adjacent:
- 164:             self.vertices[src].remove_adjacent(dst)
+ 158:     @staticmethod
+ 159:     def remove_edge(self, src, dst):
+ 160:         if src not in self.vertices:
+ 161:             return
+ 162:         if dst not in self.vertices:
+ 163:             return
+ 164:         if dst in self.vertices[src].adjacent:
+ 165:             self.vertices[src].remove_adjacent(dst)
--------------------------------------------------------------------------------
[0.09847 s] incompetent

TypeError: /home/lucca/teste/python_experiments2/graph1/ALL-SMART/test_graph1_MIO.py:124: TypeError: WeightedGraph.remove_edge() missing 1 required positional argument: 'dst'

   - [#  80] SDL graph1: 
--------------------------------------------------------------------------------
    2: 
    3: class GraphNode:
    4:     
    5:     def __init__(self, val):
-   6:         self.val = val
+   6:         pass
    7:         self.adjacent_list = set()
    8:     
    9:     def add_adjacent(self, node):
   10:         self.adjacent_list.add(node)
--------------------------------------------------------------------------------
[0.11897 s] survived
   - [#  81] SDL graph1: 
--------------------------------------------------------------------------------
    3: class GraphNode:
    4:     
    5:     def __init__(self, val):
    6:         self.val = val
-   7:         self.adjacent_list = set()
+   7:         pass
    8:     
    9:     def add_adjacent(self, node):
   10:         self.adjacent_list.add(node)
   11:     
--------------------------------------------------------------------------------
[0.10814 s] killed by ALL-SMART/test_graph1_MIO.py::test_case_25

def test_case_25():
        int_0 = 5852
        graph_node_0 = module_0.GraphNode(int_0)
>       var_0 = graph_node_0.add_adjacent(graph_node_0)

ALL-SMART/test_graph1_MIO.py:151: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <graph1.GraphNode object at 0x78ae5606db70>
node = <graph1.GraphNode object at 0x78ae5606db70>

>   ???
E   AttributeError: 'GraphNode' object has no attribute 'adjacent_list'

graph1:10: AttributeError
   - [#  82] SDL graph1: 
--------------------------------------------------------------------------------
    6:         self.val = val
    7:         self.adjacent_list = set()
    8:     
    9:     def add_adjacent(self, node):
-  10:         self.adjacent_list.add(node)
+  10:         pass
   11:     
   12:     def remove_adjacent(self, node):
   13:         self.adjacent_list.remove(node)
   14: 
--------------------------------------------------------------------------------
[0.13871 s] survived
   - [#  83] SDL graph1: 
--------------------------------------------------------------------------------
    9:     def add_adjacent(self, node):
   10:         self.adjacent_list.add(node)
   11:     
   12:     def remove_adjacent(self, node):
-  13:         self.adjacent_list.remove(node)
+  13:         pass
   14: 
   15: class Graph:
   16:     '''
   17:     A directed graph represented with an adjacency list.
--------------------------------------------------------------------------------
[0.11748 s] survived
   - [#  84] SDL graph1: 
--------------------------------------------------------------------------------
   17:     A directed graph represented with an adjacency list.
   18:     '''
   19:     
   20:     def __init__(self, verticies):
-  21:         self.graph = {}
+  21:         pass
   22:         self.verticies = verticies
   23:     
   24:     def add_edge(self, source, destination):
   25:         '''
--------------------------------------------------------------------------------
[0.08906 s] killed by ALL-SMART/test_graph1_MIO.py::test_case_0

def test_case_0():
        int_0 = 3280
        graph_0 = module_0.Graph(int_0)
>       var_0 = graph_0.add_edge(graph_0, int_0)

ALL-SMART/test_graph1_MIO.py:8: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <graph1.Graph object at 0x78ae563fed40>
source = <graph1.Graph object at 0x78ae563fed40>, destination = 3280

>   ???
E   AttributeError: 'Graph' object has no attribute 'graph'

graph1:36: AttributeError
   - [#  85] SDL graph1: 
--------------------------------------------------------------------------------
   18:     '''
   19:     
   20:     def __init__(self, verticies):
   21:         self.graph = {}
-  22:         self.verticies = verticies
+  22:         pass
   23:     
   24:     def add_edge(self, source, destination):
   25:         '''
   26:         Add an edge to the graph.
--------------------------------------------------------------------------------
[0.09179 s] killed by ALL-SMART/test_graph1_MIO.py::test_case_0

def test_case_0():
        int_0 = 3280
        graph_0 = module_0.Graph(int_0)
>       var_0 = graph_0.add_edge(graph_0, int_0)

ALL-SMART/test_graph1_MIO.py:8: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <graph1.Graph object at 0x78ae56276d70>
source = <graph1.Graph object at 0x78ae56276d70>, destination = 3280

>   ???
E   AttributeError: 'Graph' object has no attribute 'verticies'

graph1:36: AttributeError
   - [#  86] SDL graph1: 
--------------------------------------------------------------------------------
   36:         if len(self.graph) > self.verticies:
   37:             raise IndexError('Too many verticies in graph.')
   38:         
   39:         if source in self.graph:
-  40:             self.graph[source].append(destination)
+  40:             pass
   41:         else:
   42:             self.graph[source] = [destination]
   43:         
   44:         if destination not in self.graph:
--------------------------------------------------------------------------------
[0.11679 s] killed by ALL-SMART/test_graph1_WHOLE_SUITE.py::test_case_8

def test_case_8():
        bool_0 = True
        graph_0 = module_0.Graph(bool_0)
        var_0 = graph_0.add_edge(bool_0, bool_0)
        assert graph_0.graph == {True: [True]}
        var_1 = graph_0.add_edge(bool_0, var_0)
>       assert graph_0.graph == {True: [True, None], None: []}
E       AssertionError

ALL-SMART/test_graph1_WHOLE_SUITE.py:80: AssertionError
   - [#  87] SDL graph1: 
--------------------------------------------------------------------------------
   38:         
   39:         if source in self.graph:
   40:             self.graph[source].append(destination)
   41:         else:
-  42:             self.graph[source] = [destination]
+  42:             pass
   43:         
   44:         if destination not in self.graph:
   45:             self.graph[destination] = []
   46:     
--------------------------------------------------------------------------------
[0.08975 s] killed by ALL-SMART/test_graph1_MIO.py::test_case_0

def test_case_0():
        int_0 = 3280
        graph_0 = module_0.Graph(int_0)
        var_0 = graph_0.add_edge(graph_0, int_0)
>       assert len(graph_0.graph) == 2
E       AssertionError

ALL-SMART/test_graph1_MIO.py:9: AssertionError
   - [#  88] SDL graph1: 
--------------------------------------------------------------------------------
   41:         else:
   42:             self.graph[source] = [destination]
   43:         
   44:         if destination not in self.graph:
-  45:             self.graph[destination] = []
+  45:             pass
   46:     
   47:     def has_cycle(self):
   48:         '''
   49:         Detect if a graph has a cycle.
--------------------------------------------------------------------------------
[0.08989 s] killed by ALL-SMART/test_graph1_MIO.py::test_case_0

def test_case_0():
        int_0 = 3280
        graph_0 = module_0.Graph(int_0)
        var_0 = graph_0.add_edge(graph_0, int_0)
>       assert len(graph_0.graph) == 2
E       AssertionError

ALL-SMART/test_graph1_MIO.py:9: AssertionError
   - [#  89] SDL graph1: 
--------------------------------------------------------------------------------
   53:             False if the graph is acyclic.
   54: 
   55:         '''
   56:         
-  57:         visited = [0] * self.verticies
+  57:         pass
   58:         
   59:         def valid(node):
   60:             
   61:             if visited[node] == -1:
--------------------------------------------------------------------------------
[0.08891 s] killed by ALL-SMART/test_graph1_MIO.py::test_case_6

def test_case_6():
        bool_0 = True
        graph_0 = module_0.Graph(bool_0)
        bool_1 = False
        var_0 = graph_0.add_edge(graph_0, bool_1)
        assert len(graph_0.graph) == 2
>       var_1 = graph_0.has_cycle()

ALL-SMART/test_graph1_MIO.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <graph1.Graph object at 0x78ae563c5de0>

>   ???
E   UnboundLocalError: local variable 'visited' referenced before assignment

graph1:75: UnboundLocalError
   - [#  90] SDL graph1: 
--------------------------------------------------------------------------------
   58:         
   59:         def valid(node):
   60:             
   61:             if visited[node] == -1:
-  62:                 return False
+  62:                 pass
   63:             elif visited[node] == 1:
   64:                 return True
   65:             visited[node] = -1
   66:             for neighbor in self.graph[node]:
--------------------------------------------------------------------------------
[0.12002 s] killed by ALL-SMART/test_graph1_MIO.py::test_case_7

def test_case_7():
        bool_0 = True
        graph_0 = module_0.Graph(bool_0)
        bool_1 = False
        var_0 = graph_0.add_edge(bool_1, bool_1)
        assert graph_0.graph == {False: [False]}
>       var_1 = graph_0.has_cycle()

ALL-SMART/test_graph1_MIO.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graph1:77: in has_cycle
    ???
graph1:67: in valid
    ???
graph1:67: in valid
    ???
E   RecursionError: maximum recursion depth exceeded in comparison
!!! Recursion detected (same locals & position)
   - [#  91] SDL graph1: 
--------------------------------------------------------------------------------
   60:             
   61:             if visited[node] == -1:
   62:                 return False
   63:             elif visited[node] == 1:
-  64:                 return True
+  64:                 pass
   65:             visited[node] = -1
   66:             for neighbor in self.graph[node]:
   67:                 if not (valid(neighbor)):
   68:                     return False
--------------------------------------------------------------------------------
[0.11764 s] survived
   - [#  92] SDL graph1: 
--------------------------------------------------------------------------------
   61:             if visited[node] == -1:
   62:                 return False
   63:             elif visited[node] == 1:
   64:                 return True
-  65:             visited[node] = -1
+  65:             pass
   66:             for neighbor in self.graph[node]:
   67:                 if not (valid(neighbor)):
   68:                     return False
   69:             return True
--------------------------------------------------------------------------------
[0.09669 s] killed by ALL-SMART/test_graph1_MIO.py::test_case_7

def test_case_7():
        bool_0 = True
        graph_0 = module_0.Graph(bool_0)
        bool_1 = False
        var_0 = graph_0.add_edge(bool_1, bool_1)
        assert graph_0.graph == {False: [False]}
>       var_1 = graph_0.has_cycle()

ALL-SMART/test_graph1_MIO.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graph1:77: in has_cycle
    ???
graph1:67: in valid
    ???
graph1:67: in valid
    ???
E   RecursionError: maximum recursion depth exceeded in comparison
!!! Recursion detected (same locals & position)
   - [#  93] SDL graph1: 
--------------------------------------------------------------------------------
   64:                 return True
   65:             visited[node] = -1
   66:             for neighbor in self.graph[node]:
   67:                 if not (valid(neighbor)):
-  68:                     return False
+  68:                     pass
   69:             return True
   70:         
   71:         for node in range(self.verticies):
   72:             
--------------------------------------------------------------------------------
[0.09640 s] killed by ALL-SMART/test_graph1_MIO.py::test_case_7

def test_case_7():
        bool_0 = True
        graph_0 = module_0.Graph(bool_0)
        bool_1 = False
        var_0 = graph_0.add_edge(bool_1, bool_1)
        assert graph_0.graph == {False: [False]}
        var_1 = graph_0.has_cycle()
>       assert var_1 is True
E       AssertionError

ALL-SMART/test_graph1_MIO.py:56: AssertionError
   - [#  94] SDL graph1: 
--------------------------------------------------------------------------------
   65:             visited[node] = -1
   66:             for neighbor in self.graph[node]:
   67:                 if not (valid(neighbor)):
   68:                     return False
-  69:             return True
+  69:             pass
   70:         
   71:         for node in range(self.verticies):
   72:             
   73:             
--------------------------------------------------------------------------------
[0.09715 s] killed by ALL-SMART/test_graph1_MIO.py::test_case_6

def test_case_6():
        bool_0 = True
        graph_0 = module_0.Graph(bool_0)
        bool_1 = False
        var_0 = graph_0.add_edge(graph_0, bool_1)
        assert len(graph_0.graph) == 2
        var_1 = graph_0.has_cycle()
>       assert var_1 is False
E       AssertionError

ALL-SMART/test_graph1_MIO.py:47: AssertionError
   - [#  95] SDL graph1: 
--------------------------------------------------------------------------------
   75:             if not (visited[node]):
   76:                 
   77:                 if valid(node):
   78:                     
-  79:                     visited = list(map((lambda x: (abs(x))), visited))
+  79:                     pass
   80:                 else:
   81:                     
   82:                     return True
   83:         
--------------------------------------------------------------------------------
[0.11593 s] survived
   - [#  96] SDL graph1: 
--------------------------------------------------------------------------------
   78:                     
   79:                     visited = list(map((lambda x: (abs(x))), visited))
   80:                 else:
   81:                     
-  82:                     return True
+  82:                     pass
   83:         
   84:         return False
   85:     
   86:     def topological_sort(self):
--------------------------------------------------------------------------------
[0.09543 s] killed by ALL-SMART/test_graph1_MIO.py::test_case_7

def test_case_7():
        bool_0 = True
        graph_0 = module_0.Graph(bool_0)
        bool_1 = False
        var_0 = graph_0.add_edge(bool_1, bool_1)
        assert graph_0.graph == {False: [False]}
        var_1 = graph_0.has_cycle()
>       assert var_1 is True
E       AssertionError

ALL-SMART/test_graph1_MIO.py:56: AssertionError
   - [#  97] SDL graph1: 
--------------------------------------------------------------------------------
   80:                 else:
   81:                     
   82:                     return True
   83:         
-  84:         return False
+  84:         pass
   85:     
   86:     def topological_sort(self):
   87:         """
   88:         Sort the graph topologically.
--------------------------------------------------------------------------------
[0.09449 s] killed by ALL-SMART/test_graph1_MIO.py::test_case_5

def test_case_5():
        int_0 = -3972
        graph_0 = module_0.Graph(int_0)
        var_0 = graph_0.has_cycle()
>       assert var_0 is False
E       AssertionError

ALL-SMART/test_graph1_MIO.py:38: AssertionError
   - [#  98] SDL graph1: 
--------------------------------------------------------------------------------
  103:         Returns:
  104:             A list of vertices in a topological ordering.
  105: 
  106:         """
- 107:         visited = set()
+ 107:         pass
  108:         stack = deque()
  109:         
  110:         def dfs(vertex):
  111:             visited.add(vertex)
--------------------------------------------------------------------------------
[0.11908 s] killed by ALL-SMART/test_graph1_MIO.py::test_case_9

def test_case_9():
        int_0 = 1135
        graph_0 = module_0.Graph(int_0)
        var_0 = graph_0.add_edge(int_0, int_0)
        assert graph_0.graph == {1135: [1135]}
>       var_1 = graph_0.topological_sort()

ALL-SMART/test_graph1_MIO.py:70: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <graph1.Graph object at 0x78ae565a1c00>

>   ???
E   NameError: name 'visited' is not defined

graph1:119: NameError
   - [#  99] SDL graph1: 
--------------------------------------------------------------------------------
  104:             A list of vertices in a topological ordering.
  105: 
  106:         """
  107:         visited = set()
- 108:         stack = deque()
+ 108:         pass
  109:         
  110:         def dfs(vertex):
  111:             visited.add(vertex)
  112:             for j in self.graph[vertex]:
--------------------------------------------------------------------------------
[0.10371 s] killed by ALL-SMART/test_graph1_MIO.py::test_case_9

def test_case_9():
        int_0 = 1135
        graph_0 = module_0.Graph(int_0)
        var_0 = graph_0.add_edge(int_0, int_0)
        assert graph_0.graph == {1135: [1135]}
>       var_1 = graph_0.topological_sort()

ALL-SMART/test_graph1_MIO.py:70: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graph1:120: in topological_sort
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

vertex = 1135

>   ???
E   NameError: name 'stack' is not defined

graph1:116: NameError
   - [# 100] SDL graph1: 
--------------------------------------------------------------------------------
  107:         visited = set()
  108:         stack = deque()
  109:         
  110:         def dfs(vertex):
- 111:             visited.add(vertex)
+ 111:             pass
  112:             for j in self.graph[vertex]:
  113:                 if j not in visited:
  114:                     dfs(j)
  115:             
--------------------------------------------------------------------------------
[0.10202 s] killed by ALL-SMART/test_graph1_MIO.py::test_case_9

def test_case_9():
        int_0 = 1135
        graph_0 = module_0.Graph(int_0)
        var_0 = graph_0.add_edge(int_0, int_0)
        assert graph_0.graph == {1135: [1135]}
>       var_1 = graph_0.topological_sort()

ALL-SMART/test_graph1_MIO.py:70: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graph1:120: in topological_sort
    ???
graph1:114: in dfs
    ???
graph1:114: in dfs
    ???
E   RecursionError: maximum recursion depth exceeded
!!! Recursion detected (same locals & position)
   - [# 101] SDL graph1: 
--------------------------------------------------------------------------------
  110:         def dfs(vertex):
  111:             visited.add(vertex)
  112:             for j in self.graph[vertex]:
  113:                 if j not in visited:
- 114:                     dfs(j)
+ 114:                     pass
  115:             
  116:             stack.appendleft(vertex)
  117:         
  118:         for (key, _) in self.graph.items():
--------------------------------------------------------------------------------
[0.14176 s] killed by ALL-SMART/test_graph1_MOSA.py::test_case_22

def test_case_22():
        bool_0 = True
        int_0 = 23
        graph_0 = module_0.Graph(int_0)
        bool_1 = False
        var_0 = graph_0.add_edge(bool_0, bool_1)
        assert graph_0.graph == {True: [False], False: []}
        var_1 = graph_0.topological_sort()
        graph_1 = module_0.Graph(var_1)
>       assert graph_1.verticies == [True, False]
E       AssertionError

ALL-SMART/test_graph1_MOSA.py:190: AssertionError
   - [# 102] SDL graph1: 
--------------------------------------------------------------------------------
  112:             for j in self.graph[vertex]:
  113:                 if j not in visited:
  114:                     dfs(j)
  115:             
- 116:             stack.appendleft(vertex)
+ 116:             pass
  117:         
  118:         for (key, _) in self.graph.items():
  119:             if key not in visited:
  120:                 dfs(key)
--------------------------------------------------------------------------------
[0.14032 s] killed by ALL-SMART/test_graph1_MOSA.py::test_case_22

def test_case_22():
        bool_0 = True
        int_0 = 23
        graph_0 = module_0.Graph(int_0)
        bool_1 = False
        var_0 = graph_0.add_edge(bool_0, bool_1)
        assert graph_0.graph == {True: [False], False: []}
        var_1 = graph_0.topological_sort()
        graph_1 = module_0.Graph(var_1)
>       assert graph_1.verticies == [True, False]
E       AssertionError

ALL-SMART/test_graph1_MOSA.py:190: AssertionError
   - [# 103] SDL graph1: 
--------------------------------------------------------------------------------
  116:             stack.appendleft(vertex)
  117:         
  118:         for (key, _) in self.graph.items():
  119:             if key not in visited:
- 120:                 dfs(key)
+ 120:                 pass
  121:         
  122:         return list(stack)
  123: 
  124: class WeightedGraphNode:
--------------------------------------------------------------------------------
[0.14431 s] killed by ALL-SMART/test_graph1_MOSA.py::test_case_22

def test_case_22():
        bool_0 = True
        int_0 = 23
        graph_0 = module_0.Graph(int_0)
        bool_1 = False
        var_0 = graph_0.add_edge(bool_0, bool_1)
        assert graph_0.graph == {True: [False], False: []}
        var_1 = graph_0.topological_sort()
        graph_1 = module_0.Graph(var_1)
>       assert graph_1.verticies == [True, False]
E       AssertionError

ALL-SMART/test_graph1_MOSA.py:190: AssertionError
   - [# 104] SDL graph1: 
--------------------------------------------------------------------------------
  118:         for (key, _) in self.graph.items():
  119:             if key not in visited:
  120:                 dfs(key)
  121:         
- 122:         return list(stack)
+ 122:         pass
  123: 
  124: class WeightedGraphNode:
  125:     
  126:     def __init__(self, val):
--------------------------------------------------------------------------------
[0.14391 s] killed by ALL-SMART/test_graph1_MOSA.py::test_case_22

def test_case_22():
        bool_0 = True
        int_0 = 23
        graph_0 = module_0.Graph(int_0)
        bool_1 = False
        var_0 = graph_0.add_edge(bool_0, bool_1)
        assert graph_0.graph == {True: [False], False: []}
        var_1 = graph_0.topological_sort()
        graph_1 = module_0.Graph(var_1)
>       assert graph_1.verticies == [True, False]
E       AssertionError

ALL-SMART/test_graph1_MOSA.py:190: AssertionError
   - [# 105] SDL graph1: 
--------------------------------------------------------------------------------
  123: 
  124: class WeightedGraphNode:
  125:     
  126:     def __init__(self, val):
- 127:         self.val = val
+ 127:         pass
  128:         self.adjacent = {}
  129:     
  130:     def __str__(self):
  131:         return (str(self.val) + ' adjacent: ') + str([x for x in self.adjacent])
--------------------------------------------------------------------------------
[0.09699 s] killed by ALL-SMART/test_graph1_MIO.py::test_case_12

def test_case_12():
        weighted_graph_0 = module_0.WeightedGraph()
        none_type_0 = None
        var_0 = weighted_graph_0.add_edge(none_type_0, none_type_0)
>       var_1 = weighted_graph_0.__str__()

ALL-SMART/test_graph1_MIO.py:88: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graph1:145: in __str__
    ???
graph1:145: in <listcomp>
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <graph1.WeightedGraphNode object at 0x78ae562fe710>

>   ???
E   AttributeError: 'WeightedGraphNode' object has no attribute 'val'

graph1:131: AttributeError
   - [# 106] SDL graph1: 
--------------------------------------------------------------------------------
  124: class WeightedGraphNode:
  125:     
  126:     def __init__(self, val):
  127:         self.val = val
- 128:         self.adjacent = {}
+ 128:         pass
  129:     
  130:     def __str__(self):
  131:         return (str(self.val) + ' adjacent: ') + str([x for x in self.adjacent])
  132:     
--------------------------------------------------------------------------------
[0.11883 s] killed by ALL-SMART/test_graph1_MIO.py::test_case_12

def test_case_12():
        weighted_graph_0 = module_0.WeightedGraph()
        none_type_0 = None
>       var_0 = weighted_graph_0.add_edge(none_type_0, none_type_0)

ALL-SMART/test_graph1_MIO.py:87: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graph1:156: in add_edge
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <graph1.WeightedGraphNode object at 0x78ae562ffaf0>, node = None
weight = 0

>   ???
E   AttributeError: 'WeightedGraphNode' object has no attribute 'adjacent'

graph1:134: AttributeError
   - [# 107] SDL graph1: 
--------------------------------------------------------------------------------
  127:         self.val = val
  128:         self.adjacent = {}
  129:     
  130:     def __str__(self):
- 131:         return (str(self.val) + ' adjacent: ') + str([x for x in self.adjacent])
+ 131:         pass
  132:     
  133:     def add_adjacent(self, node, weight=0):
  134:         self.adjacent[node] = weight
  135:     
--------------------------------------------------------------------------------
[0.09661 s] incompetent

TypeError: graph1:145: TypeError: sequence item 0: expected str instance, NoneType found

   - [# 108] SDL graph1: 
--------------------------------------------------------------------------------
  130:     def __str__(self):
  131:         return (str(self.val) + ' adjacent: ') + str([x for x in self.adjacent])
  132:     
  133:     def add_adjacent(self, node, weight=0):
- 134:         self.adjacent[node] = weight
+ 134:         pass
  135:     
  136:     def remove_adjacent(self, node):
  137:         del self.adjacent[node]
  138: 
--------------------------------------------------------------------------------
[0.09751 s] killed by ALL-SMART/test_graph1_MIO.py::test_case_12

def test_case_12():
        weighted_graph_0 = module_0.WeightedGraph()
        none_type_0 = None
        var_0 = weighted_graph_0.add_edge(none_type_0, none_type_0)
        var_1 = weighted_graph_0.__str__()
>       assert var_1 == 'None adjacent: [None]'
E       AssertionError

ALL-SMART/test_graph1_MIO.py:89: AssertionError
   - [# 109] SDL graph1: 
--------------------------------------------------------------------------------
  138: 
  139: class WeightedGraph:
  140:     
  141:     def __init__(self):
- 142:         self.vertices = {}
+ 142:         pass
  143:     
  144:     def __str__(self):
  145:         return ', '.join([node.__str__() for node in self.vertices.values()])
  146:     
--------------------------------------------------------------------------------
[0.09746 s] killed by ALL-SMART/test_graph1_MIO.py::test_case_12

def test_case_12():
        weighted_graph_0 = module_0.WeightedGraph()
        none_type_0 = None
>       var_0 = weighted_graph_0.add_edge(none_type_0, none_type_0)

ALL-SMART/test_graph1_MIO.py:87: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <graph1.WeightedGraph object at 0x78ae5670fac0>, src = None, dst = None
weight = 0

>   ???
E   AttributeError: 'WeightedGraph' object has no attribute 'vertices'

graph1:152: AttributeError
   - [# 110] SDL graph1: 
--------------------------------------------------------------------------------
  141:     def __init__(self):
  142:         self.vertices = {}
  143:     
  144:     def __str__(self):
- 145:         return ', '.join([node.__str__() for node in self.vertices.values()])
+ 145:         pass
  146:     
  147:     def add_vertex(self, val):
  148:         vertex = WeightedGraphNode(val)
  149:         self.vertices[val] = vertex
--------------------------------------------------------------------------------
[0.09899 s] killed by ALL-SMART/test_graph1_MIO.py::test_case_12

def test_case_12():
        weighted_graph_0 = module_0.WeightedGraph()
        none_type_0 = None
        var_0 = weighted_graph_0.add_edge(none_type_0, none_type_0)
        var_1 = weighted_graph_0.__str__()
>       assert var_1 == 'None adjacent: [None]'
E       AssertionError

ALL-SMART/test_graph1_MIO.py:89: AssertionError
   - [# 111] SDL graph1: 
--------------------------------------------------------------------------------
  144:     def __str__(self):
  145:         return ', '.join([node.__str__() for node in self.vertices.values()])
  146:     
  147:     def add_vertex(self, val):
- 148:         vertex = WeightedGraphNode(val)
+ 148:         pass
  149:         self.vertices[val] = vertex
  150:     
  151:     def add_edge(self, src, dst, weight=0):
  152:         if src not in self.vertices:
--------------------------------------------------------------------------------
[0.09592 s] killed by ALL-SMART/test_graph1_MIO.py::test_case_12

def test_case_12():
        weighted_graph_0 = module_0.WeightedGraph()
        none_type_0 = None
>       var_0 = weighted_graph_0.add_edge(none_type_0, none_type_0)

ALL-SMART/test_graph1_MIO.py:87: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graph1:153: in add_edge
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <graph1.WeightedGraph object at 0x78ae56342d40>, val = None

>   ???
E   NameError: name 'vertex' is not defined

graph1:149: NameError
   - [# 112] SDL graph1: 
--------------------------------------------------------------------------------
  145:         return ', '.join([node.__str__() for node in self.vertices.values()])
  146:     
  147:     def add_vertex(self, val):
  148:         vertex = WeightedGraphNode(val)
- 149:         self.vertices[val] = vertex
+ 149:         pass
  150:     
  151:     def add_edge(self, src, dst, weight=0):
  152:         if src not in self.vertices:
  153:             self.add_vertex(src)
--------------------------------------------------------------------------------
[0.09957 s] killed by ALL-SMART/test_graph1_MIO.py::test_case_12

def test_case_12():
        weighted_graph_0 = module_0.WeightedGraph()
        none_type_0 = None
>       var_0 = weighted_graph_0.add_edge(none_type_0, none_type_0)

ALL-SMART/test_graph1_MIO.py:87: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <graph1.WeightedGraph object at 0x78ae5649d600>, src = None, dst = None
weight = 0

>   ???
E   KeyError: None

graph1:156: KeyError
   - [# 113] SDL graph1: 
--------------------------------------------------------------------------------
  149:         self.vertices[val] = vertex
  150:     
  151:     def add_edge(self, src, dst, weight=0):
  152:         if src not in self.vertices:
- 153:             self.add_vertex(src)
+ 153:             pass
  154:         if dst not in self.vertices:
  155:             self.add_vertex(dst)
  156:         self.vertices[src].add_adjacent(dst, weight)
  157:     
--------------------------------------------------------------------------------
[0.09911 s] killed by ALL-SMART/test_graph1_MIO.py::test_case_16

def test_case_16():
        none_type_0 = None
        weighted_graph_0 = module_0.WeightedGraph()
>       var_0 = weighted_graph_0.add_edge(none_type_0, weighted_graph_0)

ALL-SMART/test_graph1_MIO.py:108: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <graph1.WeightedGraph object at 0x78ae56542770>, src = None
dst = <graph1.WeightedGraph object at 0x78ae56542770>, weight = 0

>   ???
E   KeyError: None

graph1:156: KeyError
   - [# 114] SDL graph1: 
--------------------------------------------------------------------------------
  151:     def add_edge(self, src, dst, weight=0):
  152:         if src not in self.vertices:
  153:             self.add_vertex(src)
  154:         if dst not in self.vertices:
- 155:             self.add_vertex(dst)
+ 155:             pass
  156:         self.vertices[src].add_adjacent(dst, weight)
  157:     
  158:     def remove_edge(self, src, dst):
  159:         if src not in self.vertices:
--------------------------------------------------------------------------------
[0.11920 s] killed by ALL-SMART/test_graph1_MIO.py::test_case_16

def test_case_16():
        none_type_0 = None
        weighted_graph_0 = module_0.WeightedGraph()
        var_0 = weighted_graph_0.add_edge(none_type_0, weighted_graph_0)
>       assert len(weighted_graph_0.vertices) == 2
E       AssertionError

ALL-SMART/test_graph1_MIO.py:109: AssertionError
   - [# 115] SDL graph1: 
--------------------------------------------------------------------------------
  152:         if src not in self.vertices:
  153:             self.add_vertex(src)
  154:         if dst not in self.vertices:
  155:             self.add_vertex(dst)
- 156:         self.vertices[src].add_adjacent(dst, weight)
+ 156:         pass
  157:     
  158:     def remove_edge(self, src, dst):
  159:         if src not in self.vertices:
  160:             return
--------------------------------------------------------------------------------
[0.09882 s] killed by ALL-SMART/test_graph1_MIO.py::test_case_12

def test_case_12():
        weighted_graph_0 = module_0.WeightedGraph()
        none_type_0 = None
        var_0 = weighted_graph_0.add_edge(none_type_0, none_type_0)
        var_1 = weighted_graph_0.__str__()
>       assert var_1 == 'None adjacent: [None]'
E       AssertionError

ALL-SMART/test_graph1_MIO.py:89: AssertionError
   - [# 116] SDL graph1: 
--------------------------------------------------------------------------------
  156:         self.vertices[src].add_adjacent(dst, weight)
  157:     
  158:     def remove_edge(self, src, dst):
  159:         if src not in self.vertices:
- 160:             return
+ 160:             pass
  161:         if dst not in self.vertices:
  162:             return
  163:         if dst in self.vertices[src].adjacent:
  164:             self.vertices[src].remove_adjacent(dst)
--------------------------------------------------------------------------------
[0.11891 s] survived
   - [# 117] SDL graph1: 
--------------------------------------------------------------------------------
  158:     def remove_edge(self, src, dst):
  159:         if src not in self.vertices:
  160:             return
  161:         if dst not in self.vertices:
- 162:             return
+ 162:             pass
  163:         if dst in self.vertices[src].adjacent:
  164:             self.vertices[src].remove_adjacent(dst)
--------------------------------------------------------------------------------
[0.14324 s] survived
   - [# 118] SDL graph1: 
--------------------------------------------------------------------------------
  160:             return
  161:         if dst not in self.vertices:
  162:             return
  163:         if dst in self.vertices[src].adjacent:
- 164:             self.vertices[src].remove_adjacent(dst)
+ 164:             pass
--------------------------------------------------------------------------------
[0.12136 s] survived
   - [# 119] SVD graph1: 
--------------------------------------------------------------------------------
    2: 
    3: class GraphNode:
    4:     
    5:     def __init__(self, val):
-   6:         self.val = val
+   6:         val = val
    7:         self.adjacent_list = set()
    8:     
    9:     def add_adjacent(self, node):
   10:         self.adjacent_list.add(node)
--------------------------------------------------------------------------------
[0.00000 s] incompetent

ValueError: expression must have Store context but has Load instead

   - [# 120] SVD graph1: 
--------------------------------------------------------------------------------
    3: class GraphNode:
    4:     
    5:     def __init__(self, val):
    6:         self.val = val
-   7:         self.adjacent_list = set()
+   7:         adjacent_list = set()
    8:     
    9:     def add_adjacent(self, node):
   10:         self.adjacent_list.add(node)
   11:     
--------------------------------------------------------------------------------
[0.00000 s] incompetent

ValueError: expression must have Store context but has Load instead

   - [# 121] SVD graph1: 
--------------------------------------------------------------------------------
    6:         self.val = val
    7:         self.adjacent_list = set()
    8:     
    9:     def add_adjacent(self, node):
-  10:         self.adjacent_list.add(node)
+  10:         adjacent_list.add(node)
   11:     
   12:     def remove_adjacent(self, node):
   13:         self.adjacent_list.remove(node)
   14: 
--------------------------------------------------------------------------------
[0.10648 s] killed by ALL-SMART/test_graph1_MIO.py::test_case_25

def test_case_25():
        int_0 = 5852
        graph_node_0 = module_0.GraphNode(int_0)
>       var_0 = graph_node_0.add_adjacent(graph_node_0)

ALL-SMART/test_graph1_MIO.py:151: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <graph1.GraphNode object at 0x78ae5643d3c0>
node = <graph1.GraphNode object at 0x78ae5643d3c0>

>   ???
E   NameError: name 'adjacent_list' is not defined

graph1:10: NameError
   - [# 122] SVD graph1: 
--------------------------------------------------------------------------------
    9:     def add_adjacent(self, node):
   10:         self.adjacent_list.add(node)
   11:     
   12:     def remove_adjacent(self, node):
-  13:         self.adjacent_list.remove(node)
+  13:         adjacent_list.remove(node)
   14: 
   15: class Graph:
   16:     '''
   17:     A directed graph represented with an adjacency list.
--------------------------------------------------------------------------------
[0.13878 s] survived
   - [# 123] SVD graph1: 
--------------------------------------------------------------------------------
   17:     A directed graph represented with an adjacency list.
   18:     '''
   19:     
   20:     def __init__(self, verticies):
-  21:         self.graph = {}
+  21:         graph = {}
   22:         self.verticies = verticies
   23:     
   24:     def add_edge(self, source, destination):
   25:         '''
--------------------------------------------------------------------------------
[0.00000 s] incompetent

ValueError: expression must have Store context but has Load instead

   - [# 124] SVD graph1: 
--------------------------------------------------------------------------------
   18:     '''
   19:     
   20:     def __init__(self, verticies):
   21:         self.graph = {}
-  22:         self.verticies = verticies
+  22:         verticies = verticies
   23:     
   24:     def add_edge(self, source, destination):
   25:         '''
   26:         Add an edge to the graph.
--------------------------------------------------------------------------------
[0.00000 s] incompetent

ValueError: expression must have Store context but has Load instead

   - [# 125] SVD graph1: 
--------------------------------------------------------------------------------
   32:             source: the source vertex
   33:             destination: the destination vertex
   34: 
   35:         '''
-  36:         if len(self.graph) > self.verticies:
+  36:         if len(graph) > self.verticies:
   37:             raise IndexError('Too many verticies in graph.')
   38:         
   39:         if source in self.graph:
   40:             self.graph[source].append(destination)
--------------------------------------------------------------------------------
[0.09051 s] killed by ALL-SMART/test_graph1_MIO.py::test_case_0

def test_case_0():
        int_0 = 3280
        graph_0 = module_0.Graph(int_0)
>       var_0 = graph_0.add_edge(graph_0, int_0)

ALL-SMART/test_graph1_MIO.py:8: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <graph1.Graph object at 0x78ae56808a60>
source = <graph1.Graph object at 0x78ae56808a60>, destination = 3280

>   ???
E   NameError: name 'graph' is not defined

graph1:36: NameError
   - [# 126] SVD graph1: 
--------------------------------------------------------------------------------
   32:             source: the source vertex
   33:             destination: the destination vertex
   34: 
   35:         '''
-  36:         if len(self.graph) > self.verticies:
+  36:         if len(self.graph) > verticies:
   37:             raise IndexError('Too many verticies in graph.')
   38:         
   39:         if source in self.graph:
   40:             self.graph[source].append(destination)
--------------------------------------------------------------------------------
[0.09585 s] killed by ALL-SMART/test_graph1_MIO.py::test_case_0

def test_case_0():
        int_0 = 3280
        graph_0 = module_0.Graph(int_0)
>       var_0 = graph_0.add_edge(graph_0, int_0)

ALL-SMART/test_graph1_MIO.py:8: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <graph1.Graph object at 0x78ae56274670>
source = <graph1.Graph object at 0x78ae56274670>, destination = 3280

>   ???
E   NameError: name 'verticies' is not defined

graph1:36: NameError
   - [# 127] SVD graph1: 
--------------------------------------------------------------------------------
   35:         '''
   36:         if len(self.graph) > self.verticies:
   37:             raise IndexError('Too many verticies in graph.')
   38:         
-  39:         if source in self.graph:
+  39:         if source in graph:
   40:             self.graph[source].append(destination)
   41:         else:
   42:             self.graph[source] = [destination]
   43:         
--------------------------------------------------------------------------------
[0.09009 s] killed by ALL-SMART/test_graph1_MIO.py::test_case_0

def test_case_0():
        int_0 = 3280
        graph_0 = module_0.Graph(int_0)
>       var_0 = graph_0.add_edge(graph_0, int_0)

ALL-SMART/test_graph1_MIO.py:8: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <graph1.Graph object at 0x78ae563b5e40>
source = <graph1.Graph object at 0x78ae563b5e40>, destination = 3280

>   ???
E   NameError: name 'graph' is not defined

graph1:39: NameError
   - [# 128] SVD graph1: 
--------------------------------------------------------------------------------
   36:         if len(self.graph) > self.verticies:
   37:             raise IndexError('Too many verticies in graph.')
   38:         
   39:         if source in self.graph:
-  40:             self.graph[source].append(destination)
+  40:             graph[source].append(destination)
   41:         else:
   42:             self.graph[source] = [destination]
   43:         
   44:         if destination not in self.graph:
--------------------------------------------------------------------------------
[0.09275 s] killed by ALL-SMART/test_graph1_MIO.py::test_case_0

def test_case_0():
        int_0 = 3280
        graph_0 = module_0.Graph(int_0)
        var_0 = graph_0.add_edge(graph_0, int_0)
        assert len(graph_0.graph) == 2
>       var_1 = graph_0.add_edge(graph_0, graph_0)

ALL-SMART/test_graph1_MIO.py:10: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <graph1.Graph object at 0x78ae56340fd0>
source = <graph1.Graph object at 0x78ae56340fd0>
destination = <graph1.Graph object at 0x78ae56340fd0>

>   ???
E   NameError: name 'graph' is not defined

graph1:40: NameError
   - [# 129] SVD graph1: 
--------------------------------------------------------------------------------
   38:         
   39:         if source in self.graph:
   40:             self.graph[source].append(destination)
   41:         else:
-  42:             self.graph[source] = [destination]
+  42:             graph[source] = [destination]
   43:         
   44:         if destination not in self.graph:
   45:             self.graph[destination] = []
   46:     
--------------------------------------------------------------------------------
[0.08514 s] killed by ALL-SMART/test_graph1_MIO.py::test_case_0

def test_case_0():
        int_0 = 3280
        graph_0 = module_0.Graph(int_0)
>       var_0 = graph_0.add_edge(graph_0, int_0)

ALL-SMART/test_graph1_MIO.py:8: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <graph1.Graph object at 0x78ae563417e0>
source = <graph1.Graph object at 0x78ae563417e0>, destination = 3280

>   ???
E   NameError: name 'graph' is not defined

graph1:42: NameError
   - [# 130] SVD graph1: 
--------------------------------------------------------------------------------
   40:             self.graph[source].append(destination)
   41:         else:
   42:             self.graph[source] = [destination]
   43:         
-  44:         if destination not in self.graph:
+  44:         if destination not in graph:
   45:             self.graph[destination] = []
   46:     
   47:     def has_cycle(self):
   48:         '''
--------------------------------------------------------------------------------
[0.11005 s] killed by ALL-SMART/test_graph1_MIO.py::test_case_0

def test_case_0():
        int_0 = 3280
        graph_0 = module_0.Graph(int_0)
>       var_0 = graph_0.add_edge(graph_0, int_0)

ALL-SMART/test_graph1_MIO.py:8: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <graph1.Graph object at 0x78ae5645acb0>
source = <graph1.Graph object at 0x78ae5645acb0>, destination = 3280

>   ???
E   NameError: name 'graph' is not defined

graph1:44: NameError
   - [# 131] SVD graph1: 
--------------------------------------------------------------------------------
   41:         else:
   42:             self.graph[source] = [destination]
   43:         
   44:         if destination not in self.graph:
-  45:             self.graph[destination] = []
+  45:             graph[destination] = []
   46:     
   47:     def has_cycle(self):
   48:         '''
   49:         Detect if a graph has a cycle.
--------------------------------------------------------------------------------
[0.08908 s] killed by ALL-SMART/test_graph1_MIO.py::test_case_0

def test_case_0():
        int_0 = 3280
        graph_0 = module_0.Graph(int_0)
>       var_0 = graph_0.add_edge(graph_0, int_0)

ALL-SMART/test_graph1_MIO.py:8: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <graph1.Graph object at 0x78ae5605efe0>
source = <graph1.Graph object at 0x78ae5605efe0>, destination = 3280

>   ???
E   NameError: name 'graph' is not defined

graph1:45: NameError
   - [# 132] SVD graph1: 
--------------------------------------------------------------------------------
   53:             False if the graph is acyclic.
   54: 
   55:         '''
   56:         
-  57:         visited = [0] * self.verticies
+  57:         visited = [0] * verticies
   58:         
   59:         def valid(node):
   60:             
   61:             if visited[node] == -1:
--------------------------------------------------------------------------------
[0.09042 s] killed by ALL-SMART/test_graph1_MIO.py::test_case_5

def test_case_5():
        int_0 = -3972
        graph_0 = module_0.Graph(int_0)
>       var_0 = graph_0.has_cycle()

ALL-SMART/test_graph1_MIO.py:37: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <graph1.Graph object at 0x78ae5645ad10>

>   ???
E   NameError: name 'verticies' is not defined

graph1:57: NameError
   - [# 133] SVD graph1: 
--------------------------------------------------------------------------------
   62:                 return False
   63:             elif visited[node] == 1:
   64:                 return True
   65:             visited[node] = -1
-  66:             for neighbor in self.graph[node]:
+  66:             for neighbor in graph[node]:
   67:                 if not (valid(neighbor)):
   68:                     return False
   69:             return True
   70:         
--------------------------------------------------------------------------------
[0.09287 s] killed by ALL-SMART/test_graph1_MIO.py::test_case_6

def test_case_6():
        bool_0 = True
        graph_0 = module_0.Graph(bool_0)
        bool_1 = False
        var_0 = graph_0.add_edge(graph_0, bool_1)
        assert len(graph_0.graph) == 2
>       var_1 = graph_0.has_cycle()

ALL-SMART/test_graph1_MIO.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graph1:77: in has_cycle
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

node = 0

>   ???
E   NameError: name 'graph' is not defined

graph1:66: NameError
   - [# 134] SVD graph1: 
--------------------------------------------------------------------------------
   67:                 if not (valid(neighbor)):
   68:                     return False
   69:             return True
   70:         
-  71:         for node in range(self.verticies):
+  71:         for node in range(verticies):
   72:             
   73:             
   74:             
   75:             if not (visited[node]):
--------------------------------------------------------------------------------
[0.09252 s] killed by ALL-SMART/test_graph1_MIO.py::test_case_5

def test_case_5():
        int_0 = -3972
        graph_0 = module_0.Graph(int_0)
>       var_0 = graph_0.has_cycle()

ALL-SMART/test_graph1_MIO.py:37: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <graph1.Graph object at 0x78ae5670fb80>

>   ???
E   NameError: name 'verticies' is not defined

graph1:71: NameError
   - [# 135] SVD graph1: 
--------------------------------------------------------------------------------
  108:         stack = deque()
  109:         
  110:         def dfs(vertex):
  111:             visited.add(vertex)
- 112:             for j in self.graph[vertex]:
+ 112:             for j in graph[vertex]:
  113:                 if j not in visited:
  114:                     dfs(j)
  115:             
  116:             stack.appendleft(vertex)
--------------------------------------------------------------------------------
[0.09642 s] killed by ALL-SMART/test_graph1_MIO.py::test_case_9

def test_case_9():
        int_0 = 1135
        graph_0 = module_0.Graph(int_0)
        var_0 = graph_0.add_edge(int_0, int_0)
        assert graph_0.graph == {1135: [1135]}
>       var_1 = graph_0.topological_sort()

ALL-SMART/test_graph1_MIO.py:70: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graph1:120: in topological_sort
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

vertex = 1135

>   ???
E   NameError: name 'graph' is not defined

graph1:112: NameError
   - [# 136] SVD graph1: 
--------------------------------------------------------------------------------
  114:                     dfs(j)
  115:             
  116:             stack.appendleft(vertex)
  117:         
- 118:         for (key, _) in self.graph.items():
+ 118:         for (key, _) in graph.items():
  119:             if key not in visited:
  120:                 dfs(key)
  121:         
  122:         return list(stack)
--------------------------------------------------------------------------------
[0.09706 s] killed by ALL-SMART/test_graph1_MIO.py::test_case_9

def test_case_9():
        int_0 = 1135
        graph_0 = module_0.Graph(int_0)
        var_0 = graph_0.add_edge(int_0, int_0)
        assert graph_0.graph == {1135: [1135]}
>       var_1 = graph_0.topological_sort()

ALL-SMART/test_graph1_MIO.py:70: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <graph1.Graph object at 0x78ae562fe680>

>   ???
E   NameError: name 'graph' is not defined

graph1:118: NameError
   - [# 137] SVD graph1: 
--------------------------------------------------------------------------------
  123: 
  124: class WeightedGraphNode:
  125:     
  126:     def __init__(self, val):
- 127:         self.val = val
+ 127:         val = val
  128:         self.adjacent = {}
  129:     
  130:     def __str__(self):
  131:         return (str(self.val) + ' adjacent: ') + str([x for x in self.adjacent])
--------------------------------------------------------------------------------
[0.00000 s] incompetent

ValueError: expression must have Store context but has Load instead

   - [# 138] SVD graph1: 
--------------------------------------------------------------------------------
  124: class WeightedGraphNode:
  125:     
  126:     def __init__(self, val):
  127:         self.val = val
- 128:         self.adjacent = {}
+ 128:         adjacent = {}
  129:     
  130:     def __str__(self):
  131:         return (str(self.val) + ' adjacent: ') + str([x for x in self.adjacent])
  132:     
--------------------------------------------------------------------------------
[0.00000 s] incompetent

ValueError: expression must have Store context but has Load instead

   - [# 139] SVD graph1: 
--------------------------------------------------------------------------------
  127:         self.val = val
  128:         self.adjacent = {}
  129:     
  130:     def __str__(self):
- 131:         return (str(self.val) + ' adjacent: ') + str([x for x in self.adjacent])
+ 131:         return (str(val) + ' adjacent: ') + str([x for x in self.adjacent])
  132:     
  133:     def add_adjacent(self, node, weight=0):
  134:         self.adjacent[node] = weight
  135:     
--------------------------------------------------------------------------------
[0.10158 s] killed by ALL-SMART/test_graph1_MIO.py::test_case_12

def test_case_12():
        weighted_graph_0 = module_0.WeightedGraph()
        none_type_0 = None
        var_0 = weighted_graph_0.add_edge(none_type_0, none_type_0)
>       var_1 = weighted_graph_0.__str__()

ALL-SMART/test_graph1_MIO.py:88: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graph1:145: in __str__
    ???
graph1:145: in <listcomp>
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <graph1.WeightedGraphNode object at 0x78ae563e2530>

>   ???
E   NameError: name 'val' is not defined

graph1:131: NameError
   - [# 140] SVD graph1: 
--------------------------------------------------------------------------------
  127:         self.val = val
  128:         self.adjacent = {}
  129:     
  130:     def __str__(self):
- 131:         return (str(self.val) + ' adjacent: ') + str([x for x in self.adjacent])
+ 131:         return (str(self.val) + ' adjacent: ') + str([x for x in adjacent])
  132:     
  133:     def add_adjacent(self, node, weight=0):
  134:         self.adjacent[node] = weight
  135:     
--------------------------------------------------------------------------------
[0.09616 s] killed by ALL-SMART/test_graph1_MIO.py::test_case_12

def test_case_12():
        weighted_graph_0 = module_0.WeightedGraph()
        none_type_0 = None
        var_0 = weighted_graph_0.add_edge(none_type_0, none_type_0)
>       var_1 = weighted_graph_0.__str__()

ALL-SMART/test_graph1_MIO.py:88: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graph1:145: in __str__
    ???
graph1:145: in <listcomp>
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <graph1.WeightedGraphNode object at 0x78ae563ad9c0>

>   ???
E   NameError: name 'adjacent' is not defined

graph1:131: NameError
   - [# 141] SVD graph1: 
--------------------------------------------------------------------------------
  130:     def __str__(self):
  131:         return (str(self.val) + ' adjacent: ') + str([x for x in self.adjacent])
  132:     
  133:     def add_adjacent(self, node, weight=0):
- 134:         self.adjacent[node] = weight
+ 134:         adjacent[node] = weight
  135:     
  136:     def remove_adjacent(self, node):
  137:         del self.adjacent[node]
  138: 
--------------------------------------------------------------------------------
[0.10134 s] killed by ALL-SMART/test_graph1_MIO.py::test_case_12

def test_case_12():
        weighted_graph_0 = module_0.WeightedGraph()
        none_type_0 = None
>       var_0 = weighted_graph_0.add_edge(none_type_0, none_type_0)

ALL-SMART/test_graph1_MIO.py:87: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graph1:156: in add_edge
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <graph1.WeightedGraphNode object at 0x78ae56276ad0>, node = None
weight = 0

>   ???
E   NameError: name 'adjacent' is not defined

graph1:134: NameError
   - [# 142] SVD graph1: 
--------------------------------------------------------------------------------
  133:     def add_adjacent(self, node, weight=0):
  134:         self.adjacent[node] = weight
  135:     
  136:     def remove_adjacent(self, node):
- 137:         del self.adjacent[node]
+ 137:         del adjacent[node]
  138: 
  139: class WeightedGraph:
  140:     
  141:     def __init__(self):
--------------------------------------------------------------------------------
[0.10698 s] killed by ALL-SMART/test_graph1_MIO.py::test_case_21

def test_case_21():
        weighted_graph_0 = module_0.WeightedGraph()
        var_0 = weighted_graph_0.add_edge(weighted_graph_0, weighted_graph_0)
>       var_1 = weighted_graph_0.remove_edge(weighted_graph_0, weighted_graph_0)

ALL-SMART/test_graph1_MIO.py:135: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graph1:164: in remove_edge
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <graph1.WeightedGraphNode object at 0x78ae564fcc40>
node = <graph1.WeightedGraph object at 0x78ae564fe230>

>   ???
E   NameError: name 'adjacent' is not defined

graph1:137: NameError
   - [# 143] SVD graph1: 
--------------------------------------------------------------------------------
  138: 
  139: class WeightedGraph:
  140:     
  141:     def __init__(self):
- 142:         self.vertices = {}
+ 142:         vertices = {}
  143:     
  144:     def __str__(self):
  145:         return ', '.join([node.__str__() for node in self.vertices.values()])
  146:     
--------------------------------------------------------------------------------
[0.00000 s] incompetent

ValueError: expression must have Store context but has Load instead

   - [# 144] SVD graph1: 
--------------------------------------------------------------------------------
  141:     def __init__(self):
  142:         self.vertices = {}
  143:     
  144:     def __str__(self):
- 145:         return ', '.join([node.__str__() for node in self.vertices.values()])
+ 145:         return ', '.join([node.__str__() for node in vertices.values()])
  146:     
  147:     def add_vertex(self, val):
  148:         vertex = WeightedGraphNode(val)
  149:         self.vertices[val] = vertex
--------------------------------------------------------------------------------
[0.09639 s] killed by ALL-SMART/test_graph1_MIO.py::test_case_12

def test_case_12():
        weighted_graph_0 = module_0.WeightedGraph()
        none_type_0 = None
        var_0 = weighted_graph_0.add_edge(none_type_0, none_type_0)
>       var_1 = weighted_graph_0.__str__()

ALL-SMART/test_graph1_MIO.py:88: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <graph1.WeightedGraph object at 0x78ae5672e050>

>   ???
E   NameError: name 'vertices' is not defined

graph1:145: NameError
   - [# 145] SVD graph1: 
--------------------------------------------------------------------------------
  145:         return ', '.join([node.__str__() for node in self.vertices.values()])
  146:     
  147:     def add_vertex(self, val):
  148:         vertex = WeightedGraphNode(val)
- 149:         self.vertices[val] = vertex
+ 149:         vertices[val] = vertex
  150:     
  151:     def add_edge(self, src, dst, weight=0):
  152:         if src not in self.vertices:
  153:             self.add_vertex(src)
--------------------------------------------------------------------------------
[0.09679 s] killed by ALL-SMART/test_graph1_MIO.py::test_case_12

def test_case_12():
        weighted_graph_0 = module_0.WeightedGraph()
        none_type_0 = None
>       var_0 = weighted_graph_0.add_edge(none_type_0, none_type_0)

ALL-SMART/test_graph1_MIO.py:87: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
graph1:153: in add_edge
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <graph1.WeightedGraph object at 0x78ae5642b4c0>, val = None

>   ???
E   NameError: name 'vertices' is not defined

graph1:149: NameError
   - [# 146] SVD graph1: 
--------------------------------------------------------------------------------
  148:         vertex = WeightedGraphNode(val)
  149:         self.vertices[val] = vertex
  150:     
  151:     def add_edge(self, src, dst, weight=0):
- 152:         if src not in self.vertices:
+ 152:         if src not in vertices:
  153:             self.add_vertex(src)
  154:         if dst not in self.vertices:
  155:             self.add_vertex(dst)
  156:         self.vertices[src].add_adjacent(dst, weight)
--------------------------------------------------------------------------------
[0.12301 s] killed by ALL-SMART/test_graph1_MIO.py::test_case_12

def test_case_12():
        weighted_graph_0 = module_0.WeightedGraph()
        none_type_0 = None
>       var_0 = weighted_graph_0.add_edge(none_type_0, none_type_0)

ALL-SMART/test_graph1_MIO.py:87: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <graph1.WeightedGraph object at 0x78ae56416fb0>, src = None, dst = None
weight = 0

>   ???
E   NameError: name 'vertices' is not defined

graph1:152: NameError
   - [# 147] SVD graph1: 
--------------------------------------------------------------------------------
  149:         self.vertices[val] = vertex
  150:     
  151:     def add_edge(self, src, dst, weight=0):
  152:         if src not in self.vertices:
- 153:             self.add_vertex(src)
+ 153:             add_vertex(src)
  154:         if dst not in self.vertices:
  155:             self.add_vertex(dst)
  156:         self.vertices[src].add_adjacent(dst, weight)
  157:     
--------------------------------------------------------------------------------
[0.09713 s] killed by ALL-SMART/test_graph1_MIO.py::test_case_12

def test_case_12():
        weighted_graph_0 = module_0.WeightedGraph()
        none_type_0 = None
>       var_0 = weighted_graph_0.add_edge(none_type_0, none_type_0)

ALL-SMART/test_graph1_MIO.py:87: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <graph1.WeightedGraph object at 0x78ae5605f6d0>, src = None, dst = None
weight = 0

>   ???
E   NameError: name 'add_vertex' is not defined

graph1:153: NameError
   - [# 148] SVD graph1: 
--------------------------------------------------------------------------------
  150:     
  151:     def add_edge(self, src, dst, weight=0):
  152:         if src not in self.vertices:
  153:             self.add_vertex(src)
- 154:         if dst not in self.vertices:
+ 154:         if dst not in vertices:
  155:             self.add_vertex(dst)
  156:         self.vertices[src].add_adjacent(dst, weight)
  157:     
  158:     def remove_edge(self, src, dst):
--------------------------------------------------------------------------------
[0.09609 s] killed by ALL-SMART/test_graph1_MIO.py::test_case_12

def test_case_12():
        weighted_graph_0 = module_0.WeightedGraph()
        none_type_0 = None
>       var_0 = weighted_graph_0.add_edge(none_type_0, none_type_0)

ALL-SMART/test_graph1_MIO.py:87: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <graph1.WeightedGraph object at 0x78ae563ae320>, src = None, dst = None
weight = 0

>   ???
E   NameError: name 'vertices' is not defined

graph1:154: NameError
   - [# 149] SVD graph1: 
--------------------------------------------------------------------------------
  151:     def add_edge(self, src, dst, weight=0):
  152:         if src not in self.vertices:
  153:             self.add_vertex(src)
  154:         if dst not in self.vertices:
- 155:             self.add_vertex(dst)
+ 155:             add_vertex(dst)
  156:         self.vertices[src].add_adjacent(dst, weight)
  157:     
  158:     def remove_edge(self, src, dst):
  159:         if src not in self.vertices:
--------------------------------------------------------------------------------
[0.09698 s] killed by ALL-SMART/test_graph1_MIO.py::test_case_16

def test_case_16():
        none_type_0 = None
        weighted_graph_0 = module_0.WeightedGraph()
>       var_0 = weighted_graph_0.add_edge(none_type_0, weighted_graph_0)

ALL-SMART/test_graph1_MIO.py:108: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <graph1.WeightedGraph object at 0x78ae5651af80>, src = None
dst = <graph1.WeightedGraph object at 0x78ae5651af80>, weight = 0

>   ???
E   NameError: name 'add_vertex' is not defined

graph1:155: NameError
   - [# 150] SVD graph1: 
--------------------------------------------------------------------------------
  152:         if src not in self.vertices:
  153:             self.add_vertex(src)
  154:         if dst not in self.vertices:
  155:             self.add_vertex(dst)
- 156:         self.vertices[src].add_adjacent(dst, weight)
+ 156:         vertices[src].add_adjacent(dst, weight)
  157:     
  158:     def remove_edge(self, src, dst):
  159:         if src not in self.vertices:
  160:             return
--------------------------------------------------------------------------------
[0.09666 s] killed by ALL-SMART/test_graph1_MIO.py::test_case_12

def test_case_12():
        weighted_graph_0 = module_0.WeightedGraph()
        none_type_0 = None
>       var_0 = weighted_graph_0.add_edge(none_type_0, none_type_0)

ALL-SMART/test_graph1_MIO.py:87: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <graph1.WeightedGraph object at 0x78ae564c49a0>, src = None, dst = None
weight = 0

>   ???
E   NameError: name 'vertices' is not defined

graph1:156: NameError
   - [# 151] SVD graph1: 
--------------------------------------------------------------------------------
  155:             self.add_vertex(dst)
  156:         self.vertices[src].add_adjacent(dst, weight)
  157:     
  158:     def remove_edge(self, src, dst):
- 159:         if src not in self.vertices:
+ 159:         if src not in vertices:
  160:             return
  161:         if dst not in self.vertices:
  162:             return
  163:         if dst in self.vertices[src].adjacent:
--------------------------------------------------------------------------------
[0.10009 s] killed by ALL-SMART/test_graph1_MIO.py::test_case_19

def test_case_19():
        weighted_graph_0 = module_0.WeightedGraph()
        var_0 = weighted_graph_0.add_vertex(weighted_graph_0)
>       var_1 = weighted_graph_0.remove_edge(weighted_graph_0, var_0)

ALL-SMART/test_graph1_MIO.py:124: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <graph1.WeightedGraph object at 0x78ae565cd1e0>
src = <graph1.WeightedGraph object at 0x78ae565cd1e0>, dst = None

>   ???
E   NameError: name 'vertices' is not defined

graph1:159: NameError
   - [# 152] SVD graph1: 
--------------------------------------------------------------------------------
  157:     
  158:     def remove_edge(self, src, dst):
  159:         if src not in self.vertices:
  160:             return
- 161:         if dst not in self.vertices:
+ 161:         if dst not in vertices:
  162:             return
  163:         if dst in self.vertices[src].adjacent:
  164:             self.vertices[src].remove_adjacent(dst)
--------------------------------------------------------------------------------
[0.10052 s] killed by ALL-SMART/test_graph1_MIO.py::test_case_19

def test_case_19():
        weighted_graph_0 = module_0.WeightedGraph()
        var_0 = weighted_graph_0.add_vertex(weighted_graph_0)
>       var_1 = weighted_graph_0.remove_edge(weighted_graph_0, var_0)

ALL-SMART/test_graph1_MIO.py:124: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <graph1.WeightedGraph object at 0x78ae5642a9e0>
src = <graph1.WeightedGraph object at 0x78ae5642a9e0>, dst = None

>   ???
E   NameError: name 'vertices' is not defined

graph1:161: NameError
   - [# 153] SVD graph1: 
--------------------------------------------------------------------------------
  159:         if src not in self.vertices:
  160:             return
  161:         if dst not in self.vertices:
  162:             return
- 163:         if dst in self.vertices[src].adjacent:
+ 163:         if dst in vertices[src].adjacent:
  164:             self.vertices[src].remove_adjacent(dst)
--------------------------------------------------------------------------------
[0.10396 s] killed by ALL-SMART/test_graph1_MIO.py::test_case_20

def test_case_20():
        weighted_graph_0 = module_0.WeightedGraph()
        var_0 = weighted_graph_0.add_vertex(weighted_graph_0)
>       var_1 = weighted_graph_0.remove_edge(weighted_graph_0, weighted_graph_0)

ALL-SMART/test_graph1_MIO.py:130: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <graph1.WeightedGraph object at 0x78ae561ca200>
src = <graph1.WeightedGraph object at 0x78ae561ca200>
dst = <graph1.WeightedGraph object at 0x78ae561ca200>

>   ???
E   NameError: name 'vertices' is not defined

graph1:163: NameError
   - [# 154] SVD graph1: 
--------------------------------------------------------------------------------
  160:             return
  161:         if dst not in self.vertices:
  162:             return
  163:         if dst in self.vertices[src].adjacent:
- 164:             self.vertices[src].remove_adjacent(dst)
+ 164:             vertices[src].remove_adjacent(dst)
--------------------------------------------------------------------------------
[0.13326 s] killed by ALL-SMART/test_graph1_MIO.py::test_case_21

def test_case_21():
        weighted_graph_0 = module_0.WeightedGraph()
        var_0 = weighted_graph_0.add_edge(weighted_graph_0, weighted_graph_0)
>       var_1 = weighted_graph_0.remove_edge(weighted_graph_0, weighted_graph_0)

ALL-SMART/test_graph1_MIO.py:135: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <graph1.WeightedGraph object at 0x78ae564d1ab0>
src = <graph1.WeightedGraph object at 0x78ae564d1ab0>
dst = <graph1.WeightedGraph object at 0x78ae564d1ab0>

>   ???
E   NameError: name 'vertices' is not defined

graph1:164: NameError
   - [# 155] ZIL graph1: 
--------------------------------------------------------------------------------
   63:             elif visited[node] == 1:
   64:                 return True
   65:             visited[node] = -1
   66:             for neighbor in self.graph[node]:
-  67:                 if not (valid(neighbor)):
-  68:                     return False
+  67:                 break
+  68:             
   69:             return True
   70:         
   71:         for node in range(self.verticies):
   72:             
--------------------------------------------------------------------------------
[0.09710 s] killed by ALL-SMART/test_graph1_MIO.py::test_case_7

def test_case_7():
        bool_0 = True
        graph_0 = module_0.Graph(bool_0)
        bool_1 = False
        var_0 = graph_0.add_edge(bool_1, bool_1)
        assert graph_0.graph == {False: [False]}
        var_1 = graph_0.has_cycle()
>       assert var_1 is True
E       AssertionError

ALL-SMART/test_graph1_MIO.py:56: AssertionError
   - [# 156] ZIL graph1: 
--------------------------------------------------------------------------------
   71:         for node in range(self.verticies):
   72:             
   73:             
   74:             
-  75:             if not (visited[node]):
-  76:                 
-  77:                 if valid(node):
-  78:                     
-  79:                     visited = list(map((lambda x: (abs(x))), visited))
-  80:                 else:
-  81:                     
-  82:                     return True
+  75:             break
+  76:         
+  77:         
+  78:         
+  79:         
+  80:         
+  81:         
+  82:         
   83:         
   84:         return False
   85:     
   86:     def topological_sort(self):
--------------------------------------------------------------------------------
[0.09435 s] killed by ALL-SMART/test_graph1_MIO.py::test_case_7

def test_case_7():
        bool_0 = True
        graph_0 = module_0.Graph(bool_0)
        bool_1 = False
        var_0 = graph_0.add_edge(bool_1, bool_1)
        assert graph_0.graph == {False: [False]}
        var_1 = graph_0.has_cycle()
>       assert var_1 is True
E       AssertionError

ALL-SMART/test_graph1_MIO.py:56: AssertionError
   - [# 157] ZIL graph1: 
--------------------------------------------------------------------------------
  109:         
  110:         def dfs(vertex):
  111:             visited.add(vertex)
  112:             for j in self.graph[vertex]:
- 113:                 if j not in visited:
- 114:                     dfs(j)
+ 113:                 break
+ 114:             
  115:             
  116:             stack.appendleft(vertex)
  117:         
  118:         for (key, _) in self.graph.items():
--------------------------------------------------------------------------------
[0.14450 s] killed by ALL-SMART/test_graph1_MOSA.py::test_case_22

def test_case_22():
        bool_0 = True
        int_0 = 23
        graph_0 = module_0.Graph(int_0)
        bool_1 = False
        var_0 = graph_0.add_edge(bool_0, bool_1)
        assert graph_0.graph == {True: [False], False: []}
        var_1 = graph_0.topological_sort()
        graph_1 = module_0.Graph(var_1)
>       assert graph_1.verticies == [True, False]
E       AssertionError

ALL-SMART/test_graph1_MOSA.py:190: AssertionError
   - [# 158] ZIL graph1: 
--------------------------------------------------------------------------------
  115:             
  116:             stack.appendleft(vertex)
  117:         
  118:         for (key, _) in self.graph.items():
- 119:             if key not in visited:
- 120:                 dfs(key)
+ 119:             break
+ 120:         
  121:         
  122:         return list(stack)
  123: 
  124: class WeightedGraphNode:
--------------------------------------------------------------------------------
[0.14388 s] killed by ALL-SMART/test_graph1_MOSA.py::test_case_22

def test_case_22():
        bool_0 = True
        int_0 = 23
        graph_0 = module_0.Graph(int_0)
        bool_1 = False
        var_0 = graph_0.add_edge(bool_0, bool_1)
        assert graph_0.graph == {True: [False], False: []}
        var_1 = graph_0.topological_sort()
        graph_1 = module_0.Graph(var_1)
>       assert graph_1.verticies == [True, False]
E       AssertionError

ALL-SMART/test_graph1_MOSA.py:190: AssertionError
[*] Mutation score [26.99703 s]: 80.8%
   - all: 158
   - killed: 105 (66.5%)
   - survived: 25 (15.8%)
   - incompetent: 28 (17.7%)
   - timeout: 0 (0.0%)
