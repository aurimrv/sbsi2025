/home/lucca/desktop/ic/experimento/testes/python_experiments2/bst2/0-ts/test_bst2.py:148: SyntaxWarning: "is" with a literal. Did you mean "=="?
  assert test_bsts[2].size() is 2
/home/lucca/desktop/ic/experimento/testes/python_experiments2/bst2/0-ts/test_bst2.py:155: SyntaxWarning: "is" with a literal. Did you mean "=="?
  assert test_bsts[2].size() is 2
/home/lucca/desktop/ic/experimento/testes/python_experiments2/bst2/0-ts/test_bst2.py:162: SyntaxWarning: "is" with a literal. Did you mean "=="?
  assert test_bsts[1].size() is 0
/home/lucca/desktop/ic/experimento/testes/python_experiments2/bst2/0-ts/test_bst2.py:169: SyntaxWarning: "is" with a literal. Did you mean "=="?
  assert test_bsts[4].size() is 3
/home/lucca/desktop/ic/experimento/testes/python_experiments2/bst2/0-ts/test_bst2.py:176: SyntaxWarning: "is" with a literal. Did you mean "=="?
  assert test_bsts[5].size() is 5
/home/lucca/desktop/ic/experimento/testes/python_experiments2/bst2/0-ts/test_bst2.py:185: SyntaxWarning: "is" with a literal. Did you mean "=="?
  assert test_bsts[1].size() is 2
/home/lucca/desktop/ic/experimento/testes/python_experiments2/bst2/0-ts/test_bst2.py:194: SyntaxWarning: "is" with a literal. Did you mean "=="?
  assert test_bsts[1].size() is 2
/home/lucca/desktop/ic/experimento/testes/python_experiments2/bst2/0-ts/test_bst2.py:202: SyntaxWarning: "is" with a literal. Did you mean "=="?
  assert test_bsts[1].size() is 1
/home/lucca/desktop/ic/experimento/testes/python_experiments2/bst2/0-ts/test_bst2.py:203: SyntaxWarning: "is" with a literal. Did you mean "=="?
  assert test_bsts[1].root.val is 7
/home/lucca/desktop/ic/experimento/testes/python_experiments2/bst2/0-ts/test_bst2.py:210: SyntaxWarning: "is" with a literal. Did you mean "=="?
  assert test_bsts[3].size() is 6
/home/lucca/desktop/ic/experimento/testes/python_experiments2/bst2/0-ts/test_bst2.py:217: SyntaxWarning: "is" with a literal. Did you mean "=="?
  assert test_bsts[3].size() is 6
/home/lucca/desktop/ic/experimento/testes/python_experiments2/bst2/0-ts/test_bst2.py:218: SyntaxWarning: "is" with a literal. Did you mean "=="?
  assert test_bsts[3].root.val is 7
[34m[*][0m Start mutation process:
[36m   -[0m targets: bst2.py
[36m   -[0m tests: ./0-ts
[34m[*][0m 28 tests passed:
[36m   -[0m test_bst2 [0.36643 s]
[34m[*][0m Start mutants generation and execution:
[36m   -[0m [#   1] AOR bst2: 
--------------------------------------------------------------------------------
  152:         
  153:         leftbranch = 0 if not (tree.left) else tree.left.height
  154:         rightbranch = 0 if not (tree.right) else tree.right.height
  155:         
[34m- 156:         return leftbranch - rightbranch[0m
[32m+ 156:         return leftbranch + rightbranch[0m
  157:     
  158:     def pre_order(self, node='root'):
  159:         '''Depth first pre-order traversal of tree.'''
  160:         if node == 'root':
--------------------------------------------------------------------------------
[0.24444 s] [32mkilled[0m by 0-ts/test_bst2.py::test_balance_method

test_bsts = (<bst2.Bst object at 0x7ff228134340>, <bst2.Bst object at 0x7ff228134520>, <bst2.Bst object at 0x7ff2281348b0>, <bst2.Bst object at 0x7ff228134dc0>, <bst2.Bst object at 0x7ff228135150>, <bst2.Bst object at 0x7ff228135600>)

    def test_balance_method(test_bsts):
        """Test the balance method."""
        balance = [0, 0, 0, 0, 3, -5]
>       assert all(tree.balance() == balance[idx]
                   for idx, tree in enumerate(test_bsts))
E       AssertionError

0-ts/test_bst2.py:92: AssertionError
[36m   -[0m [#   2] ASR bst2: 
--------------------------------------------------------------------------------
   87:     def insert(self, val):
   88:         '''Insert val into BST. If val is already present will be ignored.'''
   89:         if not (self.root):
   90:             self.root = Node(val)
[34m-  91:             self._size += 1[0m
[32m+  91:             self._size -= 1[0m
   92:         else:
   93:             self._step(val, self.root)
   94:     
   95:     def _step(self, val, curr):
--------------------------------------------------------------------------------
[0.20226 s] [32mkilled[0m by 0-ts/test_bst2.py::test_insert_increases_size

test_bsts = (<bst2.Bst object at 0x7ff228060610>, <bst2.Bst object at 0x7ff228060760>, <bst2.Bst object at 0x7ff228060a60>, <bst2.Bst object at 0x7ff228060f70>, <bst2.Bst object at 0x7ff2280610c0>, <bst2.Bst object at 0x7ff228061570>)

    def test_insert_increases_size(test_bsts):
        """Test insert increases size."""
        test_bsts[0].insert(4)
>       assert test_bsts[0].size() == 1
E       AssertionError

0-ts/test_bst2.py:67: AssertionError
[36m   -[0m [#   3] ASR bst2: 
--------------------------------------------------------------------------------
  105:         child = getattr(curr, side)
  106:         if child:
  107:             count = self._step(val, child)
  108:             if curr.height <= count:
[34m- 109:                 curr.height += 1[0m
[32m+ 109:                 curr.height -= 1[0m
  110:         else:
  111:             setattr(curr, side, Node(val, curr))
  112:             self._size += 1
  113:             if curr.height == 1:
--------------------------------------------------------------------------------
[0.20045 s] [32mkilled[0m by 0-ts/test_bst2.py::test_depth_method

test_bsts = (<bst2.Bst object at 0x7ff227e4f4c0>, <bst2.Bst object at 0x7ff227e44220>, <bst2.Bst object at 0x7ff227e445b0>, <bst2.Bst object at 0x7ff227e44ac0>, <bst2.Bst object at 0x7ff227e44e50>, <bst2.Bst object at 0x7ff227e45300>)

    def test_depth_method(test_bsts):
        """Test depth method."""
        depths = [0, 1, 2, 3, 4, 6]
>       assert all(tree.depth() == depths[idx]
                   for idx, tree in enumerate(test_bsts))
E       AssertionError

0-ts/test_bst2.py:85: AssertionError
[36m   -[0m [#   4] ASR bst2: 
--------------------------------------------------------------------------------
  108:             if curr.height <= count:
  109:                 curr.height += 1
  110:         else:
  111:             setattr(curr, side, Node(val, curr))
[34m- 112:             self._size += 1[0m
[32m+ 112:             self._size -= 1[0m
  113:             if curr.height == 1:
  114:                 curr.height += 1
  115:         return curr
  116:     
--------------------------------------------------------------------------------
[0.28345 s] [32mkilled[0m by 0-ts/test_bst2.py::test_remove_leaf_left

test_bsts = (<bst2.Bst object at 0x7ff227d395a0>, <bst2.Bst object at 0x7ff227d39030>, <bst2.Bst object at 0x7ff227ccb610>, <bst2.Bst object at 0x7ff227cc93c0>, <bst2.Bst object at 0x7ff227ccaad0>, <bst2.Bst object at 0x7ff227ccb130>)

    def test_remove_leaf_left(test_bsts):
        """Test delete leaf on left."""
        test_bsts[2].delete(3)
>       assert not test_bsts[2].contains(3)
E       AssertionError

0-ts/test_bst2.py:147: AssertionError
[36m   -[0m [#   5] ASR bst2: 
--------------------------------------------------------------------------------
  110:         else:
  111:             setattr(curr, side, Node(val, curr))
  112:             self._size += 1
  113:             if curr.height == 1:
[34m- 114:                 curr.height += 1[0m
[32m+ 114:                 curr.height -= 1[0m
  115:         return curr
  116:     
  117:     def search(self, val):
  118:         '''Return the node containing val.'''
--------------------------------------------------------------------------------
[0.27471 s] [32mkilled[0m by 0-ts/test_bst2.py::test_depth_method

test_bsts = (<bst2.Bst object at 0x7ff22815da80>, <bst2.Bst object at 0x7ff22815ca90>, <bst2.Bst object at 0x7ff22815f2e0>, <bst2.Bst object at 0x7ff22815d000>, <bst2.Bst object at 0x7ff22815d570>, <bst2.Bst object at 0x7ff22815d240>)

    def test_depth_method(test_bsts):
        """Test depth method."""
        depths = [0, 1, 2, 3, 4, 6]
>       assert all(tree.depth() == depths[idx]
                   for idx, tree in enumerate(test_bsts))
E       AssertionError

0-ts/test_bst2.py:85: AssertionError
[36m   -[0m [#   6] ASR bst2: 
--------------------------------------------------------------------------------
  224:                 self.root = None
  225:         
  226:         elif node._is_interior():
  227:             next_node = self._find_replacement(node)
[34m- 228:             self._size += 1[0m
[32m+ 228:             self._size -= 1[0m
  229:             self.delete(next_node.val)
  230:             node.val = next_node.val
  231:         else:
  232:             
--------------------------------------------------------------------------------
[0.29473 s] [32mkilled[0m by 0-ts/test_bst2.py::test_delete_two_children

test_bsts = (<bst2.Bst object at 0x7ff22843fd90>, <bst2.Bst object at 0x7ff227cc8550>, <bst2.Bst object at 0x7ff227cc8160>, <bst2.Bst object at 0x7ff227cc8fa0>, <bst2.Bst object at 0x7ff227cc90f0>, <bst2.Bst object at 0x7ff227cc95a0>)

    def test_delete_two_children(test_bsts):
        """Test delete node with two children."""
        test_bsts[3].delete(3)
        assert not test_bsts[3].contains(3)
>       assert test_bsts[3].size() is 6
E       AssertionError

0-ts/test_bst2.py:210: AssertionError
[36m   -[0m [#   7] ASR bst2: 
--------------------------------------------------------------------------------
  236:                 setattr(node.parent, node._side(), child)
  237:             else:
  238:                 self.root = child
  239:         
[34m- 240:         self._size -= 1[0m
[32m+ 240:         self._size += 1[0m
  241:     
  242:     def _find_replacement(self, node):
  243:         '''Find left most node of right subtree.'''
  244:         if node.right:
--------------------------------------------------------------------------------
[0.27581 s] [32mkilled[0m by 0-ts/test_bst2.py::test_remove_leaf_left

test_bsts = (<bst2.Bst object at 0x7ff22820e560>, <bst2.Bst object at 0x7ff22820ff70>, <bst2.Bst object at 0x7ff22820f3a0>, <bst2.Bst object at 0x7ff22820ff10>, <bst2.Bst object at 0x7ff22820e020>, <bst2.Bst object at 0x7ff22820dc30>)

    def test_remove_leaf_left(test_bsts):
        """Test delete leaf on left."""
        test_bsts[2].delete(3)
        assert not test_bsts[2].contains(3)
>       assert test_bsts[2].size() is 2
E       AssertionError

0-ts/test_bst2.py:148: AssertionError
[36m   -[0m [#   8] CDI bst2: 
--------------------------------------------------------------------------------
    5: 
    6: class Node(object):
    7:     '''Node, or leaf of the BST.'''
    8:     
[34m-   9:     def __init__(self, val=None, parent=None):[0m
[34m-  10:         '''Create node object.'''[0m
[34m-  11:         self.val = val[0m
[34m-  12:         self.right = None[0m
[34m-  13:         self.left = None[0m
[34m-  14:         self.parent = parent[0m
[34m-  15:         self.height = 1[0m
[34m-  16:     [0m
[32m+   9:     @classmethod[0m
[32m+  10:     def __init__(self, val=None, parent=None):[0m
[32m+  11:         '''Create node object.'''[0m
[32m+  12:         self.val = val[0m
[32m+  13:         self.right = None[0m
[32m+  14:         self.left = None[0m
[32m+  15:         self.parent = parent[0m
[32m+  16:         self.height = 1[0m
   17:     def _is_leaf(self):
   18:         '''Return true if a leaf.'''
   19:         return not ((self.right or self.left))
   20:     
--------------------------------------------------------------------------------
[0.32864 s] [32mkilled[0m by 0-ts/test_bst2.py::test_insert_smallest_left

test_bsts = (<bst2.Bst object at 0x7ff22814ae30>, <bst2.Bst object at 0x7ff22814ae90>, <bst2.Bst object at 0x7ff22814ba00>, <bst2.Bst object at 0x7ff22814bc10>, <bst2.Bst object at 0x7ff22814b520>, <bst2.Bst object at 0x7ff22814afe0>)

    def test_insert_smallest_left(test_bsts):
        """Test insert the smallest to the left."""
        test_bsts[1].insert(3)
>       assert test_bsts[1].root.left.val < test_bsts[1].root.val
E       AssertionError

0-ts/test_bst2.py:55: AssertionError
[36m   -[0m [#   9] CDI bst2: 
--------------------------------------------------------------------------------
   13:         self.left = None
   14:         self.parent = parent
   15:         self.height = 1
   16:     
[34m-  17:     def _is_leaf(self):[0m
[34m-  18:         '''Return true if a leaf.'''[0m
[34m-  19:         return not ((self.right or self.left))[0m
[34m-  20:     [0m
[32m+  17:     @classmethod[0m
[32m+  18:     def _is_leaf(self):[0m
[32m+  19:         '''Return true if a leaf.'''[0m
[32m+  20:         return not ((self.right or self.left))[0m
   21:     def _is_interior(self):
   22:         '''Return true if a interior node.'''
   23:         return (self.right and self.left)
   24:     
--------------------------------------------------------------------------------
[0.36454 s] [32mkilled[0m by 0-ts/test_bst2.py::test_node_is_leaf

test_bsts = (<bst2.Bst object at 0x7ff2280144c0>, <bst2.Bst object at 0x7ff228014910>, <bst2.Bst object at 0x7ff227f93f40>, <bst2.Bst object at 0x7ff22801d000>, <bst2.Bst object at 0x7ff22801db70>, <bst2.Bst object at 0x7ff22801de40>)

    def test_node_is_leaf(test_bsts):
        """Test node is leaf bst."""
>       assert test_bsts[1].root._is_leaf()

0-ts/test_bst2.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <class 'bst2.Node'>

>   ???
E   AttributeError: type object 'Node' has no attribute 'right'

bst2:20: AttributeError
[36m   -[0m [#  10] CDI bst2: 
--------------------------------------------------------------------------------
   17:     def _is_leaf(self):
   18:         '''Return true if a leaf.'''
   19:         return not ((self.right or self.left))
   20:     
[34m-  21:     def _is_interior(self):[0m
[34m-  22:         '''Return true if a interior node.'''[0m
[34m-  23:         return (self.right and self.left)[0m
[34m-  24:     [0m
[32m+  21:     @classmethod[0m
[32m+  22:     def _is_interior(self):[0m
[32m+  23:         '''Return true if a interior node.'''[0m
[32m+  24:         return (self.right and self.left)[0m
   25:     def _onlychild(self):
   26:         '''Return string depending on children.'''
   27:         if (self.left and not (self.right)):
   28:             return 'left'
--------------------------------------------------------------------------------
[0.39425 s] [32mkilled[0m by 0-ts/test_bst2.py::test_remove_one_child_left

test_bsts = (<bst2.Bst object at 0x7ff22834eb00>, <bst2.Bst object at 0x7ff22834c490>, <bst2.Bst object at 0x7ff22834e9e0>, <bst2.Bst object at 0x7ff22834c8e0>, <bst2.Bst object at 0x7ff22834f7f0>, <bst2.Bst object at 0x7ff227eef370>)

    def test_remove_one_child_left(test_bsts):
        """Test delete node one child, left."""
>       test_bsts[4].delete(3)

0-ts/test_bst2.py:167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
bst2:226: in delete
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <class 'bst2.Node'>

>   ???
E   AttributeError: type object 'Node' has no attribute 'right'

bst2:24: AttributeError
[36m   -[0m [#  11] CDI bst2: 
--------------------------------------------------------------------------------
   21:     def _is_interior(self):
   22:         '''Return true if a interior node.'''
   23:         return (self.right and self.left)
   24:     
[34m-  25:     def _onlychild(self):[0m
[34m-  26:         '''Return string depending on children.'''[0m
[34m-  27:         if (self.left and not (self.right)):[0m
[34m-  28:             return 'left'[0m
[34m-  29:         if (self.right and not (self.left)):[0m
[34m-  30:             return 'right'[0m
[34m-  31:     [0m
[32m+  25:     @classmethod[0m
[32m+  26:     def _onlychild(self):[0m
[32m+  27:         '''Return string depending on children.'''[0m
[32m+  28:         if (self.left and not (self.right)):[0m
[32m+  29:             return 'left'[0m
[32m+  30:         if (self.right and not (self.left)):[0m
[32m+  31:             return 'right'[0m
   32:     def _side(self):
   33:         '''Return if left or right child of parent.'''
   34:         if self.parent:
   35:             return 'left' if self.parent.left == self else 'right'
--------------------------------------------------------------------------------
[0.28258 s] [32mkilled[0m by 0-ts/test_bst2.py::test_remove_one_child_left

test_bsts = (<bst2.Bst object at 0x7ff2282d82b0>, <bst2.Bst object at 0x7ff2282d9db0>, <bst2.Bst object at 0x7ff2282d8c70>, <bst2.Bst object at 0x7ff2282d8d30>, <bst2.Bst object at 0x7ff2282db520>, <bst2.Bst object at 0x7ff2280e2470>)

    def test_remove_one_child_left(test_bsts):
        """Test delete node one child, left."""
>       test_bsts[4].delete(3)

0-ts/test_bst2.py:167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
bst2:233: in delete
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <class 'bst2.Node'>

>   ???
E   AttributeError: type object 'Node' has no attribute 'left'

bst2:28: AttributeError
[36m   -[0m [#  12] CDI bst2: 
--------------------------------------------------------------------------------
   28:             return 'left'
   29:         if (self.right and not (self.left)):
   30:             return 'right'
   31:     
[34m-  32:     def _side(self):[0m
[34m-  33:         '''Return if left or right child of parent.'''[0m
[34m-  34:         if self.parent:[0m
[34m-  35:             return 'left' if self.parent.left == self else 'right'[0m
[34m-  36: [0m
[32m+  32:     @classmethod[0m
[32m+  33:     def _side(self):[0m
[32m+  34:         '''Return if left or right child of parent.'''[0m
[32m+  35:         if self.parent:[0m
[32m+  36:             return 'left' if self.parent.left == self else 'right'[0m
   37: 
   38: class Bst(object):
   39:     '''Binary Search Tree.
   40: 
--------------------------------------------------------------------------------
[0.29657 s] [32mkilled[0m by 0-ts/test_bst2.py::test_remove_leaf_left

test_bsts = (<bst2.Bst object at 0x7ff2281c9360>, <bst2.Bst object at 0x7ff2281c91b0>, <bst2.Bst object at 0x7ff2281c8190>, <bst2.Bst object at 0x7ff2281cb400>, <bst2.Bst object at 0x7ff2281c9e10>, <bst2.Bst object at 0x7ff2281ca890>)

    def test_remove_leaf_left(test_bsts):
        """Test delete leaf on left."""
>       test_bsts[2].delete(3)

0-ts/test_bst2.py:146: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
bst2:222: in delete
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <class 'bst2.Node'>

>   ???
E   AttributeError: type object 'Node' has no attribute 'parent'

bst2:35: AttributeError
[36m   -[0m [#  13] CDI bst2: 
--------------------------------------------------------------------------------
   74:     using breadth frist traversal, one at a time.
   75: 
   76:     '''
   77:     
[34m-  78:     def __init__(self, data=None):[0m
[34m-  79:         '''Initialize tree.'''[0m
[34m-  80:         self._size = 0[0m
[34m-  81:         self.root = None[0m
[34m-  82:         [0m
[34m-  83:         if data:[0m
[34m-  84:             for i in data:[0m
[34m-  85:                 self.insert(i)[0m
[34m-  86:     [0m
[32m+  78:     @classmethod[0m
[32m+  79:     def __init__(self, data=None):[0m
[32m+  80:         '''Initialize tree.'''[0m
[32m+  81:         self._size = 0[0m
[32m+  82:         self.root = None[0m
[32m+  83:         [0m
[32m+  84:         if data:[0m
[32m+  85:             for i in data:[0m
[32m+  86:                 self.insert(i)[0m
   87:     def insert(self, val):
   88:         '''Insert val into BST. If val is already present will be ignored.'''
   89:         if not (self.root):
   90:             self.root = Node(val)
--------------------------------------------------------------------------------
[0.22363 s] [36mincompetent[0m

TypeError: bst2:86: TypeError: Bst.insert() missing 1 required positional argument: 'val'

[36m   -[0m [#  14] CDI bst2: 
--------------------------------------------------------------------------------
   83:         if data:
   84:             for i in data:
   85:                 self.insert(i)
   86:     
[34m-  87:     def insert(self, val):[0m
[34m-  88:         '''Insert val into BST. If val is already present will be ignored.'''[0m
[34m-  89:         if not (self.root):[0m
[34m-  90:             self.root = Node(val)[0m
[34m-  91:             self._size += 1[0m
[34m-  92:         else:[0m
[34m-  93:             self._step(val, self.root)[0m
[34m-  94:     [0m
[32m+  87:     @classmethod[0m
[32m+  88:     def insert(self, val):[0m
[32m+  89:         '''Insert val into BST. If val is already present will be ignored.'''[0m
[32m+  90:         if not (self.root):[0m
[32m+  91:             self.root = Node(val)[0m
[32m+  92:             self._size += 1[0m
[32m+  93:         else:[0m
[32m+  94:             self._step(val, self.root)[0m
   95:     def _step(self, val, curr):
   96:         '''Decide left or right and returns height.'''
   97:         if val < curr.val:
   98:             curr = self._set_child(curr, 'left', val)
--------------------------------------------------------------------------------
[0.25346 s] [32mkilled[0m by 0-ts/test_bst2.py::test_node_is_leaf

@pytest.fixture
    def test_bsts():
        """Fixture for bst."""
        from bst2 import Bst
        empty = Bst()
>       one = Bst([5])

0-ts/test_bst2.py:11: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
bst2:85: in __init__
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <class 'bst2.Bst'>, val = 5

>   ???
E   AttributeError: type object 'Bst' has no attribute 'root'

bst2:90: AttributeError
[36m   -[0m [#  15] CDI bst2: 
--------------------------------------------------------------------------------
   91:             self._size += 1
   92:         else:
   93:             self._step(val, self.root)
   94:     
[34m-  95:     def _step(self, val, curr):[0m
[34m-  96:         '''Decide left or right and returns height.'''[0m
[34m-  97:         if val < curr.val:[0m
[34m-  98:             curr = self._set_child(curr, 'left', val)[0m
[34m-  99:         elif val > curr.val:[0m
[34m- 100:             curr = self._set_child(curr, 'right', val)[0m
[34m- 101:         return curr.height[0m
[34m- 102:     [0m
[32m+  95:     @classmethod[0m
[32m+  96:     def _step(self, val, curr):[0m
[32m+  97:         '''Decide left or right and returns height.'''[0m
[32m+  98:         if val < curr.val:[0m
[32m+  99:             curr = self._set_child(curr, 'left', val)[0m
[32m+ 100:         elif val > curr.val:[0m
[32m+ 101:             curr = self._set_child(curr, 'right', val)[0m
[32m+ 102:         return curr.height[0m
  103:     def _set_child(self, curr, side, val):
  104:         '''Helping.'''
  105:         child = getattr(curr, side)
  106:         if child:
--------------------------------------------------------------------------------
[0.25231 s] [36mincompetent[0m

TypeError: bst2:99: TypeError: Bst._set_child() missing 1 required positional argument: 'val'

[36m   -[0m [#  16] CDI bst2: 
--------------------------------------------------------------------------------
   99:         elif val > curr.val:
  100:             curr = self._set_child(curr, 'right', val)
  101:         return curr.height
  102:     
[34m- 103:     def _set_child(self, curr, side, val):[0m
[34m- 104:         '''Helping.'''[0m
[34m- 105:         child = getattr(curr, side)[0m
[34m- 106:         if child:[0m
[34m- 107:             count = self._step(val, child)[0m
[34m- 108:             if curr.height <= count:[0m
[34m- 109:                 curr.height += 1[0m
[34m- 110:         else:[0m
[34m- 111:             setattr(curr, side, Node(val, curr))[0m
[34m- 112:             self._size += 1[0m
[34m- 113:             if curr.height == 1:[0m
[34m- 114:                 curr.height += 1[0m
[34m- 115:         return curr[0m
[34m- 116:     [0m
[32m+ 103:     @classmethod[0m
[32m+ 104:     def _set_child(self, curr, side, val):[0m
[32m+ 105:         '''Helping.'''[0m
[32m+ 106:         child = getattr(curr, side)[0m
[32m+ 107:         if child:[0m
[32m+ 108:             count = self._step(val, child)[0m
[32m+ 109:             if curr.height <= count:[0m
[32m+ 110:                 curr.height += 1[0m
[32m+ 111:         else:[0m
[32m+ 112:             setattr(curr, side, Node(val, curr))[0m
[32m+ 113:             self._size += 1[0m
[32m+ 114:             if curr.height == 1:[0m
[32m+ 115:                 curr.height += 1[0m
[32m+ 116:         return curr[0m
  117:     def search(self, val):
  118:         '''Return the node containing val.'''
  119:         curr = self.root
  120:         while curr:
--------------------------------------------------------------------------------
[0.27391 s] [32mkilled[0m by 0-ts/test_bst2.py::test_node_is_leaf

@pytest.fixture
    def test_bsts():
        """Fixture for bst."""
        from bst2 import Bst
        empty = Bst()
        one = Bst([5])
>       three = Bst([5, 3, 7])

0-ts/test_bst2.py:12: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
bst2:85: in __init__
    ???
bst2:93: in insert
    ???
bst2:98: in _step
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <class 'bst2.Bst'>, curr = <bst2.Node object at 0x7ff22807ba00>
side = 'left', val = 3

>   ???
E   AttributeError: type object 'Bst' has no attribute '_size'

bst2:113: AttributeError
[36m   -[0m [#  17] CDI bst2: 
--------------------------------------------------------------------------------
  113:             if curr.height == 1:
  114:                 curr.height += 1
  115:         return curr
  116:     
[34m- 117:     def search(self, val):[0m
[34m- 118:         '''Return the node containing val.'''[0m
[34m- 119:         curr = self.root[0m
[34m- 120:         while curr:[0m
[34m- 121:             if curr.val == val:[0m
[34m- 122:                 return curr[0m
[34m- 123:             elif val < curr.val:[0m
[34m- 124:                 curr = curr.left[0m
[34m- 125:             else:[0m
[34m- 126:                 curr = curr.right[0m
[34m- 127:     [0m
[32m+ 117:     @classmethod[0m
[32m+ 118:     def search(self, val):[0m
[32m+ 119:         '''Return the node containing val.'''[0m
[32m+ 120:         curr = self.root[0m
[32m+ 121:         while curr:[0m
[32m+ 122:             if curr.val == val:[0m
[32m+ 123:                 return curr[0m
[32m+ 124:             elif val < curr.val:[0m
[32m+ 125:                 curr = curr.left[0m
[32m+ 126:             else:[0m
[32m+ 127:                 curr = curr.right[0m
  128:     def size(self):
  129:         '''Return the size of the BST.'''
  130:         return self._size
  131:     
--------------------------------------------------------------------------------
[0.25478 s] [32mkilled[0m by 0-ts/test_bst2.py::test_contains_method

test_bsts = (<bst2.Bst object at 0x7ff2280f8520>, <bst2.Bst object at 0x7ff2280f8a00>, <bst2.Bst object at 0x7ff2280f8cd0>, <bst2.Bst object at 0x7ff2280f9120>, <bst2.Bst object at 0x7ff2280f9660>, <bst2.Bst object at 0x7ff2280f9b70>)

    def test_contains_method(test_bsts):
        """Test contains on number that exists."""
>       assert test_bsts[2].contains(5)

0-ts/test_bst2.py:72: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
bst2:138: in contains
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <class 'bst2.Bst'>, val = 5

>   ???
E   AttributeError: type object 'Bst' has no attribute 'root'

bst2:120: AttributeError
[36m   -[0m [#  18] CDI bst2: 
--------------------------------------------------------------------------------
  124:                 curr = curr.left
  125:             else:
  126:                 curr = curr.right
  127:     
[34m- 128:     def size(self):[0m
[34m- 129:         '''Return the size of the BST.'''[0m
[34m- 130:         return self._size[0m
[34m- 131:     [0m
[32m+ 128:     @classmethod[0m
[32m+ 129:     def size(self):[0m
[32m+ 130:         '''Return the size of the BST.'''[0m
[32m+ 131:         return self._size[0m
  132:     def depth(self):
  133:         '''Return depth of the BST, representing total levels.'''
  134:         return 0 if not (self.root) else self.root.height
  135:     
--------------------------------------------------------------------------------
[0.36734 s] [32mkilled[0m by 0-ts/test_bst2.py::test_insert_increases_size

test_bsts = (<bst2.Bst object at 0x7ff227f46980>, <bst2.Bst object at 0x7ff227f44400>, <bst2.Bst object at 0x7ff227f46b90>, <bst2.Bst object at 0x7ff227f47670>, <bst2.Bst object at 0x7ff227f46620>, <bst2.Bst object at 0x7ff227f46bc0>)

    def test_insert_increases_size(test_bsts):
        """Test insert increases size."""
        test_bsts[0].insert(4)
>       assert test_bsts[0].size() == 1

0-ts/test_bst2.py:67: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <class 'bst2.Bst'>

>   ???
E   AttributeError: type object 'Bst' has no attribute '_size'

bst2:131: AttributeError
[36m   -[0m [#  19] CDI bst2: 
--------------------------------------------------------------------------------
  128:     def size(self):
  129:         '''Return the size of the BST.'''
  130:         return self._size
  131:     
[34m- 132:     def depth(self):[0m
[34m- 133:         '''Return depth of the BST, representing total levels.'''[0m
[34m- 134:         return 0 if not (self.root) else self.root.height[0m
[34m- 135:     [0m
[32m+ 132:     @classmethod[0m
[32m+ 133:     def depth(self):[0m
[32m+ 134:         '''Return depth of the BST, representing total levels.'''[0m
[32m+ 135:         return 0 if not (self.root) else self.root.height[0m
  136:     def contains(self, val):
  137:         '''Return true if val is in the bst.'''
  138:         return self.search(val) is not None
  139:     
--------------------------------------------------------------------------------
[0.30790 s] [32mkilled[0m by 0-ts/test_bst2.py::test_depth_method

test_bsts = (<bst2.Bst object at 0x7ff228209570>, <bst2.Bst object at 0x7ff22820acb0>, <bst2.Bst object at 0x7ff2282097e0>, <bst2.Bst object at 0x7ff2282d8c70>, <bst2.Bst object at 0x7ff2282da3b0>, <bst2.Bst object at 0x7ff2282d9d50>)

    def test_depth_method(test_bsts):
        """Test depth method."""
        depths = [0, 1, 2, 3, 4, 6]
>       assert all(tree.depth() == depths[idx]
                   for idx, tree in enumerate(test_bsts))

0-ts/test_bst2.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
0-ts/test_bst2.py:85: in <genexpr>
    assert all(tree.depth() == depths[idx]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <class 'bst2.Bst'>

>   ???
E   AttributeError: type object 'Bst' has no attribute 'root'

bst2:135: AttributeError
[36m   -[0m [#  20] CDI bst2: 
--------------------------------------------------------------------------------
  132:     def depth(self):
  133:         '''Return depth of the BST, representing total levels.'''
  134:         return 0 if not (self.root) else self.root.height
  135:     
[34m- 136:     def contains(self, val):[0m
[34m- 137:         '''Return true if val is in the bst.'''[0m
[34m- 138:         return self.search(val) is not None[0m
[34m- 139:     [0m
[32m+ 136:     @classmethod[0m
[32m+ 137:     def contains(self, val):[0m
[32m+ 138:         '''Return true if val is in the bst.'''[0m
[32m+ 139:         return self.search(val) is not None[0m
  140:     def balance(self, tree=None):
  141:         '''Return an integer of how well the tree is balanced.
  142: 
  143:         Trees which are higher on the left than the right should return a
--------------------------------------------------------------------------------
[0.25043 s] [36mincompetent[0m

TypeError: bst2:139: TypeError: Bst.search() missing 1 required positional argument: 'val'

[36m   -[0m [#  21] CDI bst2: 
--------------------------------------------------------------------------------
  136:     def contains(self, val):
  137:         '''Return true if val is in the bst.'''
  138:         return self.search(val) is not None
  139:     
[34m- 140:     def balance(self, tree=None):[0m
[34m- 141:         '''Return an integer of how well the tree is balanced.[0m
[34m- 142: [0m
[34m- 143:         Trees which are higher on the left than the right should return a[0m
[34m- 144:         positive value, trees which are higher on the right than the left[0m
[34m- 145:         should return a negative value. An ideally-balanced tree should[0m
[34m- 146:         return 0.[0m
[34m- 147:         '''[0m
[34m- 148:         if not tree:[0m
[34m- 149:             tree = self.root[0m
[34m- 150:             if not tree:[0m
[34m- 151:                 return 0[0m
[34m- 152:         [0m
[34m- 153:         leftbranch = 0 if not (tree.left) else tree.left.height[0m
[34m- 154:         rightbranch = 0 if not (tree.right) else tree.right.height[0m
[34m- 155:         [0m
[34m- 156:         return leftbranch - rightbranch[0m
[34m- 157:     [0m
[32m+ 140:     @classmethod[0m
[32m+ 141:     def balance(self, tree=None):[0m
[32m+ 142:         '''Return an integer of how well the tree is balanced.[0m
[32m+ 143: [0m
[32m+ 144:         Trees which are higher on the left than the right should return a[0m
[32m+ 145:         positive value, trees which are higher on the right than the left[0m
[32m+ 146:         should return a negative value. An ideally-balanced tree should[0m
[32m+ 147:         return 0.[0m
[32m+ 148:         '''[0m
[32m+ 149:         if not tree:[0m
[32m+ 150:             tree = self.root[0m
[32m+ 151:             if not tree:[0m
[32m+ 152:                 return 0[0m
[32m+ 153:         [0m
[32m+ 154:         leftbranch = 0 if not (tree.left) else tree.left.height[0m
[32m+ 155:         rightbranch = 0 if not (tree.right) else tree.right.height[0m
[32m+ 156:         [0m
[32m+ 157:         return leftbranch - rightbranch[0m
  158:     def pre_order(self, node='root'):
  159:         '''Depth first pre-order traversal of tree.'''
  160:         if node == 'root':
  161:             node = self.root
--------------------------------------------------------------------------------
[0.24204 s] [32mkilled[0m by 0-ts/test_bst2.py::test_balance_method

test_bsts = (<bst2.Bst object at 0x7ff227fe0730>, <bst2.Bst object at 0x7ff227fe0910>, <bst2.Bst object at 0x7ff227fe0ca0>, <bst2.Bst object at 0x7ff227fe11b0>, <bst2.Bst object at 0x7ff227fe1540>, <bst2.Bst object at 0x7ff227fe19f0>)

    def test_balance_method(test_bsts):
        """Test the balance method."""
        balance = [0, 0, 0, 0, 3, -5]
>       assert all(tree.balance() == balance[idx]
                   for idx, tree in enumerate(test_bsts))

0-ts/test_bst2.py:92: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
0-ts/test_bst2.py:92: in <genexpr>
    assert all(tree.balance() == balance[idx]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <class 'bst2.Bst'>, tree = None

>   ???
E   AttributeError: type object 'Bst' has no attribute 'root'

bst2:150: AttributeError
[36m   -[0m [#  22] CDI bst2: 
--------------------------------------------------------------------------------
  154:         rightbranch = 0 if not (tree.right) else tree.right.height
  155:         
  156:         return leftbranch - rightbranch
  157:     
[34m- 158:     def pre_order(self, node='root'):[0m
[34m- 159:         '''Depth first pre-order traversal of tree.'''[0m
[34m- 160:         if node == 'root':[0m
[34m- 161:             node = self.root[0m
[34m- 162:         [0m
[34m- 163:         if not node:[0m
[34m- 164:             return[0m
[34m- 165:         [0m
[34m- 166:         yield node.val[0m
[34m- 167:         [0m
[34m- 168:         for n in self.pre_order(node=node.left):[0m
[34m- 169:             yield n[0m
[34m- 170:         for n in self.pre_order(node=node.right):[0m
[34m- 171:             yield n[0m
[34m- 172:     [0m
[32m+ 158:     @classmethod[0m
[32m+ 159:     def pre_order(self, node='root'):[0m
[32m+ 160:         '''Depth first pre-order traversal of tree.'''[0m
[32m+ 161:         if node == 'root':[0m
[32m+ 162:             node = self.root[0m
[32m+ 163:         [0m
[32m+ 164:         if not node:[0m
[32m+ 165:             return[0m
[32m+ 166:         [0m
[32m+ 167:         yield node.val[0m
[32m+ 168:         [0m
[32m+ 169:         for n in self.pre_order(node=node.left):[0m
[32m+ 170:             yield n[0m
[32m+ 171:         for n in self.pre_order(node=node.right):[0m
[32m+ 172:             yield n[0m
  173:     def in_order(self, node='root'):
  174:         '''Depth first in-order traversal of tree.'''
  175:         if node == 'root':
  176:             node = self.root
--------------------------------------------------------------------------------
[0.34969 s] [32mkilled[0m by 0-ts/test_bst2.py::test_pre_order

test_traversals = {'breadth': ['F', 'B', 'G', 'A', 'D', 'I', ...], 'empty': <bst2.Bst object at 0x7ff227df9a20>, 'in_order': ['A', 'B', 'C', 'D', 'E', 'F', ...], 'post_order': ['A', 'C', 'E', 'D', 'B', 'H', ...], ...}

    def test_pre_order(test_traversals):
        """Test preorder for a traversal."""
>       path = [i for i in test_traversals['tree'].pre_order()]

0-ts/test_bst2.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
0-ts/test_bst2.py:103: in <listcomp>
    path = [i for i in test_traversals['tree'].pre_order()]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <class 'bst2.Bst'>, node = 'root'

>   ???
E   AttributeError: type object 'Bst' has no attribute 'root'

bst2:162: AttributeError
[36m   -[0m [#  23] CDI bst2: 
--------------------------------------------------------------------------------
  169:             yield n
  170:         for n in self.pre_order(node=node.right):
  171:             yield n
  172:     
[34m- 173:     def in_order(self, node='root'):[0m
[34m- 174:         '''Depth first in-order traversal of tree.'''[0m
[34m- 175:         if node == 'root':[0m
[34m- 176:             node = self.root[0m
[34m- 177:         [0m
[34m- 178:         if not node:[0m
[34m- 179:             return[0m
[34m- 180:         [0m
[34m- 181:         for n in self.in_order(node=node.left):[0m
[34m- 182:             yield n[0m
[34m- 183:         yield node.val[0m
[34m- 184:         for n in self.in_order(node=node.right):[0m
[34m- 185:             yield n[0m
[34m- 186:     [0m
[32m+ 173:     @classmethod[0m
[32m+ 174:     def in_order(self, node='root'):[0m
[32m+ 175:         '''Depth first in-order traversal of tree.'''[0m
[32m+ 176:         if node == 'root':[0m
[32m+ 177:             node = self.root[0m
[32m+ 178:         [0m
[32m+ 179:         if not node:[0m
[32m+ 180:             return[0m
[32m+ 181:         [0m
[32m+ 182:         for n in self.in_order(node=node.left):[0m
[32m+ 183:             yield n[0m
[32m+ 184:         yield node.val[0m
[32m+ 185:         for n in self.in_order(node=node.right):[0m
[32m+ 186:             yield n[0m
  187:     def post_order(self, node='root'):
  188:         '''Depth frist post_order traversal of tree.'''
  189:         if node == 'root':
  190:             node = self.root
--------------------------------------------------------------------------------
[0.22296 s] [32mkilled[0m by 0-ts/test_bst2.py::test_in_order

test_traversals = {'breadth': ['F', 'B', 'G', 'A', 'D', 'I', ...], 'empty': <bst2.Bst object at 0x7ff2280cc430>, 'in_order': ['A', 'B', 'C', 'D', 'E', 'F', ...], 'post_order': ['A', 'C', 'E', 'D', 'B', 'H', ...], ...}

    def test_in_order(test_traversals):
        """Test inorder for a traversal."""
>       path = [i for i in test_traversals['tree'].in_order()]

0-ts/test_bst2.py:109: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
0-ts/test_bst2.py:109: in <listcomp>
    path = [i for i in test_traversals['tree'].in_order()]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <class 'bst2.Bst'>, node = 'root'

>   ???
E   AttributeError: type object 'Bst' has no attribute 'root'

bst2:177: AttributeError
[36m   -[0m [#  24] CDI bst2: 
--------------------------------------------------------------------------------
  183:         yield node.val
  184:         for n in self.in_order(node=node.right):
  185:             yield n
  186:     
[34m- 187:     def post_order(self, node='root'):[0m
[34m- 188:         '''Depth frist post_order traversal of tree.'''[0m
[34m- 189:         if node == 'root':[0m
[34m- 190:             node = self.root[0m
[34m- 191:         [0m
[34m- 192:         if not node:[0m
[34m- 193:             return[0m
[34m- 194:         [0m
[34m- 195:         for n in self.post_order(node=node.left):[0m
[34m- 196:             yield n[0m
[34m- 197:         for n in self.post_order(node=node.right):[0m
[34m- 198:             yield n[0m
[34m- 199:         yield node.val[0m
[34m- 200:     [0m
[32m+ 187:     @classmethod[0m
[32m+ 188:     def post_order(self, node='root'):[0m
[32m+ 189:         '''Depth frist post_order traversal of tree.'''[0m
[32m+ 190:         if node == 'root':[0m
[32m+ 191:             node = self.root[0m
[32m+ 192:         [0m
[32m+ 193:         if not node:[0m
[32m+ 194:             return[0m
[32m+ 195:         [0m
[32m+ 196:         for n in self.post_order(node=node.left):[0m
[32m+ 197:             yield n[0m
[32m+ 198:         for n in self.post_order(node=node.right):[0m
[32m+ 199:             yield n[0m
[32m+ 200:         yield node.val[0m
  201:     def breadth_first(self):
  202:         '''Breadth first traversal of tree.'''
  203:         q = Queue()
  204:         q.enqueue(self.root)
--------------------------------------------------------------------------------
[0.21526 s] [32mkilled[0m by 0-ts/test_bst2.py::test_post_order

test_traversals = {'breadth': ['F', 'B', 'G', 'A', 'D', 'I', ...], 'empty': <bst2.Bst object at 0x7ff227c04040>, 'in_order': ['A', 'B', 'C', 'D', 'E', 'F', ...], 'post_order': ['A', 'C', 'E', 'D', 'B', 'H', ...], ...}

    def test_post_order(test_traversals):
        """Test postorder for a traversal."""
>       path = [i for i in test_traversals['tree'].post_order()]

0-ts/test_bst2.py:115: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
0-ts/test_bst2.py:115: in <listcomp>
    path = [i for i in test_traversals['tree'].post_order()]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <class 'bst2.Bst'>, node = 'root'

>   ???
E   AttributeError: type object 'Bst' has no attribute 'root'

bst2:191: AttributeError
[36m   -[0m [#  25] CDI bst2: 
--------------------------------------------------------------------------------
  197:         for n in self.post_order(node=node.right):
  198:             yield n
  199:         yield node.val
  200:     
[34m- 201:     def breadth_first(self):[0m
[34m- 202:         '''Breadth first traversal of tree.'''[0m
[34m- 203:         q = Queue()[0m
[34m- 204:         q.enqueue(self.root)[0m
[34m- 205:         while q.peek():[0m
[34m- 206:             node = q.dequeue()[0m
[34m- 207:             yield node.val[0m
[34m- 208:             if node.left:[0m
[34m- 209:                 q.enqueue(node.left)[0m
[34m- 210:             if node.right:[0m
[34m- 211:                 q.enqueue(node.right)[0m
[34m- 212:     [0m
[32m+ 201:     @classmethod[0m
[32m+ 202:     def breadth_first(self):[0m
[32m+ 203:         '''Breadth first traversal of tree.'''[0m
[32m+ 204:         q = Queue()[0m
[32m+ 205:         q.enqueue(self.root)[0m
[32m+ 206:         while q.peek():[0m
[32m+ 207:             node = q.dequeue()[0m
[32m+ 208:             yield node.val[0m
[32m+ 209:             if node.left:[0m
[32m+ 210:                 q.enqueue(node.left)[0m
[32m+ 211:             if node.right:[0m
[32m+ 212:                 q.enqueue(node.right)[0m
  213:     def delete(self, val):
  214:         '''Remove a node from the tree.'''
  215:         if (self._size < 1 or not (self.contains(val))):
  216:             return
--------------------------------------------------------------------------------
[0.26220 s] [32mkilled[0m by 0-ts/test_bst2.py::test_breadth_first

test_traversals = {'breadth': ['F', 'B', 'G', 'A', 'D', 'I', ...], 'empty': <bst2.Bst object at 0x7ff227d89a80>, 'in_order': ['A', 'B', 'C', 'D', 'E', 'F', ...], 'post_order': ['A', 'C', 'E', 'D', 'B', 'H', ...], ...}

    def test_breadth_first(test_traversals):
        """Test breadth first for a traversal."""
>       path = [i for i in test_traversals['tree'].breadth_first()]

0-ts/test_bst2.py:121: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
0-ts/test_bst2.py:121: in <listcomp>
    path = [i for i in test_traversals['tree'].breadth_first()]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <class 'bst2.Bst'>

>   ???
E   AttributeError: type object 'Bst' has no attribute 'root'

bst2:205: AttributeError
[36m   -[0m [#  26] CDI bst2: 
--------------------------------------------------------------------------------
  209:                 q.enqueue(node.left)
  210:             if node.right:
  211:                 q.enqueue(node.right)
  212:     
[34m- 213:     def delete(self, val):[0m
[34m- 214:         '''Remove a node from the tree.'''[0m
[34m- 215:         if (self._size < 1 or not (self.contains(val))):[0m
[34m- 216:             return[0m
[34m- 217:         [0m
[34m- 218:         node = self.search(val)[0m
[34m- 219:         [0m
[34m- 220:         if node._is_leaf():[0m
[34m- 221:             if node.parent:[0m
[34m- 222:                 setattr(node.parent, node._side(), None)[0m
[34m- 223:             else:[0m
[34m- 224:                 self.root = None[0m
[34m- 225:         [0m
[34m- 226:         elif node._is_interior():[0m
[34m- 227:             next_node = self._find_replacement(node)[0m
[34m- 228:             self._size += 1[0m
[34m- 229:             self.delete(next_node.val)[0m
[34m- 230:             node.val = next_node.val[0m
[34m- 231:         else:[0m
[34m- 232:             [0m
[34m- 233:             child = getattr(node, node._onlychild())[0m
[34m- 234:             if node.parent:[0m
[34m- 235:                 child.parent = node.parent[0m
[34m- 236:                 setattr(node.parent, node._side(), child)[0m
[34m- 237:             else:[0m
[34m- 238:                 self.root = child[0m
[34m- 239:         [0m
[34m- 240:         self._size -= 1[0m
[34m- 241:     [0m
[32m+ 213:     @classmethod[0m
[32m+ 214:     def delete(self, val):[0m
[32m+ 215:         '''Remove a node from the tree.'''[0m
[32m+ 216:         if (self._size < 1 or not (self.contains(val))):[0m
[32m+ 217:             return[0m
[32m+ 218:         [0m
[32m+ 219:         node = self.search(val)[0m
[32m+ 220:         [0m
[32m+ 221:         if node._is_leaf():[0m
[32m+ 222:             if node.parent:[0m
[32m+ 223:                 setattr(node.parent, node._side(), None)[0m
[32m+ 224:             else:[0m
[32m+ 225:                 self.root = None[0m
[32m+ 226:         [0m
[32m+ 227:         elif node._is_interior():[0m
[32m+ 228:             next_node = self._find_replacement(node)[0m
[32m+ 229:             self._size += 1[0m
[32m+ 230:             self.delete(next_node.val)[0m
[32m+ 231:             node.val = next_node.val[0m
[32m+ 232:         else:[0m
[32m+ 233:             [0m
[32m+ 234:             child = getattr(node, node._onlychild())[0m
[32m+ 235:             if node.parent:[0m
[32m+ 236:                 child.parent = node.parent[0m
[32m+ 237:                 setattr(node.parent, node._side(), child)[0m
[32m+ 238:             else:[0m
[32m+ 239:                 self.root = child[0m
[32m+ 240:         [0m
[32m+ 241:         self._size -= 1[0m
  242:     def _find_replacement(self, node):
  243:         '''Find left most node of right subtree.'''
  244:         if node.right:
  245:             return self._findmin(node.right)
--------------------------------------------------------------------------------
[0.33444 s] [32mkilled[0m by 0-ts/test_bst2.py::test_del_false

test_bsts = (<bst2.Bst object at 0x7ff22800fe50>, <bst2.Bst object at 0x7ff22800f250>, <bst2.Bst object at 0x7ff22800f160>, <bst2.Bst object at 0x7ff22800efb0>, <bst2.Bst object at 0x7ff22800ed70>, <bst2.Bst object at 0x7ff22800e920>)

    def test_del_false(test_bsts):
        """Test delete for a node not in tree."""
        size = test_bsts[2].size()
>       test_bsts[2].delete(1)

0-ts/test_bst2.py:134: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <class 'bst2.Bst'>, val = 1

>   ???
E   AttributeError: type object 'Bst' has no attribute '_size'

bst2:216: AttributeError
[36m   -[0m [#  27] CDI bst2: 
--------------------------------------------------------------------------------
  238:                 self.root = child
  239:         
  240:         self._size -= 1
  241:     
[34m- 242:     def _find_replacement(self, node):[0m
[34m- 243:         '''Find left most node of right subtree.'''[0m
[34m- 244:         if node.right:[0m
[34m- 245:             return self._findmin(node.right)[0m
[34m- 246:         [0m
[34m- 247:         elif node.parent:[0m
[34m- 248:             if node._side() == 'left':[0m
[34m- 249:                 return self.parent[0m
[34m- 250:             else:[0m
[34m- 251:                 node.parent.right = None[0m
[34m- 252:                 tmp = self._find_replacement(node.parent)[0m
[34m- 253:                 node.parent.right = node[0m
[34m- 254:                 return tmp[0m
[34m- 255:     [0m
[32m+ 242:     @classmethod[0m
[32m+ 243:     def _find_replacement(self, node):[0m
[32m+ 244:         '''Find left most node of right subtree.'''[0m
[32m+ 245:         if node.right:[0m
[32m+ 246:             return self._findmin(node.right)[0m
[32m+ 247:         [0m
[32m+ 248:         elif node.parent:[0m
[32m+ 249:             if node._side() == 'left':[0m
[32m+ 250:                 return self.parent[0m
[32m+ 251:             else:[0m
[32m+ 252:                 node.parent.right = None[0m
[32m+ 253:                 tmp = self._find_replacement(node.parent)[0m
[32m+ 254:                 node.parent.right = node[0m
[32m+ 255:                 return tmp[0m
  256:     def _findmin(self, node):
  257:         '''Find min of subtree, Min is always left most node.'''
  258:         while node.left:
  259:             node = node.left
--------------------------------------------------------------------------------
[0.28112 s] [36mincompetent[0m

TypeError: bst2:246: TypeError: Bst._findmin() missing 1 required positional argument: 'node'

[36m   -[0m [#  28] CDI bst2: 
--------------------------------------------------------------------------------
  252:                 tmp = self._find_replacement(node.parent)
  253:                 node.parent.right = node
  254:                 return tmp
  255:     
[34m- 256:     def _findmin(self, node):[0m
[34m- 257:         '''Find min of subtree, Min is always left most node.'''[0m
[34m- 258:         while node.left:[0m
[34m- 259:             node = node.left[0m
[34m- 260:         return node[0m
[32m+ 256:     @classmethod[0m
[32m+ 257:     def _findmin(self, node):[0m
[32m+ 258:         '''Find min of subtree, Min is always left most node.'''[0m
[32m+ 259:         while node.left:[0m
[32m+ 260:             node = node.left[0m
[32m+ 261:         return node[0m
--------------------------------------------------------------------------------
[0.24617 s] [31msurvived[0m
[36m   -[0m [#  29] COD bst2: 
--------------------------------------------------------------------------------
   15:         self.height = 1
   16:     
   17:     def _is_leaf(self):
   18:         '''Return true if a leaf.'''
[34m-  19:         return not ((self.right or self.left))[0m
[32m+  19:         return (self.right or self.left)[0m
   20:     
   21:     def _is_interior(self):
   22:         '''Return true if a interior node.'''
   23:         return (self.right and self.left)
--------------------------------------------------------------------------------
[0.27777 s] [32mkilled[0m by 0-ts/test_bst2.py::test_node_is_leaf

test_bsts = (<bst2.Bst object at 0x7ff227d65150>, <bst2.Bst object at 0x7ff227d67160>, <bst2.Bst object at 0x7ff227d663e0>, <bst2.Bst object at 0x7ff227d66830>, <bst2.Bst object at 0x7ff227d66cb0>, <bst2.Bst object at 0x7ff227d65d80>)

    def test_node_is_leaf(test_bsts):
        """Test node is leaf bst."""
>       assert test_bsts[1].root._is_leaf()
E       AssertionError

0-ts/test_bst2.py:36: AssertionError
[36m   -[0m [#  30] COD bst2: 
--------------------------------------------------------------------------------
   23:         return (self.right and self.left)
   24:     
   25:     def _onlychild(self):
   26:         '''Return string depending on children.'''
[34m-  27:         if (self.left and not (self.right)):[0m
[32m+  27:         if (self.left and self.right):[0m
   28:             return 'left'
   29:         if (self.right and not (self.left)):
   30:             return 'right'
   31:     
--------------------------------------------------------------------------------
[0.29204 s] [36mincompetent[0m

TypeError: bst2:233: TypeError: getattr(): attribute name must be string

[36m   -[0m [#  31] COD bst2: 
--------------------------------------------------------------------------------
   25:     def _onlychild(self):
   26:         '''Return string depending on children.'''
   27:         if (self.left and not (self.right)):
   28:             return 'left'
[34m-  29:         if (self.right and not (self.left)):[0m
[32m+  29:         if (self.right and self.left):[0m
   30:             return 'right'
   31:     
   32:     def _side(self):
   33:         '''Return if left or right child of parent.'''
--------------------------------------------------------------------------------
[0.50004 s] [36mincompetent[0m

TypeError: bst2:233: TypeError: getattr(): attribute name must be string

[36m   -[0m [#  32] COD bst2: 
--------------------------------------------------------------------------------
   85:                 self.insert(i)
   86:     
   87:     def insert(self, val):
   88:         '''Insert val into BST. If val is already present will be ignored.'''
[34m-  89:         if not (self.root):[0m
[32m+  89:         if self.root:[0m
   90:             self.root = Node(val)
   91:             self._size += 1
   92:         else:
   93:             self._step(val, self.root)
--------------------------------------------------------------------------------
[0.25009 s] [32mkilled[0m by 0-ts/test_bst2.py::test_node_is_leaf

@pytest.fixture
    def test_bsts():
        """Fixture for bst."""
        from bst2 import Bst
        empty = Bst()
>       one = Bst([5])

0-ts/test_bst2.py:11: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
bst2:85: in __init__
    ???
bst2:93: in insert
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x7ff227eec310>, val = 5, curr = None

>   ???
E   AttributeError: 'NoneType' object has no attribute 'val'

bst2:97: AttributeError
[36m   -[0m [#  33] COD bst2: 
--------------------------------------------------------------------------------
  130:         return self._size
  131:     
  132:     def depth(self):
  133:         '''Return depth of the BST, representing total levels.'''
[34m- 134:         return 0 if not (self.root) else self.root.height[0m
[32m+ 134:         return 0 if self.root else self.root.height[0m
  135:     
  136:     def contains(self, val):
  137:         '''Return true if val is in the bst.'''
  138:         return self.search(val) is not None
--------------------------------------------------------------------------------
[0.26370 s] [32mkilled[0m by 0-ts/test_bst2.py::test_depth_method

test_bsts = (<bst2.Bst object at 0x7ff227becb20>, <bst2.Bst object at 0x7ff227bef490>, <bst2.Bst object at 0x7ff227bec850>, <bst2.Bst object at 0x7ff227bed870>, <bst2.Bst object at 0x7ff227bed210>, <bst2.Bst object at 0x7ff227bec3d0>)

    def test_depth_method(test_bsts):
        """Test depth method."""
        depths = [0, 1, 2, 3, 4, 6]
>       assert all(tree.depth() == depths[idx]
                   for idx, tree in enumerate(test_bsts))

0-ts/test_bst2.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
0-ts/test_bst2.py:85: in <genexpr>
    assert all(tree.depth() == depths[idx]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x7ff227becb20>

>   ???
E   AttributeError: 'NoneType' object has no attribute 'height'

bst2:134: AttributeError
[36m   -[0m [#  34] COD bst2: 
--------------------------------------------------------------------------------
  144:         positive value, trees which are higher on the right than the left
  145:         should return a negative value. An ideally-balanced tree should
  146:         return 0.
  147:         '''
[34m- 148:         if not tree:[0m
[32m+ 148:         if tree:[0m
  149:             tree = self.root
  150:             if not tree:
  151:                 return 0
  152:         
--------------------------------------------------------------------------------
[0.20903 s] [32mkilled[0m by 0-ts/test_bst2.py::test_balance_method

test_bsts = (<bst2.Bst object at 0x7ff227fec670>, <bst2.Bst object at 0x7ff227feca90>, <bst2.Bst object at 0x7ff227fee9e0>, <bst2.Bst object at 0x7ff227fecbe0>, <bst2.Bst object at 0x7ff227fecfd0>, <bst2.Bst object at 0x7ff227fed240>)

    def test_balance_method(test_bsts):
        """Test the balance method."""
        balance = [0, 0, 0, 0, 3, -5]
>       assert all(tree.balance() == balance[idx]
                   for idx, tree in enumerate(test_bsts))

0-ts/test_bst2.py:92: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
0-ts/test_bst2.py:92: in <genexpr>
    assert all(tree.balance() == balance[idx]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x7ff227fec670>, tree = None

>   ???
E   AttributeError: 'NoneType' object has no attribute 'left'

bst2:153: AttributeError
[36m   -[0m [#  35] COD bst2: 
--------------------------------------------------------------------------------
  146:         return 0.
  147:         '''
  148:         if not tree:
  149:             tree = self.root
[34m- 150:             if not tree:[0m
[32m+ 150:             if tree:[0m
  151:                 return 0
  152:         
  153:         leftbranch = 0 if not (tree.left) else tree.left.height
  154:         rightbranch = 0 if not (tree.right) else tree.right.height
--------------------------------------------------------------------------------
[0.32113 s] [32mkilled[0m by 0-ts/test_bst2.py::test_balance_method

test_bsts = (<bst2.Bst object at 0x7ff227dfa710>, <bst2.Bst object at 0x7ff227dfabc0>, <bst2.Bst object at 0x7ff227df9ae0>, <bst2.Bst object at 0x7ff227df9090>, <bst2.Bst object at 0x7ff227dfaf80>, <bst2.Bst object at 0x7ff227dfb430>)

    def test_balance_method(test_bsts):
        """Test the balance method."""
        balance = [0, 0, 0, 0, 3, -5]
>       assert all(tree.balance() == balance[idx]
                   for idx, tree in enumerate(test_bsts))

0-ts/test_bst2.py:92: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
0-ts/test_bst2.py:92: in <genexpr>
    assert all(tree.balance() == balance[idx]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x7ff227dfa710>, tree = None

>   ???
E   AttributeError: 'NoneType' object has no attribute 'left'

bst2:153: AttributeError
[36m   -[0m [#  36] COD bst2: 
--------------------------------------------------------------------------------
  149:             tree = self.root
  150:             if not tree:
  151:                 return 0
  152:         
[34m- 153:         leftbranch = 0 if not (tree.left) else tree.left.height[0m
[32m+ 153:         leftbranch = 0 if tree.left else tree.left.height[0m
  154:         rightbranch = 0 if not (tree.right) else tree.right.height
  155:         
  156:         return leftbranch - rightbranch
  157:     
--------------------------------------------------------------------------------
[0.21935 s] [32mkilled[0m by 0-ts/test_bst2.py::test_balance_method

test_bsts = (<bst2.Bst object at 0x7ff227b02320>, <bst2.Bst object at 0x7ff22815e290>, <bst2.Bst object at 0x7ff22815d660>, <bst2.Bst object at 0x7ff22815d3c0>, <bst2.Bst object at 0x7ff22815c1f0>, <bst2.Bst object at 0x7ff22815f6a0>)

    def test_balance_method(test_bsts):
        """Test the balance method."""
        balance = [0, 0, 0, 0, 3, -5]
>       assert all(tree.balance() == balance[idx]
                   for idx, tree in enumerate(test_bsts))

0-ts/test_bst2.py:92: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
0-ts/test_bst2.py:92: in <genexpr>
    assert all(tree.balance() == balance[idx]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x7ff22815e290>
tree = <bst2.Node object at 0x7ff22815dba0>

>   ???
E   AttributeError: 'NoneType' object has no attribute 'height'

bst2:153: AttributeError
[36m   -[0m [#  37] COD bst2: 
--------------------------------------------------------------------------------
  150:             if not tree:
  151:                 return 0
  152:         
  153:         leftbranch = 0 if not (tree.left) else tree.left.height
[34m- 154:         rightbranch = 0 if not (tree.right) else tree.right.height[0m
[32m+ 154:         rightbranch = 0 if tree.right else tree.right.height[0m
  155:         
  156:         return leftbranch - rightbranch
  157:     
  158:     def pre_order(self, node='root'):
--------------------------------------------------------------------------------
[0.22639 s] [32mkilled[0m by 0-ts/test_bst2.py::test_balance_method

test_bsts = (<bst2.Bst object at 0x7ff22826c790>, <bst2.Bst object at 0x7ff22826d390>, <bst2.Bst object at 0x7ff22826f0a0>, <bst2.Bst object at 0x7ff22826cd90>, <bst2.Bst object at 0x7ff22826c100>, <bst2.Bst object at 0x7ff22826cdc0>)

    def test_balance_method(test_bsts):
        """Test the balance method."""
        balance = [0, 0, 0, 0, 3, -5]
>       assert all(tree.balance() == balance[idx]
                   for idx, tree in enumerate(test_bsts))

0-ts/test_bst2.py:92: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
0-ts/test_bst2.py:92: in <genexpr>
    assert all(tree.balance() == balance[idx]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x7ff22826d390>
tree = <bst2.Node object at 0x7ff22826dcf0>

>   ???
E   AttributeError: 'NoneType' object has no attribute 'height'

bst2:154: AttributeError
[36m   -[0m [#  38] COD bst2: 
--------------------------------------------------------------------------------
  159:         '''Depth first pre-order traversal of tree.'''
  160:         if node == 'root':
  161:             node = self.root
  162:         
[34m- 163:         if not node:[0m
[32m+ 163:         if node:[0m
  164:             return
  165:         
  166:         yield node.val
  167:         
--------------------------------------------------------------------------------
[0.23517 s] [32mkilled[0m by 0-ts/test_bst2.py::test_pre_order

test_traversals = {'breadth': ['F', 'B', 'G', 'A', 'D', 'I', ...], 'empty': <bst2.Bst object at 0x7ff227d68fa0>, 'in_order': ['A', 'B', 'C', 'D', 'E', 'F', ...], 'post_order': ['A', 'C', 'E', 'D', 'B', 'H', ...], ...}

    def test_pre_order(test_traversals):
        """Test preorder for a traversal."""
        path = [i for i in test_traversals['tree'].pre_order()]
>       assert path == test_traversals['pre_order']
E       AssertionError

0-ts/test_bst2.py:104: AssertionError
[36m   -[0m [#  39] COD bst2: 
--------------------------------------------------------------------------------
  174:         '''Depth first in-order traversal of tree.'''
  175:         if node == 'root':
  176:             node = self.root
  177:         
[34m- 178:         if not node:[0m
[32m+ 178:         if node:[0m
  179:             return
  180:         
  181:         for n in self.in_order(node=node.left):
  182:             yield n
--------------------------------------------------------------------------------
[0.21519 s] [32mkilled[0m by 0-ts/test_bst2.py::test_in_order

test_traversals = {'breadth': ['F', 'B', 'G', 'A', 'D', 'I', ...], 'empty': <bst2.Bst object at 0x7ff227fd62c0>, 'in_order': ['A', 'B', 'C', 'D', 'E', 'F', ...], 'post_order': ['A', 'C', 'E', 'D', 'B', 'H', ...], ...}

    def test_in_order(test_traversals):
        """Test inorder for a traversal."""
        path = [i for i in test_traversals['tree'].in_order()]
>       assert path == test_traversals['in_order']
E       AssertionError

0-ts/test_bst2.py:110: AssertionError
[36m   -[0m [#  40] COD bst2: 
--------------------------------------------------------------------------------
  188:         '''Depth frist post_order traversal of tree.'''
  189:         if node == 'root':
  190:             node = self.root
  191:         
[34m- 192:         if not node:[0m
[32m+ 192:         if node:[0m
  193:             return
  194:         
  195:         for n in self.post_order(node=node.left):
  196:             yield n
--------------------------------------------------------------------------------
[0.31207 s] [32mkilled[0m by 0-ts/test_bst2.py::test_post_order

test_traversals = {'breadth': ['F', 'B', 'G', 'A', 'D', 'I', ...], 'empty': <bst2.Bst object at 0x7ff227eb35b0>, 'in_order': ['A', 'B', 'C', 'D', 'E', 'F', ...], 'post_order': ['A', 'C', 'E', 'D', 'B', 'H', ...], ...}

    def test_post_order(test_traversals):
        """Test postorder for a traversal."""
        path = [i for i in test_traversals['tree'].post_order()]
>       assert path == test_traversals['post_order']
E       AssertionError

0-ts/test_bst2.py:116: AssertionError
[36m   -[0m [#  41] COD bst2: 
--------------------------------------------------------------------------------
  211:                 q.enqueue(node.right)
  212:     
  213:     def delete(self, val):
  214:         '''Remove a node from the tree.'''
[34m- 215:         if (self._size < 1 or not (self.contains(val))):[0m
[32m+ 215:         if (self._size < 1 or self.contains(val)):[0m
  216:             return
  217:         
  218:         node = self.search(val)
  219:         
--------------------------------------------------------------------------------
[0.27383 s] [32mkilled[0m by 0-ts/test_bst2.py::test_del_false

test_bsts = (<bst2.Bst object at 0x7ff22815f010>, <bst2.Bst object at 0x7ff22815c790>, <bst2.Bst object at 0x7ff22815dd20>, <bst2.Bst object at 0x7ff22815cc10>, <bst2.Bst object at 0x7ff22815f490>, <bst2.Bst object at 0x7ff22815f910>)

    def test_del_false(test_bsts):
        """Test delete for a node not in tree."""
        size = test_bsts[2].size()
>       test_bsts[2].delete(1)

0-ts/test_bst2.py:134: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x7ff22815dd20>, val = 1

>   ???
E   AttributeError: 'NoneType' object has no attribute '_is_leaf'

bst2:220: AttributeError
[36m   -[0m [#  42] COI bst2: 
--------------------------------------------------------------------------------
   23:         return (self.right and self.left)
   24:     
   25:     def _onlychild(self):
   26:         '''Return string depending on children.'''
[34m-  27:         if (self.left and not (self.right)):[0m
[32m+  27:         if not ((self.left and not (self.right))):[0m
   28:             return 'left'
   29:         if (self.right and not (self.left)):
   30:             return 'right'
   31:     
--------------------------------------------------------------------------------
[0.23557 s] [36mincompetent[0m

TypeError: bst2:233: TypeError: getattr(): attribute name must be string

[36m   -[0m [#  43] COI bst2: 
--------------------------------------------------------------------------------
   25:     def _onlychild(self):
   26:         '''Return string depending on children.'''
   27:         if (self.left and not (self.right)):
   28:             return 'left'
[34m-  29:         if (self.right and not (self.left)):[0m
[32m+  29:         if not ((self.right and not (self.left))):[0m
   30:             return 'right'
   31:     
   32:     def _side(self):
   33:         '''Return if left or right child of parent.'''
--------------------------------------------------------------------------------
[0.29055 s] [36mincompetent[0m

TypeError: bst2:233: TypeError: getattr(): attribute name must be string

[36m   -[0m [#  44] COI bst2: 
--------------------------------------------------------------------------------
   30:             return 'right'
   31:     
   32:     def _side(self):
   33:         '''Return if left or right child of parent.'''
[34m-  34:         if self.parent:[0m
[32m+  34:         if not (self.parent):[0m
   35:             return 'left' if self.parent.left == self else 'right'
   36: 
   37: 
   38: class Bst(object):
--------------------------------------------------------------------------------
[0.25711 s] [36mincompetent[0m

TypeError: bst2:222: TypeError: attribute name must be string, not 'NoneType'

[36m   -[0m [#  45] COI bst2: 
--------------------------------------------------------------------------------
   79:         '''Initialize tree.'''
   80:         self._size = 0
   81:         self.root = None
   82:         
[34m-  83:         if data:[0m
[32m+  83:         if not data:[0m
   84:             for i in data:
   85:                 self.insert(i)
   86:     
   87:     def insert(self, val):
--------------------------------------------------------------------------------
[0.18955 s] [36mincompetent[0m

TypeError: bst2:84: TypeError: 'NoneType' object is not iterable

[36m   -[0m [#  46] COI bst2: 
--------------------------------------------------------------------------------
   85:                 self.insert(i)
   86:     
   87:     def insert(self, val):
   88:         '''Insert val into BST. If val is already present will be ignored.'''
[34m-  89:         if not (self.root):[0m
[32m+  89:         if not ((not (self.root))):[0m
   90:             self.root = Node(val)
   91:             self._size += 1
   92:         else:
   93:             self._step(val, self.root)
--------------------------------------------------------------------------------
[0.18868 s] [32mkilled[0m by 0-ts/test_bst2.py::test_node_is_leaf

@pytest.fixture
    def test_bsts():
        """Fixture for bst."""
        from bst2 import Bst
        empty = Bst()
>       one = Bst([5])

0-ts/test_bst2.py:11: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
bst2:85: in __init__
    ???
bst2:93: in insert
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x7ff227f85fc0>, val = 5, curr = None

>   ???
E   AttributeError: 'NoneType' object has no attribute 'val'

bst2:97: AttributeError
[36m   -[0m [#  47] COI bst2: 
--------------------------------------------------------------------------------
   93:             self._step(val, self.root)
   94:     
   95:     def _step(self, val, curr):
   96:         '''Decide left or right and returns height.'''
[34m-  97:         if val < curr.val:[0m
[32m+  97:         if not (val < curr.val):[0m
   98:             curr = self._set_child(curr, 'left', val)
   99:         elif val > curr.val:
  100:             curr = self._set_child(curr, 'right', val)
  101:         return curr.height
--------------------------------------------------------------------------------
[0.19244 s] [32mkilled[0m by 0-ts/test_bst2.py::test_insert_updates_pointers

test_bsts = (<bst2.Bst object at 0x7ff22834b4f0>, <bst2.Bst object at 0x7ff228349f60>, <bst2.Bst object at 0x7ff228349ed0>, <bst2.Bst object at 0x7ff22834b370>, <bst2.Bst object at 0x7ff22834b0a0>, <bst2.Bst object at 0x7ff228348b20>)

    def test_insert_updates_pointers(test_bsts):
        """Test insert updates pointers."""
        test_bsts[1].insert(3)
>       assert test_bsts[1].root.left.val == 3
E       AttributeError: 'NoneType' object has no attribute 'val'

0-ts/test_bst2.py:48: AttributeError
[36m   -[0m [#  48] COI bst2: 
--------------------------------------------------------------------------------
   95:     def _step(self, val, curr):
   96:         '''Decide left or right and returns height.'''
   97:         if val < curr.val:
   98:             curr = self._set_child(curr, 'left', val)
[34m-  99:         elif val > curr.val:[0m
[32m+  99:         elif not (val > curr.val):[0m
  100:             curr = self._set_child(curr, 'right', val)
  101:         return curr.height
  102:     
  103:     def _set_child(self, curr, side, val):
--------------------------------------------------------------------------------
[0.23604 s] [32mkilled[0m by 0-ts/test_bst2.py::test_insert_largest_right

test_bsts = (<bst2.Bst object at 0x7ff22834d6f0>, <bst2.Bst object at 0x7ff22834d180>, <bst2.Bst object at 0x7ff22834cbb0>, <bst2.Bst object at 0x7ff22834e290>, <bst2.Bst object at 0x7ff22834ec20>, <bst2.Bst object at 0x7ff22834f1c0>)

    def test_insert_largest_right(test_bsts):
        """Test insert the largest to the right."""
        test_bsts[1].insert(7)
>       assert test_bsts[1].root.right.val > test_bsts[1].root.val
E       AttributeError: 'NoneType' object has no attribute 'val'

0-ts/test_bst2.py:61: AttributeError
[36m   -[0m [#  49] COI bst2: 
--------------------------------------------------------------------------------
  102:     
  103:     def _set_child(self, curr, side, val):
  104:         '''Helping.'''
  105:         child = getattr(curr, side)
[34m- 106:         if child:[0m
[32m+ 106:         if not child:[0m
  107:             count = self._step(val, child)
  108:             if curr.height <= count:
  109:                 curr.height += 1
  110:         else:
--------------------------------------------------------------------------------
[0.38870 s] [32mkilled[0m by 0-ts/test_bst2.py::test_node_is_leaf

@pytest.fixture
    def test_bsts():
        """Fixture for bst."""
        from bst2 import Bst
        empty = Bst()
        one = Bst([5])
>       three = Bst([5, 3, 7])

0-ts/test_bst2.py:12: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
bst2:85: in __init__
    ???
bst2:93: in insert
    ???
bst2:98: in _step
    ???
bst2:107: in _set_child
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x7ff227c3b3d0>, val = 3, curr = None

>   ???
E   AttributeError: 'NoneType' object has no attribute 'val'

bst2:97: AttributeError
[36m   -[0m [#  50] COI bst2: 
--------------------------------------------------------------------------------
  104:         '''Helping.'''
  105:         child = getattr(curr, side)
  106:         if child:
  107:             count = self._step(val, child)
[34m- 108:             if curr.height <= count:[0m
[32m+ 108:             if not (curr.height <= count):[0m
  109:                 curr.height += 1
  110:         else:
  111:             setattr(curr, side, Node(val, curr))
  112:             self._size += 1
--------------------------------------------------------------------------------
[0.19452 s] [32mkilled[0m by 0-ts/test_bst2.py::test_depth_method

test_bsts = (<bst2.Bst object at 0x7ff2282db370>, <bst2.Bst object at 0x7ff2282d8a60>, <bst2.Bst object at 0x7ff2282d8a00>, <bst2.Bst object at 0x7ff2282db880>, <bst2.Bst object at 0x7ff2282d9db0>, <bst2.Bst object at 0x7ff2282da170>)

    def test_depth_method(test_bsts):
        """Test depth method."""
        depths = [0, 1, 2, 3, 4, 6]
>       assert all(tree.depth() == depths[idx]
                   for idx, tree in enumerate(test_bsts))
E       AssertionError

0-ts/test_bst2.py:85: AssertionError
[36m   -[0m [#  51] COI bst2: 
--------------------------------------------------------------------------------
  109:                 curr.height += 1
  110:         else:
  111:             setattr(curr, side, Node(val, curr))
  112:             self._size += 1
[34m- 113:             if curr.height == 1:[0m
[32m+ 113:             if not (curr.height == 1):[0m
  114:                 curr.height += 1
  115:         return curr
  116:     
  117:     def search(self, val):
--------------------------------------------------------------------------------
[0.24954 s] [32mkilled[0m by 0-ts/test_bst2.py::test_depth_method

test_bsts = (<bst2.Bst object at 0x7ff2281dbf40>, <bst2.Bst object at 0x7ff2281dab30>, <bst2.Bst object at 0x7ff2281d80d0>, <bst2.Bst object at 0x7ff2281d9120>, <bst2.Bst object at 0x7ff2282da080>, <bst2.Bst object at 0x7ff2282da3e0>)

    def test_depth_method(test_bsts):
        """Test depth method."""
        depths = [0, 1, 2, 3, 4, 6]
>       assert all(tree.depth() == depths[idx]
                   for idx, tree in enumerate(test_bsts))
E       AssertionError

0-ts/test_bst2.py:85: AssertionError
[36m   -[0m [#  52] COI bst2: 
--------------------------------------------------------------------------------
  116:     
  117:     def search(self, val):
  118:         '''Return the node containing val.'''
  119:         curr = self.root
[34m- 120:         while curr:[0m
[32m+ 120:         while not curr:[0m
  121:             if curr.val == val:
  122:                 return curr
  123:             elif val < curr.val:
  124:                 curr = curr.left
--------------------------------------------------------------------------------
[0.28246 s] [32mkilled[0m by 0-ts/test_bst2.py::test_contains_method

test_bsts = (<bst2.Bst object at 0x7ff227ee5ea0>, <bst2.Bst object at 0x7ff227ee6530>, <bst2.Bst object at 0x7ff227dafa60>, <bst2.Bst object at 0x7ff227dae320>, <bst2.Bst object at 0x7ff227daf7f0>, <bst2.Bst object at 0x7ff227dac5b0>)

    def test_contains_method(test_bsts):
        """Test contains on number that exists."""
>       assert test_bsts[2].contains(5)
E       AssertionError

0-ts/test_bst2.py:72: AssertionError
[36m   -[0m [#  53] COI bst2: 
--------------------------------------------------------------------------------
  117:     def search(self, val):
  118:         '''Return the node containing val.'''
  119:         curr = self.root
  120:         while curr:
[34m- 121:             if curr.val == val:[0m
[32m+ 121:             if not (curr.val == val):[0m
  122:                 return curr
  123:             elif val < curr.val:
  124:                 curr = curr.left
  125:             else:
--------------------------------------------------------------------------------
[0.21723 s] [32mkilled[0m by 0-ts/test_bst2.py::test_contains_method_no_val

test_bsts = (<bst2.Bst object at 0x7ff227ec8490>, <bst2.Bst object at 0x7ff227ec84c0>, <bst2.Bst object at 0x7ff227ec89d0>, <bst2.Bst object at 0x7ff227ec9210>, <bst2.Bst object at 0x7ff227ec95a0>, <bst2.Bst object at 0x7ff227ec9a50>)

    def test_contains_method_no_val(test_bsts):
        """Test contains that doesnt exist."""
>       assert not test_bsts[4].contains(10)
E       AssertionError

0-ts/test_bst2.py:79: AssertionError
[36m   -[0m [#  54] COI bst2: 
--------------------------------------------------------------------------------
  119:         curr = self.root
  120:         while curr:
  121:             if curr.val == val:
  122:                 return curr
[34m- 123:             elif val < curr.val:[0m
[32m+ 123:             elif not (val < curr.val):[0m
  124:                 curr = curr.left
  125:             else:
  126:                 curr = curr.right
  127:     
--------------------------------------------------------------------------------
[0.21597 s] [32mkilled[0m by 0-ts/test_bst2.py::test_contains_method

test_bsts = (<bst2.Bst object at 0x7ff227e933a0>, <bst2.Bst object at 0x7ff227e925c0>, <bst2.Bst object at 0x7ff227e91c60>, <bst2.Bst object at 0x7ff227e91e40>, <bst2.Bst object at 0x7ff227e91b40>, <bst2.Bst object at 0x7ff227e92e60>)

    def test_contains_method(test_bsts):
        """Test contains on number that exists."""
        assert test_bsts[2].contains(5)
>       assert test_bsts[2].contains(3)
E       AssertionError

0-ts/test_bst2.py:73: AssertionError
[36m   -[0m [#  55] COI bst2: 
--------------------------------------------------------------------------------
  144:         positive value, trees which are higher on the right than the left
  145:         should return a negative value. An ideally-balanced tree should
  146:         return 0.
  147:         '''
[34m- 148:         if not tree:[0m
[32m+ 148:         if not ((not tree)):[0m
  149:             tree = self.root
  150:             if not tree:
  151:                 return 0
  152:         
--------------------------------------------------------------------------------
[0.21942 s] [32mkilled[0m by 0-ts/test_bst2.py::test_balance_method

test_bsts = (<bst2.Bst object at 0x7ff227d09f00>, <bst2.Bst object at 0x7ff227d09900>, <bst2.Bst object at 0x7ff227d0a7d0>, <bst2.Bst object at 0x7ff227d0b7c0>, <bst2.Bst object at 0x7ff227d08f10>, <bst2.Bst object at 0x7ff227d08700>)

    def test_balance_method(test_bsts):
        """Test the balance method."""
        balance = [0, 0, 0, 0, 3, -5]
>       assert all(tree.balance() == balance[idx]
                   for idx, tree in enumerate(test_bsts))

0-ts/test_bst2.py:92: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
0-ts/test_bst2.py:92: in <genexpr>
    assert all(tree.balance() == balance[idx]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x7ff227d09f00>, tree = None

>   ???
E   AttributeError: 'NoneType' object has no attribute 'left'

bst2:153: AttributeError
[36m   -[0m [#  56] COI bst2: 
--------------------------------------------------------------------------------
  146:         return 0.
  147:         '''
  148:         if not tree:
  149:             tree = self.root
[34m- 150:             if not tree:[0m
[32m+ 150:             if not ((not tree)):[0m
  151:                 return 0
  152:         
  153:         leftbranch = 0 if not (tree.left) else tree.left.height
  154:         rightbranch = 0 if not (tree.right) else tree.right.height
--------------------------------------------------------------------------------
[0.21166 s] [32mkilled[0m by 0-ts/test_bst2.py::test_balance_method

test_bsts = (<bst2.Bst object at 0x7ff228208970>, <bst2.Bst object at 0x7ff228209180>, <bst2.Bst object at 0x7ff22820b130>, <bst2.Bst object at 0x7ff22820a4a0>, <bst2.Bst object at 0x7ff22820be50>, <bst2.Bst object at 0x7ff228209a50>)

    def test_balance_method(test_bsts):
        """Test the balance method."""
        balance = [0, 0, 0, 0, 3, -5]
>       assert all(tree.balance() == balance[idx]
                   for idx, tree in enumerate(test_bsts))

0-ts/test_bst2.py:92: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
0-ts/test_bst2.py:92: in <genexpr>
    assert all(tree.balance() == balance[idx]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x7ff228208970>, tree = None

>   ???
E   AttributeError: 'NoneType' object has no attribute 'left'

bst2:153: AttributeError
[36m   -[0m [#  57] COI bst2: 
--------------------------------------------------------------------------------
  156:         return leftbranch - rightbranch
  157:     
  158:     def pre_order(self, node='root'):
  159:         '''Depth first pre-order traversal of tree.'''
[34m- 160:         if node == 'root':[0m
[32m+ 160:         if not (node == 'root'):[0m
  161:             node = self.root
  162:         
  163:         if not node:
  164:             return
--------------------------------------------------------------------------------
[0.22705 s] [32mkilled[0m by 0-ts/test_bst2.py::test_pre_order

test_traversals = {'breadth': ['F', 'B', 'G', 'A', 'D', 'I', ...], 'empty': <bst2.Bst object at 0x7ff227be0490>, 'in_order': ['A', 'B', 'C', 'D', 'E', 'F', ...], 'post_order': ['A', 'C', 'E', 'D', 'B', 'H', ...], ...}

    def test_pre_order(test_traversals):
        """Test preorder for a traversal."""
>       path = [i for i in test_traversals['tree'].pre_order()]

0-ts/test_bst2.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
0-ts/test_bst2.py:103: in <listcomp>
    path = [i for i in test_traversals['tree'].pre_order()]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x7ff22825bbe0>, node = 'root'

>   ???
E   AttributeError: 'str' object has no attribute 'val'

bst2:166: AttributeError
[36m   -[0m [#  58] COI bst2: 
--------------------------------------------------------------------------------
  159:         '''Depth first pre-order traversal of tree.'''
  160:         if node == 'root':
  161:             node = self.root
  162:         
[34m- 163:         if not node:[0m
[32m+ 163:         if not ((not node)):[0m
  164:             return
  165:         
  166:         yield node.val
  167:         
--------------------------------------------------------------------------------
[0.34470 s] [32mkilled[0m by 0-ts/test_bst2.py::test_pre_order

test_traversals = {'breadth': ['F', 'B', 'G', 'A', 'D', 'I', ...], 'empty': <bst2.Bst object at 0x7ff227f31810>, 'in_order': ['A', 'B', 'C', 'D', 'E', 'F', ...], 'post_order': ['A', 'C', 'E', 'D', 'B', 'H', ...], ...}

    def test_pre_order(test_traversals):
        """Test preorder for a traversal."""
        path = [i for i in test_traversals['tree'].pre_order()]
>       assert path == test_traversals['pre_order']
E       AssertionError

0-ts/test_bst2.py:104: AssertionError
[36m   -[0m [#  59] COI bst2: 
--------------------------------------------------------------------------------
  171:             yield n
  172:     
  173:     def in_order(self, node='root'):
  174:         '''Depth first in-order traversal of tree.'''
[34m- 175:         if node == 'root':[0m
[32m+ 175:         if not (node == 'root'):[0m
  176:             node = self.root
  177:         
  178:         if not node:
  179:             return
--------------------------------------------------------------------------------
[0.23978 s] [32mkilled[0m by 0-ts/test_bst2.py::test_in_order

test_traversals = {'breadth': ['F', 'B', 'G', 'A', 'D', 'I', ...], 'empty': <bst2.Bst object at 0x7ff2280f42b0>, 'in_order': ['A', 'B', 'C', 'D', 'E', 'F', ...], 'post_order': ['A', 'C', 'E', 'D', 'B', 'H', ...], ...}

    def test_in_order(test_traversals):
        """Test inorder for a traversal."""
>       path = [i for i in test_traversals['tree'].in_order()]

0-ts/test_bst2.py:109: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
0-ts/test_bst2.py:109: in <listcomp>
    path = [i for i in test_traversals['tree'].in_order()]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x7ff2280f41f0>, node = 'root'

>   ???
E   AttributeError: 'str' object has no attribute 'left'

bst2:181: AttributeError
[36m   -[0m [#  60] COI bst2: 
--------------------------------------------------------------------------------
  174:         '''Depth first in-order traversal of tree.'''
  175:         if node == 'root':
  176:             node = self.root
  177:         
[34m- 178:         if not node:[0m
[32m+ 178:         if not ((not node)):[0m
  179:             return
  180:         
  181:         for n in self.in_order(node=node.left):
  182:             yield n
--------------------------------------------------------------------------------
[0.21222 s] [32mkilled[0m by 0-ts/test_bst2.py::test_in_order

test_traversals = {'breadth': ['F', 'B', 'G', 'A', 'D', 'I', ...], 'empty': <bst2.Bst object at 0x7ff22802e3e0>, 'in_order': ['A', 'B', 'C', 'D', 'E', 'F', ...], 'post_order': ['A', 'C', 'E', 'D', 'B', 'H', ...], ...}

    def test_in_order(test_traversals):
        """Test inorder for a traversal."""
        path = [i for i in test_traversals['tree'].in_order()]
>       assert path == test_traversals['in_order']
E       AssertionError

0-ts/test_bst2.py:110: AssertionError
[36m   -[0m [#  61] COI bst2: 
--------------------------------------------------------------------------------
  185:             yield n
  186:     
  187:     def post_order(self, node='root'):
  188:         '''Depth frist post_order traversal of tree.'''
[34m- 189:         if node == 'root':[0m
[32m+ 189:         if not (node == 'root'):[0m
  190:             node = self.root
  191:         
  192:         if not node:
  193:             return
--------------------------------------------------------------------------------
[0.20880 s] [32mkilled[0m by 0-ts/test_bst2.py::test_post_order

test_traversals = {'breadth': ['F', 'B', 'G', 'A', 'D', 'I', ...], 'empty': <bst2.Bst object at 0x7ff228169d80>, 'in_order': ['A', 'B', 'C', 'D', 'E', 'F', ...], 'post_order': ['A', 'C', 'E', 'D', 'B', 'H', ...], ...}

    def test_post_order(test_traversals):
        """Test postorder for a traversal."""
>       path = [i for i in test_traversals['tree'].post_order()]

0-ts/test_bst2.py:115: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
0-ts/test_bst2.py:115: in <listcomp>
    path = [i for i in test_traversals['tree'].post_order()]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x7ff227ebf700>, node = 'root'

>   ???
E   AttributeError: 'str' object has no attribute 'left'

bst2:195: AttributeError
[36m   -[0m [#  62] COI bst2: 
--------------------------------------------------------------------------------
  188:         '''Depth frist post_order traversal of tree.'''
  189:         if node == 'root':
  190:             node = self.root
  191:         
[34m- 192:         if not node:[0m
[32m+ 192:         if not ((not node)):[0m
  193:             return
  194:         
  195:         for n in self.post_order(node=node.left):
  196:             yield n
--------------------------------------------------------------------------------
[0.21685 s] [32mkilled[0m by 0-ts/test_bst2.py::test_post_order

test_traversals = {'breadth': ['F', 'B', 'G', 'A', 'D', 'I', ...], 'empty': <bst2.Bst object at 0x7ff227cb3f10>, 'in_order': ['A', 'B', 'C', 'D', 'E', 'F', ...], 'post_order': ['A', 'C', 'E', 'D', 'B', 'H', ...], ...}

    def test_post_order(test_traversals):
        """Test postorder for a traversal."""
        path = [i for i in test_traversals['tree'].post_order()]
>       assert path == test_traversals['post_order']
E       AssertionError

0-ts/test_bst2.py:116: AssertionError
[36m   -[0m [#  63] COI bst2: 
--------------------------------------------------------------------------------
  201:     def breadth_first(self):
  202:         '''Breadth first traversal of tree.'''
  203:         q = Queue()
  204:         q.enqueue(self.root)
[34m- 205:         while q.peek():[0m
[32m+ 205:         while not (q.peek()):[0m
  206:             node = q.dequeue()
  207:             yield node.val
  208:             if node.left:
  209:                 q.enqueue(node.left)
--------------------------------------------------------------------------------
[0.34701 s] [32mkilled[0m by 0-ts/test_bst2.py::test_breadth_first

test_traversals = {'breadth': ['F', 'B', 'G', 'A', 'D', 'I', ...], 'empty': <bst2.Bst object at 0x7ff227b03cd0>, 'in_order': ['A', 'B', 'C', 'D', 'E', 'F', ...], 'post_order': ['A', 'C', 'E', 'D', 'B', 'H', ...], ...}

    def test_breadth_first(test_traversals):
        """Test breadth first for a traversal."""
        path = [i for i in test_traversals['tree'].breadth_first()]
>       assert path == test_traversals['breadth']
E       AssertionError

0-ts/test_bst2.py:122: AssertionError
[36m   -[0m [#  64] COI bst2: 
--------------------------------------------------------------------------------
  204:         q.enqueue(self.root)
  205:         while q.peek():
  206:             node = q.dequeue()
  207:             yield node.val
[34m- 208:             if node.left:[0m
[32m+ 208:             if not (node.left):[0m
  209:                 q.enqueue(node.left)
  210:             if node.right:
  211:                 q.enqueue(node.right)
  212:     
--------------------------------------------------------------------------------
[0.22662 s] [32mkilled[0m by 0-ts/test_bst2.py::test_breadth_first

test_traversals = {'breadth': ['F', 'B', 'G', 'A', 'D', 'I', ...], 'empty': <bst2.Bst object at 0x7ff227d74520>, 'in_order': ['A', 'B', 'C', 'D', 'E', 'F', ...], 'post_order': ['A', 'C', 'E', 'D', 'B', 'H', ...], ...}

    def test_breadth_first(test_traversals):
        """Test breadth first for a traversal."""
        path = [i for i in test_traversals['tree'].breadth_first()]
>       assert path == test_traversals['breadth']
E       AssertionError

0-ts/test_bst2.py:122: AssertionError
[36m   -[0m [#  65] COI bst2: 
--------------------------------------------------------------------------------
  206:             node = q.dequeue()
  207:             yield node.val
  208:             if node.left:
  209:                 q.enqueue(node.left)
[34m- 210:             if node.right:[0m
[32m+ 210:             if not (node.right):[0m
  211:                 q.enqueue(node.right)
  212:     
  213:     def delete(self, val):
  214:         '''Remove a node from the tree.'''
--------------------------------------------------------------------------------
[0.22034 s] [32mkilled[0m by 0-ts/test_bst2.py::test_breadth_first

test_traversals = {'breadth': ['F', 'B', 'G', 'A', 'D', 'I', ...], 'empty': <bst2.Bst object at 0x7ff22820bd90>, 'in_order': ['A', 'B', 'C', 'D', 'E', 'F', ...], 'post_order': ['A', 'C', 'E', 'D', 'B', 'H', ...], ...}

    def test_breadth_first(test_traversals):
        """Test breadth first for a traversal."""
        path = [i for i in test_traversals['tree'].breadth_first()]
>       assert path == test_traversals['breadth']
E       AssertionError

0-ts/test_bst2.py:122: AssertionError
[36m   -[0m [#  66] COI bst2: 
--------------------------------------------------------------------------------
  211:                 q.enqueue(node.right)
  212:     
  213:     def delete(self, val):
  214:         '''Remove a node from the tree.'''
[34m- 215:         if (self._size < 1 or not (self.contains(val))):[0m
[32m+ 215:         if not ((self._size < 1 or not (self.contains(val)))):[0m
  216:             return
  217:         
  218:         node = self.search(val)
  219:         
--------------------------------------------------------------------------------
[0.20778 s] [32mkilled[0m by 0-ts/test_bst2.py::test_del_false

test_bsts = (<bst2.Bst object at 0x7ff227d33fa0>, <bst2.Bst object at 0x7ff227d332b0>, <bst2.Bst object at 0x7ff227d330d0>, <bst2.Bst object at 0x7ff227d33160>, <bst2.Bst object at 0x7ff227d32f20>, <bst2.Bst object at 0x7ff227d32a40>)

    def test_del_false(test_bsts):
        """Test delete for a node not in tree."""
        size = test_bsts[2].size()
>       test_bsts[2].delete(1)

0-ts/test_bst2.py:134: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x7ff227d330d0>, val = 1

>   ???
E   AttributeError: 'NoneType' object has no attribute '_is_leaf'

bst2:220: AttributeError
[36m   -[0m [#  67] COI bst2: 
--------------------------------------------------------------------------------
  216:             return
  217:         
  218:         node = self.search(val)
  219:         
[34m- 220:         if node._is_leaf():[0m
[32m+ 220:         if not (node._is_leaf()):[0m
  221:             if node.parent:
  222:                 setattr(node.parent, node._side(), None)
  223:             else:
  224:                 self.root = None
--------------------------------------------------------------------------------
[0.29389 s] [36mincompetent[0m

TypeError: bst2:233: TypeError: getattr(): attribute name must be string

[36m   -[0m [#  68] COI bst2: 
--------------------------------------------------------------------------------
  217:         
  218:         node = self.search(val)
  219:         
  220:         if node._is_leaf():
[34m- 221:             if node.parent:[0m
[32m+ 221:             if not (node.parent):[0m
  222:                 setattr(node.parent, node._side(), None)
  223:             else:
  224:                 self.root = None
  225:         
--------------------------------------------------------------------------------
[0.26947 s] [36mincompetent[0m

TypeError: bst2:222: TypeError: attribute name must be string, not 'NoneType'

[36m   -[0m [#  69] COI bst2: 
--------------------------------------------------------------------------------
  222:                 setattr(node.parent, node._side(), None)
  223:             else:
  224:                 self.root = None
  225:         
[34m- 226:         elif node._is_interior():[0m
[32m+ 226:         elif not (node._is_interior()):[0m
  227:             next_node = self._find_replacement(node)
  228:             self._size += 1
  229:             self.delete(next_node.val)
  230:             node.val = next_node.val
--------------------------------------------------------------------------------
[0.21521 s] [32mkilled[0m by 0-ts/test_bst2.py::test_remove_one_child_left

test_bsts = (<bst2.Bst object at 0x7ff22827bf70>, <bst2.Bst object at 0x7ff22827a170>, <bst2.Bst object at 0x7ff22827b040>, <bst2.Bst object at 0x7ff227f27c70>, <bst2.Bst object at 0x7ff227f27970>, <bst2.Bst object at 0x7ff227f25540>)

    def test_remove_one_child_left(test_bsts):
        """Test delete node one child, left."""
>       test_bsts[4].delete(3)

0-ts/test_bst2.py:167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
bst2:227: in delete
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x7ff227f27970>
node = <bst2.Node object at 0x7ff227f27d60>

>   ???
E   AttributeError: 'Bst' object has no attribute 'parent'

bst2:249: AttributeError
[36m   -[0m [#  70] COI bst2: 
--------------------------------------------------------------------------------
  230:             node.val = next_node.val
  231:         else:
  232:             
  233:             child = getattr(node, node._onlychild())
[34m- 234:             if node.parent:[0m
[32m+ 234:             if not (node.parent):[0m
  235:                 child.parent = node.parent
  236:                 setattr(node.parent, node._side(), child)
  237:             else:
  238:                 self.root = child
--------------------------------------------------------------------------------
[0.25324 s] [36mincompetent[0m

TypeError: bst2:236: TypeError: attribute name must be string, not 'NoneType'

[36m   -[0m [#  71] COI bst2: 
--------------------------------------------------------------------------------
  240:         self._size -= 1
  241:     
  242:     def _find_replacement(self, node):
  243:         '''Find left most node of right subtree.'''
[34m- 244:         if node.right:[0m
[32m+ 244:         if not (node.right):[0m
  245:             return self._findmin(node.right)
  246:         
  247:         elif node.parent:
  248:             if node._side() == 'left':
--------------------------------------------------------------------------------
[0.26314 s] [32mkilled[0m by 0-ts/test_bst2.py::test_delete_two_children

test_bsts = (<bst2.Bst object at 0x7ff227c82b30>, <bst2.Bst object at 0x7ff227c81690>, <bst2.Bst object at 0x7ff227c82e30>, <bst2.Bst object at 0x7ff227c81db0>, <bst2.Bst object at 0x7ff227c82fb0>, <bst2.Bst object at 0x7ff227c83460>)

    def test_delete_two_children(test_bsts):
        """Test delete node with two children."""
>       test_bsts[3].delete(3)

0-ts/test_bst2.py:208: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
bst2:227: in delete
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x7ff227c81db0>
node = <bst2.Node object at 0x7ff227c83040>

>   ???
E   AttributeError: 'Bst' object has no attribute 'parent'

bst2:249: AttributeError
[36m   -[0m [#  72] COI bst2: 
--------------------------------------------------------------------------------
  243:         '''Find left most node of right subtree.'''
  244:         if node.right:
  245:             return self._findmin(node.right)
  246:         
[34m- 247:         elif node.parent:[0m
[32m+ 247:         elif not (node.parent):[0m
  248:             if node._side() == 'left':
  249:                 return self.parent
  250:             else:
  251:                 node.parent.right = None
--------------------------------------------------------------------------------
[0.16867 s] [31msurvived[0m
[36m   -[0m [#  73] COI bst2: 
--------------------------------------------------------------------------------
  244:         if node.right:
  245:             return self._findmin(node.right)
  246:         
  247:         elif node.parent:
[34m- 248:             if node._side() == 'left':[0m
[32m+ 248:             if not (node._side() == 'left'):[0m
  249:                 return self.parent
  250:             else:
  251:                 node.parent.right = None
  252:                 tmp = self._find_replacement(node.parent)
--------------------------------------------------------------------------------
[0.18769 s] [31msurvived[0m
[36m   -[0m [#  74] COI bst2: 
--------------------------------------------------------------------------------
  254:                 return tmp
  255:     
  256:     def _findmin(self, node):
  257:         '''Find min of subtree, Min is always left most node.'''
[34m- 258:         while node.left:[0m
[32m+ 258:         while not (node.left):[0m
  259:             node = node.left
  260:         return node
--------------------------------------------------------------------------------
[0.22182 s] [32mkilled[0m by 0-ts/test_bst2.py::test_delete_two_children

test_bsts = (<bst2.Bst object at 0x7ff227c27460>, <bst2.Bst object at 0x7ff22826c7c0>, <bst2.Bst object at 0x7ff22826e830>, <bst2.Bst object at 0x7ff22826d150>, <bst2.Bst object at 0x7ff22826c100>, <bst2.Bst object at 0x7ff22826ed10>)

    def test_delete_two_children(test_bsts):
        """Test delete node with two children."""
>       test_bsts[3].delete(3)

0-ts/test_bst2.py:208: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
bst2:227: in delete
    ???
bst2:245: in _find_replacement
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x7ff22826d150>, node = None

>   ???
E   AttributeError: 'NoneType' object has no attribute 'left'

bst2:258: AttributeError
[36m   -[0m [#  75] CRP bst2: 
--------------------------------------------------------------------------------
   11:         self.val = val
   12:         self.right = None
   13:         self.left = None
   14:         self.parent = parent
[34m-  15:         self.height = 1[0m
[32m+  15:         self.height = 2[0m
   16:     
   17:     def _is_leaf(self):
   18:         '''Return true if a leaf.'''
   19:         return not ((self.right or self.left))
--------------------------------------------------------------------------------
[0.21201 s] [32mkilled[0m by 0-ts/test_bst2.py::test_depth_method

test_bsts = (<bst2.Bst object at 0x7ff2280c8820>, <bst2.Bst object at 0x7ff2280c8a00>, <bst2.Bst object at 0x7ff2280c8d90>, <bst2.Bst object at 0x7ff2280c92a0>, <bst2.Bst object at 0x7ff2280c9630>, <bst2.Bst object at 0x7ff2280c9ae0>)

    def test_depth_method(test_bsts):
        """Test depth method."""
        depths = [0, 1, 2, 3, 4, 6]
>       assert all(tree.depth() == depths[idx]
                   for idx, tree in enumerate(test_bsts))
E       AssertionError

0-ts/test_bst2.py:85: AssertionError
[36m   -[0m [#  76] CRP bst2: 
--------------------------------------------------------------------------------
   24:     
   25:     def _onlychild(self):
   26:         '''Return string depending on children.'''
   27:         if (self.left and not (self.right)):
[34m-  28:             return 'left'[0m
[32m+  28:             return 'mutpy'[0m
   29:         if (self.right and not (self.left)):
   30:             return 'right'
   31:     
   32:     def _side(self):
--------------------------------------------------------------------------------
[0.30869 s] [32mkilled[0m by 0-ts/test_bst2.py::test_remove_one_child_left

test_bsts = (<bst2.Bst object at 0x7ff227ef6020>, <bst2.Bst object at 0x7ff227ef59c0>, <bst2.Bst object at 0x7ff227f869b0>, <bst2.Bst object at 0x7ff227f86200>, <bst2.Bst object at 0x7ff227f86980>, <bst2.Bst object at 0x7ff227f871c0>)

    def test_remove_one_child_left(test_bsts):
        """Test delete node one child, left."""
>       test_bsts[4].delete(3)

0-ts/test_bst2.py:167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x7ff227f86980>, val = 3

>   ???
E   AttributeError: 'Node' object has no attribute 'mutpy'

bst2:233: AttributeError
[36m   -[0m [#  77] CRP bst2: 
--------------------------------------------------------------------------------
   24:     
   25:     def _onlychild(self):
   26:         '''Return string depending on children.'''
   27:         if (self.left and not (self.right)):
[34m-  28:             return 'left'[0m
[32m+  28:             return ''[0m
   29:         if (self.right and not (self.left)):
   30:             return 'right'
   31:     
   32:     def _side(self):
--------------------------------------------------------------------------------
[0.21588 s] [32mkilled[0m by 0-ts/test_bst2.py::test_remove_one_child_left

test_bsts = (<bst2.Bst object at 0x7ff22802d390>, <bst2.Bst object at 0x7ff22802dea0>, <bst2.Bst object at 0x7ff22802f3d0>, <bst2.Bst object at 0x7ff22802e980>, <bst2.Bst object at 0x7ff22802e740>, <bst2.Bst object at 0x7ff22815d630>)

    def test_remove_one_child_left(test_bsts):
        """Test delete node one child, left."""
>       test_bsts[4].delete(3)

0-ts/test_bst2.py:167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x7ff22802e740>, val = 3

>   ???
E   AttributeError: 'Node' object has no attribute ''

bst2:233: AttributeError
[36m   -[0m [#  78] CRP bst2: 
--------------------------------------------------------------------------------
   26:         '''Return string depending on children.'''
   27:         if (self.left and not (self.right)):
   28:             return 'left'
   29:         if (self.right and not (self.left)):
[34m-  30:             return 'right'[0m
[32m+  30:             return 'mutpy'[0m
   31:     
   32:     def _side(self):
   33:         '''Return if left or right child of parent.'''
   34:         if self.parent:
--------------------------------------------------------------------------------
[0.23022 s] [32mkilled[0m by 0-ts/test_bst2.py::test_remove_one_child_right

test_bsts = (<bst2.Bst object at 0x7ff227c4b880>, <bst2.Bst object at 0x7ff227c48040>, <bst2.Bst object at 0x7ff227c4b1f0>, <bst2.Bst object at 0x7ff227c4a260>, <bst2.Bst object at 0x7ff227ecbeb0>, <bst2.Bst object at 0x7ff227ecb760>)

    def test_remove_one_child_right(test_bsts):
        """Test delete node one child, right."""
>       test_bsts[5].delete(6)

0-ts/test_bst2.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x7ff227ecb760>, val = 6

>   ???
E   AttributeError: 'Node' object has no attribute 'mutpy'

bst2:233: AttributeError
[36m   -[0m [#  79] CRP bst2: 
--------------------------------------------------------------------------------
   26:         '''Return string depending on children.'''
   27:         if (self.left and not (self.right)):
   28:             return 'left'
   29:         if (self.right and not (self.left)):
[34m-  30:             return 'right'[0m
[32m+  30:             return ''[0m
   31:     
   32:     def _side(self):
   33:         '''Return if left or right child of parent.'''
   34:         if self.parent:
--------------------------------------------------------------------------------
[0.22246 s] [32mkilled[0m by 0-ts/test_bst2.py::test_remove_one_child_right

test_bsts = (<bst2.Bst object at 0x7ff227d2c760>, <bst2.Bst object at 0x7ff227d2ce50>, <bst2.Bst object at 0x7ff227cf1180>, <bst2.Bst object at 0x7ff227cf2590>, <bst2.Bst object at 0x7ff227cf0940>, <bst2.Bst object at 0x7ff227cf1d50>)

    def test_remove_one_child_right(test_bsts):
        """Test delete node one child, right."""
>       test_bsts[5].delete(6)

0-ts/test_bst2.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x7ff227cf1d50>, val = 6

>   ???
E   AttributeError: 'Node' object has no attribute ''

bst2:233: AttributeError
[36m   -[0m [#  80] CRP bst2: 
--------------------------------------------------------------------------------
   31:     
   32:     def _side(self):
   33:         '''Return if left or right child of parent.'''
   34:         if self.parent:
[34m-  35:             return 'left' if self.parent.left == self else 'right'[0m
[32m+  35:             return 'mutpy' if self.parent.left == self else 'right'[0m
   36: 
   37: 
   38: class Bst(object):
   39:     '''Binary Search Tree.
--------------------------------------------------------------------------------
[0.28342 s] [32mkilled[0m by 0-ts/test_bst2.py::test_remove_leaf_left

test_bsts = (<bst2.Bst object at 0x7ff2280e6da0>, <bst2.Bst object at 0x7ff2280e68f0>, <bst2.Bst object at 0x7ff2280e63b0>, <bst2.Bst object at 0x7ff2280e72b0>, <bst2.Bst object at 0x7ff2280e62f0>, <bst2.Bst object at 0x7ff2280e5e10>)

    def test_remove_leaf_left(test_bsts):
        """Test delete leaf on left."""
        test_bsts[2].delete(3)
>       assert not test_bsts[2].contains(3)
E       AssertionError

0-ts/test_bst2.py:147: AssertionError
[36m   -[0m [#  81] CRP bst2: 
--------------------------------------------------------------------------------
   31:     
   32:     def _side(self):
   33:         '''Return if left or right child of parent.'''
   34:         if self.parent:
[34m-  35:             return 'left' if self.parent.left == self else 'right'[0m
[32m+  35:             return '' if self.parent.left == self else 'right'[0m
   36: 
   37: 
   38: class Bst(object):
   39:     '''Binary Search Tree.
--------------------------------------------------------------------------------
[0.27274 s] [32mkilled[0m by 0-ts/test_bst2.py::test_remove_leaf_left

test_bsts = (<bst2.Bst object at 0x7ff227dac850>, <bst2.Bst object at 0x7ff227dad870>, <bst2.Bst object at 0x7ff227dac9d0>, <bst2.Bst object at 0x7ff227daf7f0>, <bst2.Bst object at 0x7ff227dad3c0>, <bst2.Bst object at 0x7ff227daddb0>)

    def test_remove_leaf_left(test_bsts):
        """Test delete leaf on left."""
        test_bsts[2].delete(3)
>       assert not test_bsts[2].contains(3)
E       AssertionError

0-ts/test_bst2.py:147: AssertionError
[36m   -[0m [#  82] CRP bst2: 
--------------------------------------------------------------------------------
   31:     
   32:     def _side(self):
   33:         '''Return if left or right child of parent.'''
   34:         if self.parent:
[34m-  35:             return 'left' if self.parent.left == self else 'right'[0m
[32m+  35:             return 'left' if self.parent.left == self else 'mutpy'[0m
   36: 
   37: 
   38: class Bst(object):
   39:     '''Binary Search Tree.
--------------------------------------------------------------------------------
[0.25749 s] [32mkilled[0m by 0-ts/test_bst2.py::test_remove_leaf_right

test_bsts = (<bst2.Bst object at 0x7ff227d76e90>, <bst2.Bst object at 0x7ff227d779a0>, <bst2.Bst object at 0x7ff227d76fb0>, <bst2.Bst object at 0x7ff227d74160>, <bst2.Bst object at 0x7ff227d764a0>, <bst2.Bst object at 0x7ff227d76860>)

    def test_remove_leaf_right(test_bsts):
        """Test delete leaf on right."""
        test_bsts[2].delete(7)
>       assert not test_bsts[2].contains(7)
E       AssertionError

0-ts/test_bst2.py:154: AssertionError
[36m   -[0m [#  83] CRP bst2: 
--------------------------------------------------------------------------------
   31:     
   32:     def _side(self):
   33:         '''Return if left or right child of parent.'''
   34:         if self.parent:
[34m-  35:             return 'left' if self.parent.left == self else 'right'[0m
[32m+  35:             return 'left' if self.parent.left == self else ''[0m
   36: 
   37: 
   38: class Bst(object):
   39:     '''Binary Search Tree.
--------------------------------------------------------------------------------
[0.23634 s] [32mkilled[0m by 0-ts/test_bst2.py::test_remove_leaf_right

test_bsts = (<bst2.Bst object at 0x7ff2280cdd50>, <bst2.Bst object at 0x7ff2280ceec0>, <bst2.Bst object at 0x7ff2280cfe50>, <bst2.Bst object at 0x7ff2280ce4d0>, <bst2.Bst object at 0x7ff2280cf640>, <bst2.Bst object at 0x7ff2280cf7c0>)

    def test_remove_leaf_right(test_bsts):
        """Test delete leaf on right."""
        test_bsts[2].delete(7)
>       assert not test_bsts[2].contains(7)
E       AssertionError

0-ts/test_bst2.py:154: AssertionError
[36m   -[0m [#  84] CRP bst2: 
--------------------------------------------------------------------------------
   76:     '''
   77:     
   78:     def __init__(self, data=None):
   79:         '''Initialize tree.'''
[34m-  80:         self._size = 0[0m
[32m+  80:         self._size = 1[0m
   81:         self.root = None
   82:         
   83:         if data:
   84:             for i in data:
--------------------------------------------------------------------------------
[0.22793 s] [32mkilled[0m by 0-ts/test_bst2.py::test_insert_increases_size

test_bsts = (<bst2.Bst object at 0x7ff227d9e8f0>, <bst2.Bst object at 0x7ff227d9edd0>, <bst2.Bst object at 0x7ff227d9dd20>, <bst2.Bst object at 0x7ff227e90370>, <bst2.Bst object at 0x7ff227e904f0>, <bst2.Bst object at 0x7ff227e909a0>)

    def test_insert_increases_size(test_bsts):
        """Test insert increases size."""
        test_bsts[0].insert(4)
>       assert test_bsts[0].size() == 1
E       AssertionError

0-ts/test_bst2.py:67: AssertionError
[36m   -[0m [#  85] CRP bst2: 
--------------------------------------------------------------------------------
   87:     def insert(self, val):
   88:         '''Insert val into BST. If val is already present will be ignored.'''
   89:         if not (self.root):
   90:             self.root = Node(val)
[34m-  91:             self._size += 1[0m
[32m+  91:             self._size += 2[0m
   92:         else:
   93:             self._step(val, self.root)
   94:     
   95:     def _step(self, val, curr):
--------------------------------------------------------------------------------
[0.35979 s] [32mkilled[0m by 0-ts/test_bst2.py::test_insert_increases_size

test_bsts = (<bst2.Bst object at 0x7ff228281780>, <bst2.Bst object at 0x7ff227c60160>, <bst2.Bst object at 0x7ff227c60790>, <bst2.Bst object at 0x7ff227c600a0>, <bst2.Bst object at 0x7ff227c60190>, <bst2.Bst object at 0x7ff227c60eb0>)

    def test_insert_increases_size(test_bsts):
        """Test insert increases size."""
        test_bsts[0].insert(4)
>       assert test_bsts[0].size() == 1
E       AssertionError

0-ts/test_bst2.py:67: AssertionError
[36m   -[0m [#  86] CRP bst2: 
--------------------------------------------------------------------------------
   94:     
   95:     def _step(self, val, curr):
   96:         '''Decide left or right and returns height.'''
   97:         if val < curr.val:
[34m-  98:             curr = self._set_child(curr, 'left', val)[0m
[32m+  98:             curr = self._set_child(curr, 'mutpy', val)[0m
   99:         elif val > curr.val:
  100:             curr = self._set_child(curr, 'right', val)
  101:         return curr.height
  102:     
--------------------------------------------------------------------------------
[0.21759 s] [32mkilled[0m by 0-ts/test_bst2.py::test_node_is_leaf

@pytest.fixture
    def test_bsts():
        """Fixture for bst."""
        from bst2 import Bst
        empty = Bst()
        one = Bst([5])
>       three = Bst([5, 3, 7])

0-ts/test_bst2.py:12: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
bst2:85: in __init__
    ???
bst2:93: in insert
    ???
bst2:98: in _step
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x7ff227d65960>
curr = <bst2.Node object at 0x7ff227d665f0>, side = 'mutpy', val = 3

>   ???
E   AttributeError: 'Node' object has no attribute 'mutpy'

bst2:105: AttributeError
[36m   -[0m [#  87] CRP bst2: 
--------------------------------------------------------------------------------
   94:     
   95:     def _step(self, val, curr):
   96:         '''Decide left or right and returns height.'''
   97:         if val < curr.val:
[34m-  98:             curr = self._set_child(curr, 'left', val)[0m
[32m+  98:             curr = self._set_child(curr, '', val)[0m
   99:         elif val > curr.val:
  100:             curr = self._set_child(curr, 'right', val)
  101:         return curr.height
  102:     
--------------------------------------------------------------------------------
[0.21459 s] [32mkilled[0m by 0-ts/test_bst2.py::test_node_is_leaf

@pytest.fixture
    def test_bsts():
        """Fixture for bst."""
        from bst2 import Bst
        empty = Bst()
        one = Bst([5])
>       three = Bst([5, 3, 7])

0-ts/test_bst2.py:12: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
bst2:85: in __init__
    ???
bst2:93: in insert
    ???
bst2:98: in _step
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x7ff22834bbb0>
curr = <bst2.Node object at 0x7ff22834a3b0>, side = '', val = 3

>   ???
E   AttributeError: 'Node' object has no attribute ''

bst2:105: AttributeError
[36m   -[0m [#  88] CRP bst2: 
--------------------------------------------------------------------------------
   96:         '''Decide left or right and returns height.'''
   97:         if val < curr.val:
   98:             curr = self._set_child(curr, 'left', val)
   99:         elif val > curr.val:
[34m- 100:             curr = self._set_child(curr, 'right', val)[0m
[32m+ 100:             curr = self._set_child(curr, 'mutpy', val)[0m
  101:         return curr.height
  102:     
  103:     def _set_child(self, curr, side, val):
  104:         '''Helping.'''
--------------------------------------------------------------------------------
[0.24379 s] [32mkilled[0m by 0-ts/test_bst2.py::test_node_is_leaf

@pytest.fixture
    def test_bsts():
        """Fixture for bst."""
        from bst2 import Bst
        empty = Bst()
        one = Bst([5])
>       three = Bst([5, 3, 7])

0-ts/test_bst2.py:12: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
bst2:85: in __init__
    ???
bst2:93: in insert
    ???
bst2:100: in _step
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x7ff2282d9450>
curr = <bst2.Node object at 0x7ff2282d8730>, side = 'mutpy', val = 7

>   ???
E   AttributeError: 'Node' object has no attribute 'mutpy'

bst2:105: AttributeError
[36m   -[0m [#  89] CRP bst2: 
--------------------------------------------------------------------------------
   96:         '''Decide left or right and returns height.'''
   97:         if val < curr.val:
   98:             curr = self._set_child(curr, 'left', val)
   99:         elif val > curr.val:
[34m- 100:             curr = self._set_child(curr, 'right', val)[0m
[32m+ 100:             curr = self._set_child(curr, '', val)[0m
  101:         return curr.height
  102:     
  103:     def _set_child(self, curr, side, val):
  104:         '''Helping.'''
--------------------------------------------------------------------------------
[0.23340 s] [32mkilled[0m by 0-ts/test_bst2.py::test_node_is_leaf

@pytest.fixture
    def test_bsts():
        """Fixture for bst."""
        from bst2 import Bst
        empty = Bst()
        one = Bst([5])
>       three = Bst([5, 3, 7])

0-ts/test_bst2.py:12: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
bst2:85: in __init__
    ???
bst2:93: in insert
    ???
bst2:100: in _step
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x7ff227d6cdf0>
curr = <bst2.Node object at 0x7ff227d6e050>, side = '', val = 7

>   ???
E   AttributeError: 'Node' object has no attribute ''

bst2:105: AttributeError
[36m   -[0m [#  90] CRP bst2: 
--------------------------------------------------------------------------------
  105:         child = getattr(curr, side)
  106:         if child:
  107:             count = self._step(val, child)
  108:             if curr.height <= count:
[34m- 109:                 curr.height += 1[0m
[32m+ 109:                 curr.height += 2[0m
  110:         else:
  111:             setattr(curr, side, Node(val, curr))
  112:             self._size += 1
  113:             if curr.height == 1:
--------------------------------------------------------------------------------
[0.32505 s] [32mkilled[0m by 0-ts/test_bst2.py::test_depth_method

test_bsts = (<bst2.Bst object at 0x7ff227f69a20>, <bst2.Bst object at 0x7ff227f69090>, <bst2.Bst object at 0x7ff227f6abc0>, <bst2.Bst object at 0x7ff227f6b340>, <bst2.Bst object at 0x7ff227f692d0>, <bst2.Bst object at 0x7ff227f68520>)

    def test_depth_method(test_bsts):
        """Test depth method."""
        depths = [0, 1, 2, 3, 4, 6]
>       assert all(tree.depth() == depths[idx]
                   for idx, tree in enumerate(test_bsts))
E       AssertionError

0-ts/test_bst2.py:85: AssertionError
[36m   -[0m [#  91] CRP bst2: 
--------------------------------------------------------------------------------
  108:             if curr.height <= count:
  109:                 curr.height += 1
  110:         else:
  111:             setattr(curr, side, Node(val, curr))
[34m- 112:             self._size += 1[0m
[32m+ 112:             self._size += 2[0m
  113:             if curr.height == 1:
  114:                 curr.height += 1
  115:         return curr
  116:     
--------------------------------------------------------------------------------
[0.23373 s] [32mkilled[0m by 0-ts/test_bst2.py::test_remove_leaf_left

test_bsts = (<bst2.Bst object at 0x7ff22815c640>, <bst2.Bst object at 0x7ff22815dc60>, <bst2.Bst object at 0x7ff22815d1b0>, <bst2.Bst object at 0x7ff22815e8f0>, <bst2.Bst object at 0x7ff22815c8b0>, <bst2.Bst object at 0x7ff22815e380>)

    def test_remove_leaf_left(test_bsts):
        """Test delete leaf on left."""
        test_bsts[2].delete(3)
        assert not test_bsts[2].contains(3)
>       assert test_bsts[2].size() is 2
E       AssertionError

0-ts/test_bst2.py:148: AssertionError
[36m   -[0m [#  92] CRP bst2: 
--------------------------------------------------------------------------------
  109:                 curr.height += 1
  110:         else:
  111:             setattr(curr, side, Node(val, curr))
  112:             self._size += 1
[34m- 113:             if curr.height == 1:[0m
[32m+ 113:             if curr.height == 2:[0m
  114:                 curr.height += 1
  115:         return curr
  116:     
  117:     def search(self, val):
--------------------------------------------------------------------------------
[0.20236 s] [32mkilled[0m by 0-ts/test_bst2.py::test_depth_method

test_bsts = (<bst2.Bst object at 0x7ff22820a140>, <bst2.Bst object at 0x7ff22820b670>, <bst2.Bst object at 0x7ff228278940>, <bst2.Bst object at 0x7ff228278e20>, <bst2.Bst object at 0x7ff2282794e0>, <bst2.Bst object at 0x7ff228279780>)

    def test_depth_method(test_bsts):
        """Test depth method."""
        depths = [0, 1, 2, 3, 4, 6]
>       assert all(tree.depth() == depths[idx]
                   for idx, tree in enumerate(test_bsts))
E       AssertionError

0-ts/test_bst2.py:85: AssertionError
[36m   -[0m [#  93] CRP bst2: 
--------------------------------------------------------------------------------
  110:         else:
  111:             setattr(curr, side, Node(val, curr))
  112:             self._size += 1
  113:             if curr.height == 1:
[34m- 114:                 curr.height += 1[0m
[32m+ 114:                 curr.height += 2[0m
  115:         return curr
  116:     
  117:     def search(self, val):
  118:         '''Return the node containing val.'''
--------------------------------------------------------------------------------
[0.22303 s] [32mkilled[0m by 0-ts/test_bst2.py::test_depth_method

test_bsts = (<bst2.Bst object at 0x7ff227f822c0>, <bst2.Bst object at 0x7ff227f805e0>, <bst2.Bst object at 0x7ff227e4c340>, <bst2.Bst object at 0x7ff227e4c850>, <bst2.Bst object at 0x7ff227e4cbe0>, <bst2.Bst object at 0x7ff227e4d090>)

    def test_depth_method(test_bsts):
        """Test depth method."""
        depths = [0, 1, 2, 3, 4, 6]
>       assert all(tree.depth() == depths[idx]
                   for idx, tree in enumerate(test_bsts))
E       AssertionError

0-ts/test_bst2.py:85: AssertionError
[36m   -[0m [#  94] CRP bst2: 
--------------------------------------------------------------------------------
  130:         return self._size
  131:     
  132:     def depth(self):
  133:         '''Return depth of the BST, representing total levels.'''
[34m- 134:         return 0 if not (self.root) else self.root.height[0m
[32m+ 134:         return 1 if not (self.root) else self.root.height[0m
  135:     
  136:     def contains(self, val):
  137:         '''Return true if val is in the bst.'''
  138:         return self.search(val) is not None
--------------------------------------------------------------------------------
[0.35374 s] [32mkilled[0m by 0-ts/test_bst2.py::test_depth_method

test_bsts = (<bst2.Bst object at 0x7ff227c32680>, <bst2.Bst object at 0x7ff227c32b30>, <bst2.Bst object at 0x7ff227c315a0>, <bst2.Bst object at 0x7ff227c30f40>, <bst2.Bst object at 0x7ff227c32ef0>, <bst2.Bst object at 0x7ff227c333a0>)

    def test_depth_method(test_bsts):
        """Test depth method."""
        depths = [0, 1, 2, 3, 4, 6]
>       assert all(tree.depth() == depths[idx]
                   for idx, tree in enumerate(test_bsts))
E       AssertionError

0-ts/test_bst2.py:85: AssertionError
[36m   -[0m [#  95] CRP bst2: 
--------------------------------------------------------------------------------
  147:         '''
  148:         if not tree:
  149:             tree = self.root
  150:             if not tree:
[34m- 151:                 return 0[0m
[32m+ 151:                 return 1[0m
  152:         
  153:         leftbranch = 0 if not (tree.left) else tree.left.height
  154:         rightbranch = 0 if not (tree.right) else tree.right.height
  155:         
--------------------------------------------------------------------------------
[0.20896 s] [32mkilled[0m by 0-ts/test_bst2.py::test_balance_method

test_bsts = (<bst2.Bst object at 0x7ff227d75a20>, <bst2.Bst object at 0x7ff227d74ee0>, <bst2.Bst object at 0x7ff227d74bb0>, <bst2.Bst object at 0x7ff227d74f70>, <bst2.Bst object at 0x7ff227d77040>, <bst2.Bst object at 0x7ff227d75c00>)

    def test_balance_method(test_bsts):
        """Test the balance method."""
        balance = [0, 0, 0, 0, 3, -5]
>       assert all(tree.balance() == balance[idx]
                   for idx, tree in enumerate(test_bsts))
E       AssertionError

0-ts/test_bst2.py:92: AssertionError
[36m   -[0m [#  96] CRP bst2: 
--------------------------------------------------------------------------------
  149:             tree = self.root
  150:             if not tree:
  151:                 return 0
  152:         
[34m- 153:         leftbranch = 0 if not (tree.left) else tree.left.height[0m
[32m+ 153:         leftbranch = 1 if not (tree.left) else tree.left.height[0m
  154:         rightbranch = 0 if not (tree.right) else tree.right.height
  155:         
  156:         return leftbranch - rightbranch
  157:     
--------------------------------------------------------------------------------
[0.23031 s] [32mkilled[0m by 0-ts/test_bst2.py::test_balance_method

test_bsts = (<bst2.Bst object at 0x7ff2282da5f0>, <bst2.Bst object at 0x7ff227de1180>, <bst2.Bst object at 0x7ff227de2380>, <bst2.Bst object at 0x7ff227de0b80>, <bst2.Bst object at 0x7ff227de0be0>, <bst2.Bst object at 0x7ff227de3340>)

    def test_balance_method(test_bsts):
        """Test the balance method."""
        balance = [0, 0, 0, 0, 3, -5]
>       assert all(tree.balance() == balance[idx]
                   for idx, tree in enumerate(test_bsts))
E       AssertionError

0-ts/test_bst2.py:92: AssertionError
[36m   -[0m [#  97] CRP bst2: 
--------------------------------------------------------------------------------
  150:             if not tree:
  151:                 return 0
  152:         
  153:         leftbranch = 0 if not (tree.left) else tree.left.height
[34m- 154:         rightbranch = 0 if not (tree.right) else tree.right.height[0m
[32m+ 154:         rightbranch = 1 if not (tree.right) else tree.right.height[0m
  155:         
  156:         return leftbranch - rightbranch
  157:     
  158:     def pre_order(self, node='root'):
--------------------------------------------------------------------------------
[0.23044 s] [32mkilled[0m by 0-ts/test_bst2.py::test_balance_method

test_bsts = (<bst2.Bst object at 0x7ff227d29db0>, <bst2.Bst object at 0x7ff227dae0e0>, <bst2.Bst object at 0x7ff227dae6e0>, <bst2.Bst object at 0x7ff227daf2e0>, <bst2.Bst object at 0x7ff227dac460>, <bst2.Bst object at 0x7ff227dad3f0>)

    def test_balance_method(test_bsts):
        """Test the balance method."""
        balance = [0, 0, 0, 0, 3, -5]
>       assert all(tree.balance() == balance[idx]
                   for idx, tree in enumerate(test_bsts))
E       AssertionError

0-ts/test_bst2.py:92: AssertionError
[36m   -[0m [#  98] CRP bst2: 
--------------------------------------------------------------------------------
  154:         rightbranch = 0 if not (tree.right) else tree.right.height
  155:         
  156:         return leftbranch - rightbranch
  157:     
[34m- 158:     def pre_order(self, node='root'):[0m
[32m+ 158:     def pre_order(self, node='mutpy'):[0m
  159:         '''Depth first pre-order traversal of tree.'''
  160:         if node == 'root':
  161:             node = self.root
  162:         
--------------------------------------------------------------------------------
[0.21294 s] [32mkilled[0m by 0-ts/test_bst2.py::test_pre_order

test_traversals = {'breadth': ['F', 'B', 'G', 'A', 'D', 'I', ...], 'empty': <bst2.Bst object at 0x7ff227d6f2e0>, 'in_order': ['A', 'B', 'C', 'D', 'E', 'F', ...], 'post_order': ['A', 'C', 'E', 'D', 'B', 'H', ...], ...}

    def test_pre_order(test_traversals):
        """Test preorder for a traversal."""
>       path = [i for i in test_traversals['tree'].pre_order()]

0-ts/test_bst2.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
0-ts/test_bst2.py:103: in <listcomp>
    path = [i for i in test_traversals['tree'].pre_order()]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x7ff227d6ee30>, node = 'mutpy'

>   ???
E   AttributeError: 'str' object has no attribute 'val'

bst2:166: AttributeError
[36m   -[0m [#  99] CRP bst2: 
--------------------------------------------------------------------------------
  154:         rightbranch = 0 if not (tree.right) else tree.right.height
  155:         
  156:         return leftbranch - rightbranch
  157:     
[34m- 158:     def pre_order(self, node='root'):[0m
[32m+ 158:     def pre_order(self, node=''):[0m
  159:         '''Depth first pre-order traversal of tree.'''
  160:         if node == 'root':
  161:             node = self.root
  162:         
--------------------------------------------------------------------------------
[0.36555 s] [32mkilled[0m by 0-ts/test_bst2.py::test_pre_order

test_traversals = {'breadth': ['F', 'B', 'G', 'A', 'D', 'I', ...], 'empty': <bst2.Bst object at 0x7ff227cf11b0>, 'in_order': ['A', 'B', 'C', 'D', 'E', 'F', ...], 'post_order': ['A', 'C', 'E', 'D', 'B', 'H', ...], ...}

    def test_pre_order(test_traversals):
        """Test preorder for a traversal."""
        path = [i for i in test_traversals['tree'].pre_order()]
>       assert path == test_traversals['pre_order']
E       AssertionError

0-ts/test_bst2.py:104: AssertionError
[36m   -[0m [# 100] CRP bst2: 
--------------------------------------------------------------------------------
  156:         return leftbranch - rightbranch
  157:     
  158:     def pre_order(self, node='root'):
  159:         '''Depth first pre-order traversal of tree.'''
[34m- 160:         if node == 'root':[0m
[32m+ 160:         if node == 'mutpy':[0m
  161:             node = self.root
  162:         
  163:         if not node:
  164:             return
--------------------------------------------------------------------------------
[0.22979 s] [32mkilled[0m by 0-ts/test_bst2.py::test_pre_order

test_traversals = {'breadth': ['F', 'B', 'G', 'A', 'D', 'I', ...], 'empty': <bst2.Bst object at 0x7ff227c45d80>, 'in_order': ['A', 'B', 'C', 'D', 'E', 'F', ...], 'post_order': ['A', 'C', 'E', 'D', 'B', 'H', ...], ...}

    def test_pre_order(test_traversals):
        """Test preorder for a traversal."""
>       path = [i for i in test_traversals['tree'].pre_order()]

0-ts/test_bst2.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
0-ts/test_bst2.py:103: in <listcomp>
    path = [i for i in test_traversals['tree'].pre_order()]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x7ff227c47b80>, node = 'root'

>   ???
E   AttributeError: 'str' object has no attribute 'val'

bst2:166: AttributeError
[36m   -[0m [# 101] CRP bst2: 
--------------------------------------------------------------------------------
  156:         return leftbranch - rightbranch
  157:     
  158:     def pre_order(self, node='root'):
  159:         '''Depth first pre-order traversal of tree.'''
[34m- 160:         if node == 'root':[0m
[32m+ 160:         if node == '':[0m
  161:             node = self.root
  162:         
  163:         if not node:
  164:             return
--------------------------------------------------------------------------------
[0.23050 s] [32mkilled[0m by 0-ts/test_bst2.py::test_pre_order

test_traversals = {'breadth': ['F', 'B', 'G', 'A', 'D', 'I', ...], 'empty': <bst2.Bst object at 0x7ff227d76da0>, 'in_order': ['A', 'B', 'C', 'D', 'E', 'F', ...], 'post_order': ['A', 'C', 'E', 'D', 'B', 'H', ...], ...}

    def test_pre_order(test_traversals):
        """Test preorder for a traversal."""
>       path = [i for i in test_traversals['tree'].pre_order()]

0-ts/test_bst2.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
0-ts/test_bst2.py:103: in <listcomp>
    path = [i for i in test_traversals['tree'].pre_order()]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x7ff227d76ce0>, node = 'root'

>   ???
E   AttributeError: 'str' object has no attribute 'val'

bst2:166: AttributeError
[36m   -[0m [# 102] CRP bst2: 
--------------------------------------------------------------------------------
  169:             yield n
  170:         for n in self.pre_order(node=node.right):
  171:             yield n
  172:     
[34m- 173:     def in_order(self, node='root'):[0m
[32m+ 173:     def in_order(self, node='mutpy'):[0m
  174:         '''Depth first in-order traversal of tree.'''
  175:         if node == 'root':
  176:             node = self.root
  177:         
--------------------------------------------------------------------------------
[0.21345 s] [32mkilled[0m by 0-ts/test_bst2.py::test_in_order

test_traversals = {'breadth': ['F', 'B', 'G', 'A', 'D', 'I', ...], 'empty': <bst2.Bst object at 0x7ff2281cb640>, 'in_order': ['A', 'B', 'C', 'D', 'E', 'F', ...], 'post_order': ['A', 'C', 'E', 'D', 'B', 'H', ...], ...}

    def test_in_order(test_traversals):
        """Test inorder for a traversal."""
>       path = [i for i in test_traversals['tree'].in_order()]

0-ts/test_bst2.py:109: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
0-ts/test_bst2.py:109: in <listcomp>
    path = [i for i in test_traversals['tree'].in_order()]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x7ff2281cb9a0>, node = 'mutpy'

>   ???
E   AttributeError: 'str' object has no attribute 'left'

bst2:181: AttributeError
[36m   -[0m [# 103] CRP bst2: 
--------------------------------------------------------------------------------
  169:             yield n
  170:         for n in self.pre_order(node=node.right):
  171:             yield n
  172:     
[34m- 173:     def in_order(self, node='root'):[0m
[32m+ 173:     def in_order(self, node=''):[0m
  174:         '''Depth first in-order traversal of tree.'''
  175:         if node == 'root':
  176:             node = self.root
  177:         
--------------------------------------------------------------------------------
[0.21653 s] [32mkilled[0m by 0-ts/test_bst2.py::test_in_order

test_traversals = {'breadth': ['F', 'B', 'G', 'A', 'D', 'I', ...], 'empty': <bst2.Bst object at 0x7ff22825b880>, 'in_order': ['A', 'B', 'C', 'D', 'E', 'F', ...], 'post_order': ['A', 'C', 'E', 'D', 'B', 'H', ...], ...}

    def test_in_order(test_traversals):
        """Test inorder for a traversal."""
        path = [i for i in test_traversals['tree'].in_order()]
>       assert path == test_traversals['in_order']
E       AssertionError

0-ts/test_bst2.py:110: AssertionError
[36m   -[0m [# 104] CRP bst2: 
--------------------------------------------------------------------------------
  171:             yield n
  172:     
  173:     def in_order(self, node='root'):
  174:         '''Depth first in-order traversal of tree.'''
[34m- 175:         if node == 'root':[0m
[32m+ 175:         if node == 'mutpy':[0m
  176:             node = self.root
  177:         
  178:         if not node:
  179:             return
--------------------------------------------------------------------------------
[0.21198 s] [32mkilled[0m by 0-ts/test_bst2.py::test_in_order

test_traversals = {'breadth': ['F', 'B', 'G', 'A', 'D', 'I', ...], 'empty': <bst2.Bst object at 0x7ff228205c60>, 'in_order': ['A', 'B', 'C', 'D', 'E', 'F', ...], 'post_order': ['A', 'C', 'E', 'D', 'B', 'H', ...], ...}

    def test_in_order(test_traversals):
        """Test inorder for a traversal."""
>       path = [i for i in test_traversals['tree'].in_order()]

0-ts/test_bst2.py:109: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
0-ts/test_bst2.py:109: in <listcomp>
    path = [i for i in test_traversals['tree'].in_order()]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x7ff228205cc0>, node = 'root'

>   ???
E   AttributeError: 'str' object has no attribute 'left'

bst2:181: AttributeError
[36m   -[0m [# 105] CRP bst2: 
--------------------------------------------------------------------------------
  171:             yield n
  172:     
  173:     def in_order(self, node='root'):
  174:         '''Depth first in-order traversal of tree.'''
[34m- 175:         if node == 'root':[0m
[32m+ 175:         if node == '':[0m
  176:             node = self.root
  177:         
  178:         if not node:
  179:             return
--------------------------------------------------------------------------------
[0.22857 s] [32mkilled[0m by 0-ts/test_bst2.py::test_in_order

test_traversals = {'breadth': ['F', 'B', 'G', 'A', 'D', 'I', ...], 'empty': <bst2.Bst object at 0x7ff2281350f0>, 'in_order': ['A', 'B', 'C', 'D', 'E', 'F', ...], 'post_order': ['A', 'C', 'E', 'D', 'B', 'H', ...], ...}

    def test_in_order(test_traversals):
        """Test inorder for a traversal."""
>       path = [i for i in test_traversals['tree'].in_order()]

0-ts/test_bst2.py:109: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
0-ts/test_bst2.py:109: in <listcomp>
    path = [i for i in test_traversals['tree'].in_order()]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x7ff2281352a0>, node = 'root'

>   ???
E   AttributeError: 'str' object has no attribute 'left'

bst2:181: AttributeError
[36m   -[0m [# 106] CRP bst2: 
--------------------------------------------------------------------------------
  183:         yield node.val
  184:         for n in self.in_order(node=node.right):
  185:             yield n
  186:     
[34m- 187:     def post_order(self, node='root'):[0m
[32m+ 187:     def post_order(self, node='mutpy'):[0m
  188:         '''Depth frist post_order traversal of tree.'''
  189:         if node == 'root':
  190:             node = self.root
  191:         
--------------------------------------------------------------------------------
[0.21144 s] [32mkilled[0m by 0-ts/test_bst2.py::test_post_order

test_traversals = {'breadth': ['F', 'B', 'G', 'A', 'D', 'I', ...], 'empty': <bst2.Bst object at 0x7ff227dae110>, 'in_order': ['A', 'B', 'C', 'D', 'E', 'F', ...], 'post_order': ['A', 'C', 'E', 'D', 'B', 'H', ...], ...}

    def test_post_order(test_traversals):
        """Test postorder for a traversal."""
>       path = [i for i in test_traversals['tree'].post_order()]

0-ts/test_bst2.py:115: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
0-ts/test_bst2.py:115: in <listcomp>
    path = [i for i in test_traversals['tree'].post_order()]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x7ff227cf0a90>, node = 'mutpy'

>   ???
E   AttributeError: 'str' object has no attribute 'left'

bst2:195: AttributeError
[36m   -[0m [# 107] CRP bst2: 
--------------------------------------------------------------------------------
  183:         yield node.val
  184:         for n in self.in_order(node=node.right):
  185:             yield n
  186:     
[34m- 187:     def post_order(self, node='root'):[0m
[32m+ 187:     def post_order(self, node=''):[0m
  188:         '''Depth frist post_order traversal of tree.'''
  189:         if node == 'root':
  190:             node = self.root
  191:         
--------------------------------------------------------------------------------
[0.21974 s] [32mkilled[0m by 0-ts/test_bst2.py::test_post_order

test_traversals = {'breadth': ['F', 'B', 'G', 'A', 'D', 'I', ...], 'empty': <bst2.Bst object at 0x7ff227d4feb0>, 'in_order': ['A', 'B', 'C', 'D', 'E', 'F', ...], 'post_order': ['A', 'C', 'E', 'D', 'B', 'H', ...], ...}

    def test_post_order(test_traversals):
        """Test postorder for a traversal."""
        path = [i for i in test_traversals['tree'].post_order()]
>       assert path == test_traversals['post_order']
E       AssertionError

0-ts/test_bst2.py:116: AssertionError
[36m   -[0m [# 108] CRP bst2: 
--------------------------------------------------------------------------------
  185:             yield n
  186:     
  187:     def post_order(self, node='root'):
  188:         '''Depth frist post_order traversal of tree.'''
[34m- 189:         if node == 'root':[0m
[32m+ 189:         if node == 'mutpy':[0m
  190:             node = self.root
  191:         
  192:         if not node:
  193:             return
--------------------------------------------------------------------------------
[0.30512 s] [32mkilled[0m by 0-ts/test_bst2.py::test_post_order

test_traversals = {'breadth': ['F', 'B', 'G', 'A', 'D', 'I', ...], 'empty': <bst2.Bst object at 0x7ff227baf3a0>, 'in_order': ['A', 'B', 'C', 'D', 'E', 'F', ...], 'post_order': ['A', 'C', 'E', 'D', 'B', 'H', ...], ...}

    def test_post_order(test_traversals):
        """Test postorder for a traversal."""
>       path = [i for i in test_traversals['tree'].post_order()]

0-ts/test_bst2.py:115: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
0-ts/test_bst2.py:115: in <listcomp>
    path = [i for i in test_traversals['tree'].post_order()]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x7ff227bae740>, node = 'root'

>   ???
E   AttributeError: 'str' object has no attribute 'left'

bst2:195: AttributeError
[36m   -[0m [# 109] CRP bst2: 
--------------------------------------------------------------------------------
  185:             yield n
  186:     
  187:     def post_order(self, node='root'):
  188:         '''Depth frist post_order traversal of tree.'''
[34m- 189:         if node == 'root':[0m
[32m+ 189:         if node == '':[0m
  190:             node = self.root
  191:         
  192:         if not node:
  193:             return
--------------------------------------------------------------------------------
[0.20685 s] [32mkilled[0m by 0-ts/test_bst2.py::test_post_order

test_traversals = {'breadth': ['F', 'B', 'G', 'A', 'D', 'I', ...], 'empty': <bst2.Bst object at 0x7ff2282d9cc0>, 'in_order': ['A', 'B', 'C', 'D', 'E', 'F', ...], 'post_order': ['A', 'C', 'E', 'D', 'B', 'H', ...], ...}

    def test_post_order(test_traversals):
        """Test postorder for a traversal."""
>       path = [i for i in test_traversals['tree'].post_order()]

0-ts/test_bst2.py:115: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
0-ts/test_bst2.py:115: in <listcomp>
    path = [i for i in test_traversals['tree'].post_order()]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x7ff227c45f90>, node = 'root'

>   ???
E   AttributeError: 'str' object has no attribute 'left'

bst2:195: AttributeError
[36m   -[0m [# 110] CRP bst2: 
--------------------------------------------------------------------------------
  211:                 q.enqueue(node.right)
  212:     
  213:     def delete(self, val):
  214:         '''Remove a node from the tree.'''
[34m- 215:         if (self._size < 1 or not (self.contains(val))):[0m
[32m+ 215:         if (self._size < 2 or not (self.contains(val))):[0m
  216:             return
  217:         
  218:         node = self.search(val)
  219:         
--------------------------------------------------------------------------------
[0.22095 s] [32mkilled[0m by 0-ts/test_bst2.py::test_remove_leaf_root

test_bsts = (<bst2.Bst object at 0x7ff22834f190>, <bst2.Bst object at 0x7ff22834d690>, <bst2.Bst object at 0x7ff22834ea70>, <bst2.Bst object at 0x7ff22834e830>, <bst2.Bst object at 0x7ff22834e890>, <bst2.Bst object at 0x7ff22834c610>)

    def test_remove_leaf_root(test_bsts):
        """Test delete leaf that is root."""
        test_bsts[1].delete(5)
>       assert not test_bsts[1].contains(5)
E       AssertionError

0-ts/test_bst2.py:161: AssertionError
[36m   -[0m [# 111] CRP bst2: 
--------------------------------------------------------------------------------
  224:                 self.root = None
  225:         
  226:         elif node._is_interior():
  227:             next_node = self._find_replacement(node)
[34m- 228:             self._size += 1[0m
[32m+ 228:             self._size += 2[0m
  229:             self.delete(next_node.val)
  230:             node.val = next_node.val
  231:         else:
  232:             
--------------------------------------------------------------------------------
[0.21707 s] [32mkilled[0m by 0-ts/test_bst2.py::test_delete_two_children

test_bsts = (<bst2.Bst object at 0x7ff22815d6c0>, <bst2.Bst object at 0x7ff22815da80>, <bst2.Bst object at 0x7ff22815f880>, <bst2.Bst object at 0x7ff22815cdc0>, <bst2.Bst object at 0x7ff22815d8d0>, <bst2.Bst object at 0x7ff22815cd00>)

    def test_delete_two_children(test_bsts):
        """Test delete node with two children."""
        test_bsts[3].delete(3)
        assert not test_bsts[3].contains(3)
>       assert test_bsts[3].size() is 6
E       AssertionError

0-ts/test_bst2.py:210: AssertionError
[36m   -[0m [# 112] CRP bst2: 
--------------------------------------------------------------------------------
  236:                 setattr(node.parent, node._side(), child)
  237:             else:
  238:                 self.root = child
  239:         
[34m- 240:         self._size -= 1[0m
[32m+ 240:         self._size -= 2[0m
  241:     
  242:     def _find_replacement(self, node):
  243:         '''Find left most node of right subtree.'''
  244:         if node.right:
--------------------------------------------------------------------------------
[0.23785 s] [32mkilled[0m by 0-ts/test_bst2.py::test_remove_leaf_left

test_bsts = (<bst2.Bst object at 0x7ff227d06740>, <bst2.Bst object at 0x7ff227d061a0>, <bst2.Bst object at 0x7ff227d073d0>, <bst2.Bst object at 0x7ff227d06b90>, <bst2.Bst object at 0x7ff227d05b10>, <bst2.Bst object at 0x7ff227d05810>)

    def test_remove_leaf_left(test_bsts):
        """Test delete leaf on left."""
        test_bsts[2].delete(3)
        assert not test_bsts[2].contains(3)
>       assert test_bsts[2].size() is 2
E       AssertionError

0-ts/test_bst2.py:148: AssertionError
[36m   -[0m [# 113] CRP bst2: 
--------------------------------------------------------------------------------
  244:         if node.right:
  245:             return self._findmin(node.right)
  246:         
  247:         elif node.parent:
[34m- 248:             if node._side() == 'left':[0m
[32m+ 248:             if node._side() == 'mutpy':[0m
  249:                 return self.parent
  250:             else:
  251:                 node.parent.right = None
  252:                 tmp = self._find_replacement(node.parent)
--------------------------------------------------------------------------------
[0.29399 s] [31msurvived[0m
[36m   -[0m [# 114] CRP bst2: 
--------------------------------------------------------------------------------
  244:         if node.right:
  245:             return self._findmin(node.right)
  246:         
  247:         elif node.parent:
[34m- 248:             if node._side() == 'left':[0m
[32m+ 248:             if node._side() == '':[0m
  249:                 return self.parent
  250:             else:
  251:                 node.parent.right = None
  252:                 tmp = self._find_replacement(node.parent)
--------------------------------------------------------------------------------
[0.22680 s] [31msurvived[0m
[36m   -[0m [# 115] LCR bst2: 
--------------------------------------------------------------------------------
   15:         self.height = 1
   16:     
   17:     def _is_leaf(self):
   18:         '''Return true if a leaf.'''
[34m-  19:         return not ((self.right or self.left))[0m
[32m+  19:         return not ((self.right and self.left))[0m
   20:     
   21:     def _is_interior(self):
   22:         '''Return true if a interior node.'''
   23:         return (self.right and self.left)
--------------------------------------------------------------------------------
[0.27207 s] [32mkilled[0m by 0-ts/test_bst2.py::test_remove_one_child_root

test_bsts = (<bst2.Bst object at 0x7ff22815de40>, <bst2.Bst object at 0x7ff22815fa60>, <bst2.Bst object at 0x7ff22815c7c0>, <bst2.Bst object at 0x7ff22815e8f0>, <bst2.Bst object at 0x7ff22815e080>, <bst2.Bst object at 0x7ff22815ed10>)

    def test_remove_one_child_root(test_bsts):
        """Test delete node that is root with one child."""
        test_bsts[1].insert(7)
        test_bsts[1].delete(5)
        assert not test_bsts[1].contains(5)
        assert test_bsts[1].size() is 1
>       assert test_bsts[1].root.val is 7
E       AttributeError: 'NoneType' object has no attribute 'val'

0-ts/test_bst2.py:203: AttributeError
[36m   -[0m [# 116] LCR bst2: 
--------------------------------------------------------------------------------
   19:         return not ((self.right or self.left))
   20:     
   21:     def _is_interior(self):
   22:         '''Return true if a interior node.'''
[34m-  23:         return (self.right and self.left)[0m
[32m+  23:         return (self.right or self.left)[0m
   24:     
   25:     def _onlychild(self):
   26:         '''Return string depending on children.'''
   27:         if (self.left and not (self.right)):
--------------------------------------------------------------------------------
[0.26421 s] [32mkilled[0m by 0-ts/test_bst2.py::test_remove_one_child_left

test_bsts = (<bst2.Bst object at 0x7ff2281b84f0>, <bst2.Bst object at 0x7ff2281bbb80>, <bst2.Bst object at 0x7ff2281b9720>, <bst2.Bst object at 0x7ff2281b96f0>, <bst2.Bst object at 0x7ff2281b80a0>, <bst2.Bst object at 0x7ff2281c3c10>)

    def test_remove_one_child_left(test_bsts):
        """Test delete node one child, left."""
>       test_bsts[4].delete(3)

0-ts/test_bst2.py:167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
bst2:227: in delete
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x7ff2281b80a0>
node = <bst2.Node object at 0x7ff2281c3d30>

>   ???
E   AttributeError: 'Bst' object has no attribute 'parent'

bst2:249: AttributeError
[36m   -[0m [# 117] LCR bst2: 
--------------------------------------------------------------------------------
   23:         return (self.right and self.left)
   24:     
   25:     def _onlychild(self):
   26:         '''Return string depending on children.'''
[34m-  27:         if (self.left and not (self.right)):[0m
[32m+  27:         if (self.left or not (self.right)):[0m
   28:             return 'left'
   29:         if (self.right and not (self.left)):
   30:             return 'right'
   31:     
--------------------------------------------------------------------------------
[0.30540 s] [31msurvived[0m
[36m   -[0m [# 118] LCR bst2: 
--------------------------------------------------------------------------------
   25:     def _onlychild(self):
   26:         '''Return string depending on children.'''
   27:         if (self.left and not (self.right)):
   28:             return 'left'
[34m-  29:         if (self.right and not (self.left)):[0m
[32m+  29:         if (self.right or not (self.left)):[0m
   30:             return 'right'
   31:     
   32:     def _side(self):
   33:         '''Return if left or right child of parent.'''
--------------------------------------------------------------------------------
[0.21630 s] [31msurvived[0m
[36m   -[0m [# 119] LCR bst2: 
--------------------------------------------------------------------------------
  211:                 q.enqueue(node.right)
  212:     
  213:     def delete(self, val):
  214:         '''Remove a node from the tree.'''
[34m- 215:         if (self._size < 1 or not (self.contains(val))):[0m
[32m+ 215:         if (self._size < 1 and not (self.contains(val))):[0m
  216:             return
  217:         
  218:         node = self.search(val)
  219:         
--------------------------------------------------------------------------------
[0.20669 s] [32mkilled[0m by 0-ts/test_bst2.py::test_del_false

test_bsts = (<bst2.Bst object at 0x7ff2282d8f70>, <bst2.Bst object at 0x7ff2282db280>, <bst2.Bst object at 0x7ff2282da560>, <bst2.Bst object at 0x7ff2282d8bb0>, <bst2.Bst object at 0x7ff2282db0d0>, <bst2.Bst object at 0x7ff2282dbe50>)

    def test_del_false(test_bsts):
        """Test delete for a node not in tree."""
        size = test_bsts[2].size()
>       test_bsts[2].delete(1)

0-ts/test_bst2.py:134: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x7ff2282da560>, val = 1

>   ???
E   AttributeError: 'NoneType' object has no attribute '_is_leaf'

bst2:220: AttributeError
[36m   -[0m [# 120] OIL bst2: 
--------------------------------------------------------------------------------
   82:         
   83:         if data:
   84:             for i in data:
   85:                 self.insert(i)
[34m-  86:     [0m
[32m+  86:                 break[0m
   87:     def insert(self, val):
   88:         '''Insert val into BST. If val is already present will be ignored.'''
   89:         if not (self.root):
   90:             self.root = Node(val)
--------------------------------------------------------------------------------
[0.23274 s] [32mkilled[0m by 0-ts/test_bst2.py::test_contains_method

test_bsts = (<bst2.Bst object at 0x7ff228384e50>, <bst2.Bst object at 0x7ff228384e20>, <bst2.Bst object at 0x7ff228384df0>, <bst2.Bst object at 0x7ff228384700>, <bst2.Bst object at 0x7ff228384fd0>, <bst2.Bst object at 0x7ff228384bb0>)

    def test_contains_method(test_bsts):
        """Test contains on number that exists."""
        assert test_bsts[2].contains(5)
>       assert test_bsts[2].contains(3)
E       AssertionError

0-ts/test_bst2.py:73: AssertionError
[36m   -[0m [# 121] OIL bst2: 
--------------------------------------------------------------------------------
  122:                 return curr
  123:             elif val < curr.val:
  124:                 curr = curr.left
  125:             else:
[34m- 126:                 curr = curr.right[0m
[32m+ 126:                 curr = curr.rightbreak[0m
  127:     
  128:     def size(self):
  129:         '''Return the size of the BST.'''
  130:         return self._size
--------------------------------------------------------------------------------
[0.22431 s] [32mkilled[0m by 0-ts/test_bst2.py::test_contains_method

test_bsts = (<bst2.Bst object at 0x7ff2282681c0>, <bst2.Bst object at 0x7ff228269e40>, <bst2.Bst object at 0x7ff22826a2f0>, <bst2.Bst object at 0x7ff22826a5f0>, <bst2.Bst object at 0x7ff22826a650>, <bst2.Bst object at 0x7ff22826ab60>)

    def test_contains_method(test_bsts):
        """Test contains on number that exists."""
        assert test_bsts[2].contains(5)
>       assert test_bsts[2].contains(3)
E       AssertionError

0-ts/test_bst2.py:73: AssertionError
[36m   -[0m [# 122] OIL bst2: 
--------------------------------------------------------------------------------
  166:         yield node.val
  167:         
  168:         for n in self.pre_order(node=node.left):
  169:             yield n
[34m- 170:         for n in self.pre_order(node=node.right):[0m
[34m- 171:             yield n[0m
[34m- 172:     [0m
[32m+ 170:             break[0m
[32m+ 171:         for n in self.pre_order(node=node.right):[0m
[32m+ 172:             yield n[0m
  173:     def in_order(self, node='root'):
  174:         '''Depth first in-order traversal of tree.'''
  175:         if node == 'root':
  176:             node = self.root
--------------------------------------------------------------------------------
[0.26990 s] [32mkilled[0m by 0-ts/test_bst2.py::test_pre_order

test_traversals = {'breadth': ['F', 'B', 'G', 'A', 'D', 'I', ...], 'empty': <bst2.Bst object at 0x7ff227f259c0>, 'in_order': ['A', 'B', 'C', 'D', 'E', 'F', ...], 'post_order': ['A', 'C', 'E', 'D', 'B', 'H', ...], ...}

    def test_pre_order(test_traversals):
        """Test preorder for a traversal."""
        path = [i for i in test_traversals['tree'].pre_order()]
>       assert path == test_traversals['pre_order']
E       AssertionError

0-ts/test_bst2.py:104: AssertionError
[36m   -[0m [# 123] OIL bst2: 
--------------------------------------------------------------------------------
  168:         for n in self.pre_order(node=node.left):
  169:             yield n
  170:         for n in self.pre_order(node=node.right):
  171:             yield n
[34m- 172:     [0m
[32m+ 172:             break[0m
  173:     def in_order(self, node='root'):
  174:         '''Depth first in-order traversal of tree.'''
  175:         if node == 'root':
  176:             node = self.root
--------------------------------------------------------------------------------
[0.25573 s] [32mkilled[0m by 0-ts/test_bst2.py::test_pre_order

test_traversals = {'breadth': ['F', 'B', 'G', 'A', 'D', 'I', ...], 'empty': <bst2.Bst object at 0x7ff227f467a0>, 'in_order': ['A', 'B', 'C', 'D', 'E', 'F', ...], 'post_order': ['A', 'C', 'E', 'D', 'B', 'H', ...], ...}

    def test_pre_order(test_traversals):
        """Test preorder for a traversal."""
        path = [i for i in test_traversals['tree'].pre_order()]
>       assert path == test_traversals['pre_order']
E       AssertionError

0-ts/test_bst2.py:104: AssertionError
[36m   -[0m [# 124] OIL bst2: 
--------------------------------------------------------------------------------
  179:             return
  180:         
  181:         for n in self.in_order(node=node.left):
  182:             yield n
[34m- 183:         yield node.val[0m
[34m- 184:         for n in self.in_order(node=node.right):[0m
[34m- 185:             yield n[0m
[34m- 186:     [0m
[32m+ 183:             break[0m
[32m+ 184:         yield node.val[0m
[32m+ 185:         for n in self.in_order(node=node.right):[0m
[32m+ 186:             yield n[0m
  187:     def post_order(self, node='root'):
  188:         '''Depth frist post_order traversal of tree.'''
  189:         if node == 'root':
  190:             node = self.root
--------------------------------------------------------------------------------
[0.23001 s] [32mkilled[0m by 0-ts/test_bst2.py::test_in_order

test_traversals = {'breadth': ['F', 'B', 'G', 'A', 'D', 'I', ...], 'empty': <bst2.Bst object at 0x7ff228278e50>, 'in_order': ['A', 'B', 'C', 'D', 'E', 'F', ...], 'post_order': ['A', 'C', 'E', 'D', 'B', 'H', ...], ...}

    def test_in_order(test_traversals):
        """Test inorder for a traversal."""
        path = [i for i in test_traversals['tree'].in_order()]
>       assert path == test_traversals['in_order']
E       AssertionError

0-ts/test_bst2.py:110: AssertionError
[36m   -[0m [# 125] OIL bst2: 
--------------------------------------------------------------------------------
  182:             yield n
  183:         yield node.val
  184:         for n in self.in_order(node=node.right):
  185:             yield n
[34m- 186:     [0m
[32m+ 186:             break[0m
  187:     def post_order(self, node='root'):
  188:         '''Depth frist post_order traversal of tree.'''
  189:         if node == 'root':
  190:             node = self.root
--------------------------------------------------------------------------------
[0.26060 s] [32mkilled[0m by 0-ts/test_bst2.py::test_in_order

test_traversals = {'breadth': ['F', 'B', 'G', 'A', 'D', 'I', ...], 'empty': <bst2.Bst object at 0x7ff2281c9570>, 'in_order': ['A', 'B', 'C', 'D', 'E', 'F', ...], 'post_order': ['A', 'C', 'E', 'D', 'B', 'H', ...], ...}

    def test_in_order(test_traversals):
        """Test inorder for a traversal."""
        path = [i for i in test_traversals['tree'].in_order()]
>       assert path == test_traversals['in_order']
E       AssertionError

0-ts/test_bst2.py:110: AssertionError
[36m   -[0m [# 126] OIL bst2: 
--------------------------------------------------------------------------------
  193:             return
  194:         
  195:         for n in self.post_order(node=node.left):
  196:             yield n
[34m- 197:         for n in self.post_order(node=node.right):[0m
[34m- 198:             yield n[0m
[34m- 199:         yield node.val[0m
[34m- 200:     [0m
[32m+ 197:             break[0m
[32m+ 198:         for n in self.post_order(node=node.right):[0m
[32m+ 199:             yield n[0m
[32m+ 200:         yield node.val[0m
  201:     def breadth_first(self):
  202:         '''Breadth first traversal of tree.'''
  203:         q = Queue()
  204:         q.enqueue(self.root)
--------------------------------------------------------------------------------
[0.34677 s] [32mkilled[0m by 0-ts/test_bst2.py::test_post_order

test_traversals = {'breadth': ['F', 'B', 'G', 'A', 'D', 'I', ...], 'empty': <bst2.Bst object at 0x7ff227fa2ec0>, 'in_order': ['A', 'B', 'C', 'D', 'E', 'F', ...], 'post_order': ['A', 'C', 'E', 'D', 'B', 'H', ...], ...}

    def test_post_order(test_traversals):
        """Test postorder for a traversal."""
        path = [i for i in test_traversals['tree'].post_order()]
>       assert path == test_traversals['post_order']
E       AssertionError

0-ts/test_bst2.py:116: AssertionError
[36m   -[0m [# 127] OIL bst2: 
--------------------------------------------------------------------------------
  195:         for n in self.post_order(node=node.left):
  196:             yield n
  197:         for n in self.post_order(node=node.right):
  198:             yield n
[34m- 199:         yield node.val[0m
[34m- 200:     [0m
[32m+ 199:             break[0m
[32m+ 200:         yield node.val[0m
  201:     def breadth_first(self):
  202:         '''Breadth first traversal of tree.'''
  203:         q = Queue()
  204:         q.enqueue(self.root)
--------------------------------------------------------------------------------
[0.26195 s] [32mkilled[0m by 0-ts/test_bst2.py::test_post_order

test_traversals = {'breadth': ['F', 'B', 'G', 'A', 'D', 'I', ...], 'empty': <bst2.Bst object at 0x7ff227d67d00>, 'in_order': ['A', 'B', 'C', 'D', 'E', 'F', ...], 'post_order': ['A', 'C', 'E', 'D', 'B', 'H', ...], ...}

    def test_post_order(test_traversals):
        """Test postorder for a traversal."""
        path = [i for i in test_traversals['tree'].post_order()]
>       assert path == test_traversals['post_order']
E       AssertionError

0-ts/test_bst2.py:116: AssertionError
[36m   -[0m [# 128] OIL bst2: 
--------------------------------------------------------------------------------
  208:             if node.left:
  209:                 q.enqueue(node.left)
  210:             if node.right:
  211:                 q.enqueue(node.right)
[34m- 212:     [0m
[32m+ 212:             break[0m
  213:     def delete(self, val):
  214:         '''Remove a node from the tree.'''
  215:         if (self._size < 1 or not (self.contains(val))):
  216:             return
--------------------------------------------------------------------------------
[0.25334 s] [32mkilled[0m by 0-ts/test_bst2.py::test_breadth_first

test_traversals = {'breadth': ['F', 'B', 'G', 'A', 'D', 'I', ...], 'empty': <bst2.Bst object at 0x7ff2287fdae0>, 'in_order': ['A', 'B', 'C', 'D', 'E', 'F', ...], 'post_order': ['A', 'C', 'E', 'D', 'B', 'H', ...], ...}

    def test_breadth_first(test_traversals):
        """Test breadth first for a traversal."""
        path = [i for i in test_traversals['tree'].breadth_first()]
>       assert path == test_traversals['breadth']
E       AssertionError

0-ts/test_bst2.py:122: AssertionError
[36m   -[0m [# 129] OIL bst2: 
--------------------------------------------------------------------------------
  256:     def _findmin(self, node):
  257:         '''Find min of subtree, Min is always left most node.'''
  258:         while node.left:
  259:             node = node.left
[34m- 260:         return node[0m
[32m+ 260:             break[0m
[32m+ 261:         return node[0m
--------------------------------------------------------------------------------
[0.22236 s] [31msurvived[0m
[36m   -[0m [# 130] RIL bst2: 
--------------------------------------------------------------------------------
   80:         self._size = 0
   81:         self.root = None
   82:         
   83:         if data:
[34m-  84:             for i in data:[0m
[32m+  84:             for i in reversed(data):[0m
   85:                 self.insert(i)
   86:     
   87:     def insert(self, val):
   88:         '''Insert val into BST. If val is already present will be ignored.'''
--------------------------------------------------------------------------------
[0.23495 s] [32mkilled[0m by 0-ts/test_bst2.py::test_depth_method

test_bsts = (<bst2.Bst object at 0x7ff2281d86a0>, <bst2.Bst object at 0x7ff2281d8880>, <bst2.Bst object at 0x7ff2281d8c10>, <bst2.Bst object at 0x7ff2281d9120>, <bst2.Bst object at 0x7ff2281d94b0>, <bst2.Bst object at 0x7ff2281d9960>)

    def test_depth_method(test_bsts):
        """Test depth method."""
        depths = [0, 1, 2, 3, 4, 6]
>       assert all(tree.depth() == depths[idx]
                   for idx, tree in enumerate(test_bsts))
E       AssertionError

0-ts/test_bst2.py:85: AssertionError
[36m   -[0m [# 131] RIL bst2: 
--------------------------------------------------------------------------------
  164:             return
  165:         
  166:         yield node.val
  167:         
[34m- 168:         for n in self.pre_order(node=node.left):[0m
[32m+ 168:         for n in reversed(self.pre_order(node=node.left)):[0m
  169:             yield n
  170:         for n in self.pre_order(node=node.right):
  171:             yield n
  172:     
--------------------------------------------------------------------------------
[0.39658 s] [36mincompetent[0m

TypeError: bst2:168: TypeError: 'generator' object is not reversible

[36m   -[0m [# 132] RIL bst2: 
--------------------------------------------------------------------------------
  166:         yield node.val
  167:         
  168:         for n in self.pre_order(node=node.left):
  169:             yield n
[34m- 170:         for n in self.pre_order(node=node.right):[0m
[32m+ 170:         for n in reversed(self.pre_order(node=node.right)):[0m
  171:             yield n
  172:     
  173:     def in_order(self, node='root'):
  174:         '''Depth first in-order traversal of tree.'''
--------------------------------------------------------------------------------
[0.23120 s] [36mincompetent[0m

TypeError: bst2:170: TypeError: 'generator' object is not reversible

[36m   -[0m [# 133] RIL bst2: 
--------------------------------------------------------------------------------
  177:         
  178:         if not node:
  179:             return
  180:         
[34m- 181:         for n in self.in_order(node=node.left):[0m
[32m+ 181:         for n in reversed(self.in_order(node=node.left)):[0m
  182:             yield n
  183:         yield node.val
  184:         for n in self.in_order(node=node.right):
  185:             yield n
--------------------------------------------------------------------------------
[0.24480 s] [36mincompetent[0m

TypeError: bst2:181: TypeError: 'generator' object is not reversible

[36m   -[0m [# 134] RIL bst2: 
--------------------------------------------------------------------------------
  180:         
  181:         for n in self.in_order(node=node.left):
  182:             yield n
  183:         yield node.val
[34m- 184:         for n in self.in_order(node=node.right):[0m
[32m+ 184:         for n in reversed(self.in_order(node=node.right)):[0m
  185:             yield n
  186:     
  187:     def post_order(self, node='root'):
  188:         '''Depth frist post_order traversal of tree.'''
--------------------------------------------------------------------------------
[0.26585 s] [36mincompetent[0m

TypeError: bst2:184: TypeError: 'generator' object is not reversible

[36m   -[0m [# 135] RIL bst2: 
--------------------------------------------------------------------------------
  191:         
  192:         if not node:
  193:             return
  194:         
[34m- 195:         for n in self.post_order(node=node.left):[0m
[32m+ 195:         for n in reversed(self.post_order(node=node.left)):[0m
  196:             yield n
  197:         for n in self.post_order(node=node.right):
  198:             yield n
  199:         yield node.val
--------------------------------------------------------------------------------
[0.39788 s] [36mincompetent[0m

TypeError: bst2:195: TypeError: 'generator' object is not reversible

[36m   -[0m [# 136] RIL bst2: 
--------------------------------------------------------------------------------
  193:             return
  194:         
  195:         for n in self.post_order(node=node.left):
  196:             yield n
[34m- 197:         for n in self.post_order(node=node.right):[0m
[32m+ 197:         for n in reversed(self.post_order(node=node.right)):[0m
  198:             yield n
  199:         yield node.val
  200:     
  201:     def breadth_first(self):
--------------------------------------------------------------------------------
[0.23790 s] [36mincompetent[0m

TypeError: bst2:197: TypeError: 'generator' object is not reversible

[36m   -[0m [# 137] ROR bst2: 
--------------------------------------------------------------------------------
   31:     
   32:     def _side(self):
   33:         '''Return if left or right child of parent.'''
   34:         if self.parent:
[34m-  35:             return 'left' if self.parent.left == self else 'right'[0m
[32m+  35:             return 'left' if self.parent.left != self else 'right'[0m
   36: 
   37: 
   38: class Bst(object):
   39:     '''Binary Search Tree.
--------------------------------------------------------------------------------
[0.23554 s] [32mkilled[0m by 0-ts/test_bst2.py::test_remove_leaf_left

test_bsts = (<bst2.Bst object at 0x7ff227d64c70>, <bst2.Bst object at 0x7ff227d64fa0>, <bst2.Bst object at 0x7ff227d647f0>, <bst2.Bst object at 0x7ff227d650f0>, <bst2.Bst object at 0x7ff227d66f20>, <bst2.Bst object at 0x7ff227d671f0>)

    def test_remove_leaf_left(test_bsts):
        """Test delete leaf on left."""
        test_bsts[2].delete(3)
>       assert not test_bsts[2].contains(3)
E       AssertionError

0-ts/test_bst2.py:147: AssertionError
[36m   -[0m [# 138] ROR bst2: 
--------------------------------------------------------------------------------
   93:             self._step(val, self.root)
   94:     
   95:     def _step(self, val, curr):
   96:         '''Decide left or right and returns height.'''
[34m-  97:         if val < curr.val:[0m
[32m+  97:         if val > curr.val:[0m
   98:             curr = self._set_child(curr, 'left', val)
   99:         elif val > curr.val:
  100:             curr = self._set_child(curr, 'right', val)
  101:         return curr.height
--------------------------------------------------------------------------------
[0.22185 s] [32mkilled[0m by 0-ts/test_bst2.py::test_insert_updates_pointers

test_bsts = (<bst2.Bst object at 0x7ff2282d8e50>, <bst2.Bst object at 0x7ff2282db6d0>, <bst2.Bst object at 0x7ff2282d8a90>, <bst2.Bst object at 0x7ff2282d85b0>, <bst2.Bst object at 0x7ff2282d8340>, <bst2.Bst object at 0x7ff2282da860>)

    def test_insert_updates_pointers(test_bsts):
        """Test insert updates pointers."""
        test_bsts[1].insert(3)
>       assert test_bsts[1].root.left.val == 3
E       AttributeError: 'NoneType' object has no attribute 'val'

0-ts/test_bst2.py:48: AttributeError
[36m   -[0m [# 139] ROR bst2: 
--------------------------------------------------------------------------------
   93:             self._step(val, self.root)
   94:     
   95:     def _step(self, val, curr):
   96:         '''Decide left or right and returns height.'''
[34m-  97:         if val < curr.val:[0m
[32m+  97:         if val <= curr.val:[0m
   98:             curr = self._set_child(curr, 'left', val)
   99:         elif val > curr.val:
  100:             curr = self._set_child(curr, 'right', val)
  101:         return curr.height
--------------------------------------------------------------------------------
[0.21835 s] [31msurvived[0m
[36m   -[0m [# 140] ROR bst2: 
--------------------------------------------------------------------------------
   95:     def _step(self, val, curr):
   96:         '''Decide left or right and returns height.'''
   97:         if val < curr.val:
   98:             curr = self._set_child(curr, 'left', val)
[34m-  99:         elif val > curr.val:[0m
[32m+  99:         elif val < curr.val:[0m
  100:             curr = self._set_child(curr, 'right', val)
  101:         return curr.height
  102:     
  103:     def _set_child(self, curr, side, val):
--------------------------------------------------------------------------------
[0.33030 s] [32mkilled[0m by 0-ts/test_bst2.py::test_insert_largest_right

test_bsts = (<bst2.Bst object at 0x7ff228047c40>, <bst2.Bst object at 0x7ff228047a90>, <bst2.Bst object at 0x7ff228045ab0>, <bst2.Bst object at 0x7ff228047ac0>, <bst2.Bst object at 0x7ff228047ca0>, <bst2.Bst object at 0x7ff228044640>)

    def test_insert_largest_right(test_bsts):
        """Test insert the largest to the right."""
        test_bsts[1].insert(7)
>       assert test_bsts[1].root.right.val > test_bsts[1].root.val
E       AttributeError: 'NoneType' object has no attribute 'val'

0-ts/test_bst2.py:61: AttributeError
[36m   -[0m [# 141] ROR bst2: 
--------------------------------------------------------------------------------
   95:     def _step(self, val, curr):
   96:         '''Decide left or right and returns height.'''
   97:         if val < curr.val:
   98:             curr = self._set_child(curr, 'left', val)
[34m-  99:         elif val > curr.val:[0m
[32m+  99:         elif val >= curr.val:[0m
  100:             curr = self._set_child(curr, 'right', val)
  101:         return curr.height
  102:     
  103:     def _set_child(self, curr, side, val):
--------------------------------------------------------------------------------
[0.22245 s] [31msurvived[0m
[36m   -[0m [# 142] ROR bst2: 
--------------------------------------------------------------------------------
  104:         '''Helping.'''
  105:         child = getattr(curr, side)
  106:         if child:
  107:             count = self._step(val, child)
[34m- 108:             if curr.height <= count:[0m
[32m+ 108:             if curr.height >= count:[0m
  109:                 curr.height += 1
  110:         else:
  111:             setattr(curr, side, Node(val, curr))
  112:             self._size += 1
--------------------------------------------------------------------------------
[0.20795 s] [32mkilled[0m by 0-ts/test_bst2.py::test_depth_method

test_bsts = (<bst2.Bst object at 0x7ff228104280>, <bst2.Bst object at 0x7ff228104a00>, <bst2.Bst object at 0x7ff2281055a0>, <bst2.Bst object at 0x7ff228107370>, <bst2.Bst object at 0x7ff228105a80>, <bst2.Bst object at 0x7ff228106440>)

    def test_depth_method(test_bsts):
        """Test depth method."""
        depths = [0, 1, 2, 3, 4, 6]
>       assert all(tree.depth() == depths[idx]
                   for idx, tree in enumerate(test_bsts))
E       AssertionError

0-ts/test_bst2.py:85: AssertionError
[36m   -[0m [# 143] ROR bst2: 
--------------------------------------------------------------------------------
  104:         '''Helping.'''
  105:         child = getattr(curr, side)
  106:         if child:
  107:             count = self._step(val, child)
[34m- 108:             if curr.height <= count:[0m
[32m+ 108:             if curr.height < count:[0m
  109:                 curr.height += 1
  110:         else:
  111:             setattr(curr, side, Node(val, curr))
  112:             self._size += 1
--------------------------------------------------------------------------------
[0.21486 s] [32mkilled[0m by 0-ts/test_bst2.py::test_depth_method

test_bsts = (<bst2.Bst object at 0x7ff22834e4d0>, <bst2.Bst object at 0x7ff22834c040>, <bst2.Bst object at 0x7ff22834d6f0>, <bst2.Bst object at 0x7ff22834ea70>, <bst2.Bst object at 0x7ff22834dff0>, <bst2.Bst object at 0x7ff227d66080>)

    def test_depth_method(test_bsts):
        """Test depth method."""
        depths = [0, 1, 2, 3, 4, 6]
>       assert all(tree.depth() == depths[idx]
                   for idx, tree in enumerate(test_bsts))
E       AssertionError

0-ts/test_bst2.py:85: AssertionError
[36m   -[0m [# 144] ROR bst2: 
--------------------------------------------------------------------------------
  109:                 curr.height += 1
  110:         else:
  111:             setattr(curr, side, Node(val, curr))
  112:             self._size += 1
[34m- 113:             if curr.height == 1:[0m
[32m+ 113:             if curr.height != 1:[0m
  114:                 curr.height += 1
  115:         return curr
  116:     
  117:     def search(self, val):
--------------------------------------------------------------------------------
[0.22731 s] [32mkilled[0m by 0-ts/test_bst2.py::test_depth_method

test_bsts = (<bst2.Bst object at 0x7ff227e8df00>, <bst2.Bst object at 0x7ff227e8e3b0>, <bst2.Bst object at 0x7ff227e8ccd0>, <bst2.Bst object at 0x7ff227e8c9a0>, <bst2.Bst object at 0x7ff227e8e770>, <bst2.Bst object at 0x7ff227e8ec20>)

    def test_depth_method(test_bsts):
        """Test depth method."""
        depths = [0, 1, 2, 3, 4, 6]
>       assert all(tree.depth() == depths[idx]
                   for idx, tree in enumerate(test_bsts))
E       AssertionError

0-ts/test_bst2.py:85: AssertionError
[36m   -[0m [# 145] ROR bst2: 
--------------------------------------------------------------------------------
  117:     def search(self, val):
  118:         '''Return the node containing val.'''
  119:         curr = self.root
  120:         while curr:
[34m- 121:             if curr.val == val:[0m
[32m+ 121:             if curr.val != val:[0m
  122:                 return curr
  123:             elif val < curr.val:
  124:                 curr = curr.left
  125:             else:
--------------------------------------------------------------------------------
[0.21745 s] [32mkilled[0m by 0-ts/test_bst2.py::test_contains_method_no_val

test_bsts = (<bst2.Bst object at 0x7ff227f9ff70>, <bst2.Bst object at 0x7ff2280d40d0>, <bst2.Bst object at 0x7ff2280d4970>, <bst2.Bst object at 0x7ff2280d52d0>, <bst2.Bst object at 0x7ff227c47eb0>, <bst2.Bst object at 0x7ff227c447f0>)

    def test_contains_method_no_val(test_bsts):
        """Test contains that doesnt exist."""
>       assert not test_bsts[4].contains(10)
E       AssertionError

0-ts/test_bst2.py:79: AssertionError
[36m   -[0m [# 146] ROR bst2: 
--------------------------------------------------------------------------------
  119:         curr = self.root
  120:         while curr:
  121:             if curr.val == val:
  122:                 return curr
[34m- 123:             elif val < curr.val:[0m
[32m+ 123:             elif val > curr.val:[0m
  124:                 curr = curr.left
  125:             else:
  126:                 curr = curr.right
  127:     
--------------------------------------------------------------------------------
[0.21315 s] [32mkilled[0m by 0-ts/test_bst2.py::test_contains_method

test_bsts = (<bst2.Bst object at 0x7ff227dae110>, <bst2.Bst object at 0x7ff227dadba0>, <bst2.Bst object at 0x7ff227dad420>, <bst2.Bst object at 0x7ff227dac310>, <bst2.Bst object at 0x7ff227dafe20>, <bst2.Bst object at 0x7ff227daefb0>)

    def test_contains_method(test_bsts):
        """Test contains on number that exists."""
        assert test_bsts[2].contains(5)
>       assert test_bsts[2].contains(3)
E       AssertionError

0-ts/test_bst2.py:73: AssertionError
[36m   -[0m [# 147] ROR bst2: 
--------------------------------------------------------------------------------
  119:         curr = self.root
  120:         while curr:
  121:             if curr.val == val:
  122:                 return curr
[34m- 123:             elif val < curr.val:[0m
[32m+ 123:             elif val <= curr.val:[0m
  124:                 curr = curr.left
  125:             else:
  126:                 curr = curr.right
  127:     
--------------------------------------------------------------------------------
[0.25221 s] [31msurvived[0m
[36m   -[0m [# 148] ROR bst2: 
--------------------------------------------------------------------------------
  156:         return leftbranch - rightbranch
  157:     
  158:     def pre_order(self, node='root'):
  159:         '''Depth first pre-order traversal of tree.'''
[34m- 160:         if node == 'root':[0m
[32m+ 160:         if node != 'root':[0m
  161:             node = self.root
  162:         
  163:         if not node:
  164:             return
--------------------------------------------------------------------------------
[0.23666 s] [32mkilled[0m by 0-ts/test_bst2.py::test_pre_order

test_traversals = {'breadth': ['F', 'B', 'G', 'A', 'D', 'I', ...], 'empty': <bst2.Bst object at 0x7ff2281bbd90>, 'in_order': ['A', 'B', 'C', 'D', 'E', 'F', ...], 'post_order': ['A', 'C', 'E', 'D', 'B', 'H', ...], ...}

    def test_pre_order(test_traversals):
        """Test preorder for a traversal."""
>       path = [i for i in test_traversals['tree'].pre_order()]

0-ts/test_bst2.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
0-ts/test_bst2.py:103: in <listcomp>
    path = [i for i in test_traversals['tree'].pre_order()]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x7ff2281bb8e0>, node = 'root'

>   ???
E   AttributeError: 'str' object has no attribute 'val'

bst2:166: AttributeError
[36m   -[0m [# 149] ROR bst2: 
--------------------------------------------------------------------------------
  171:             yield n
  172:     
  173:     def in_order(self, node='root'):
  174:         '''Depth first in-order traversal of tree.'''
[34m- 175:         if node == 'root':[0m
[32m+ 175:         if node != 'root':[0m
  176:             node = self.root
  177:         
  178:         if not node:
  179:             return
--------------------------------------------------------------------------------
[0.41010 s] [32mkilled[0m by 0-ts/test_bst2.py::test_in_order

test_traversals = {'breadth': ['F', 'B', 'G', 'A', 'D', 'I', ...], 'empty': <bst2.Bst object at 0x7ff2282142e0>, 'in_order': ['A', 'B', 'C', 'D', 'E', 'F', ...], 'post_order': ['A', 'C', 'E', 'D', 'B', 'H', ...], ...}

    def test_in_order(test_traversals):
        """Test inorder for a traversal."""
>       path = [i for i in test_traversals['tree'].in_order()]

0-ts/test_bst2.py:109: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
0-ts/test_bst2.py:109: in <listcomp>
    path = [i for i in test_traversals['tree'].in_order()]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x7ff228214520>, node = 'root'

>   ???
E   AttributeError: 'str' object has no attribute 'left'

bst2:181: AttributeError
[36m   -[0m [# 150] ROR bst2: 
--------------------------------------------------------------------------------
  185:             yield n
  186:     
  187:     def post_order(self, node='root'):
  188:         '''Depth frist post_order traversal of tree.'''
[34m- 189:         if node == 'root':[0m
[32m+ 189:         if node != 'root':[0m
  190:             node = self.root
  191:         
  192:         if not node:
  193:             return
--------------------------------------------------------------------------------
[0.26294 s] [32mkilled[0m by 0-ts/test_bst2.py::test_post_order

test_traversals = {'breadth': ['F', 'B', 'G', 'A', 'D', 'I', ...], 'empty': <bst2.Bst object at 0x7ff227d74b50>, 'in_order': ['A', 'B', 'C', 'D', 'E', 'F', ...], 'post_order': ['A', 'C', 'E', 'D', 'B', 'H', ...], ...}

    def test_post_order(test_traversals):
        """Test postorder for a traversal."""
>       path = [i for i in test_traversals['tree'].post_order()]

0-ts/test_bst2.py:115: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
0-ts/test_bst2.py:115: in <listcomp>
    path = [i for i in test_traversals['tree'].post_order()]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x7ff2282dac80>, node = 'root'

>   ???
E   AttributeError: 'str' object has no attribute 'left'

bst2:195: AttributeError
[36m   -[0m [# 151] ROR bst2: 
--------------------------------------------------------------------------------
  211:                 q.enqueue(node.right)
  212:     
  213:     def delete(self, val):
  214:         '''Remove a node from the tree.'''
[34m- 215:         if (self._size < 1 or not (self.contains(val))):[0m
[32m+ 215:         if (self._size > 1 or not (self.contains(val))):[0m
  216:             return
  217:         
  218:         node = self.search(val)
  219:         
--------------------------------------------------------------------------------
[0.28623 s] [32mkilled[0m by 0-ts/test_bst2.py::test_remove_leaf_left

test_bsts = (<bst2.Bst object at 0x7ff22827b370>, <bst2.Bst object at 0x7ff22827afe0>, <bst2.Bst object at 0x7ff228278e80>, <bst2.Bst object at 0x7ff228278070>, <bst2.Bst object at 0x7ff22827a800>, <bst2.Bst object at 0x7ff228279750>)

    def test_remove_leaf_left(test_bsts):
        """Test delete leaf on left."""
        test_bsts[2].delete(3)
>       assert not test_bsts[2].contains(3)
E       AssertionError

0-ts/test_bst2.py:147: AssertionError
[36m   -[0m [# 152] ROR bst2: 
--------------------------------------------------------------------------------
  211:                 q.enqueue(node.right)
  212:     
  213:     def delete(self, val):
  214:         '''Remove a node from the tree.'''
[34m- 215:         if (self._size < 1 or not (self.contains(val))):[0m
[32m+ 215:         if (self._size <= 1 or not (self.contains(val))):[0m
  216:             return
  217:         
  218:         node = self.search(val)
  219:         
--------------------------------------------------------------------------------
[0.25449 s] [32mkilled[0m by 0-ts/test_bst2.py::test_remove_leaf_root

test_bsts = (<bst2.Bst object at 0x7ff227e69de0>, <bst2.Bst object at 0x7ff227e68a60>, <bst2.Bst object at 0x7ff227e6b370>, <bst2.Bst object at 0x7ff227e6a560>, <bst2.Bst object at 0x7ff227e693c0>, <bst2.Bst object at 0x7ff227df1e10>)

    def test_remove_leaf_root(test_bsts):
        """Test delete leaf that is root."""
        test_bsts[1].delete(5)
>       assert not test_bsts[1].contains(5)
E       AssertionError

0-ts/test_bst2.py:161: AssertionError
[36m   -[0m [# 153] ROR bst2: 
--------------------------------------------------------------------------------
  244:         if node.right:
  245:             return self._findmin(node.right)
  246:         
  247:         elif node.parent:
[34m- 248:             if node._side() == 'left':[0m
[32m+ 248:             if node._side() != 'left':[0m
  249:                 return self.parent
  250:             else:
  251:                 node.parent.right = None
  252:                 tmp = self._find_replacement(node.parent)
--------------------------------------------------------------------------------
[0.22434 s] [31msurvived[0m
[36m   -[0m [# 154] SDI bst2: 
--------------------------------------------------------------------------------
    5: 
    6: class Node(object):
    7:     '''Node, or leaf of the BST.'''
    8:     
[34m-   9:     def __init__(self, val=None, parent=None):[0m
[34m-  10:         '''Create node object.'''[0m
[34m-  11:         self.val = val[0m
[34m-  12:         self.right = None[0m
[34m-  13:         self.left = None[0m
[34m-  14:         self.parent = parent[0m
[34m-  15:         self.height = 1[0m
[34m-  16:     [0m
[32m+   9:     @staticmethod[0m
[32m+  10:     def __init__(self, val=None, parent=None):[0m
[32m+  11:         '''Create node object.'''[0m
[32m+  12:         self.val = val[0m
[32m+  13:         self.right = None[0m
[32m+  14:         self.left = None[0m
[32m+  15:         self.parent = parent[0m
[32m+  16:         self.height = 1[0m
   17:     def _is_leaf(self):
   18:         '''Return true if a leaf.'''
   19:         return not ((self.right or self.left))
   20:     
--------------------------------------------------------------------------------
[0.22163 s] [32mkilled[0m by 0-ts/test_bst2.py::test_node_is_leaf

@pytest.fixture
    def test_bsts():
        """Fixture for bst."""
        from bst2 import Bst
        empty = Bst()
>       one = Bst([5])

0-ts/test_bst2.py:11: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
bst2:85: in __init__
    ???
bst2:90: in insert
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = 5, val = None, parent = None

>   ???
E   AttributeError: 'int' object has no attribute 'val'

bst2:12: AttributeError
[36m   -[0m [# 155] SDI bst2: 
--------------------------------------------------------------------------------
   13:         self.left = None
   14:         self.parent = parent
   15:         self.height = 1
   16:     
[34m-  17:     def _is_leaf(self):[0m
[34m-  18:         '''Return true if a leaf.'''[0m
[34m-  19:         return not ((self.right or self.left))[0m
[34m-  20:     [0m
[32m+  17:     @staticmethod[0m
[32m+  18:     def _is_leaf(self):[0m
[32m+  19:         '''Return true if a leaf.'''[0m
[32m+  20:         return not ((self.right or self.left))[0m
   21:     def _is_interior(self):
   22:         '''Return true if a interior node.'''
   23:         return (self.right and self.left)
   24:     
--------------------------------------------------------------------------------
[0.25258 s] [36mincompetent[0m

TypeError: /home/lucca/desktop/ic/experimento/testes/python_experiments2/bst2/0-ts/test_bst2.py:36: TypeError: Node._is_leaf() missing 1 required positional argument: 'self'

[36m   -[0m [# 156] SDI bst2: 
--------------------------------------------------------------------------------
   17:     def _is_leaf(self):
   18:         '''Return true if a leaf.'''
   19:         return not ((self.right or self.left))
   20:     
[34m-  21:     def _is_interior(self):[0m
[34m-  22:         '''Return true if a interior node.'''[0m
[34m-  23:         return (self.right and self.left)[0m
[34m-  24:     [0m
[32m+  21:     @staticmethod[0m
[32m+  22:     def _is_interior(self):[0m
[32m+  23:         '''Return true if a interior node.'''[0m
[32m+  24:         return (self.right and self.left)[0m
   25:     def _onlychild(self):
   26:         '''Return string depending on children.'''
   27:         if (self.left and not (self.right)):
   28:             return 'left'
--------------------------------------------------------------------------------
[0.25526 s] [36mincompetent[0m

TypeError: bst2:226: TypeError: Node._is_interior() missing 1 required positional argument: 'self'

[36m   -[0m [# 157] SDI bst2: 
--------------------------------------------------------------------------------
   21:     def _is_interior(self):
   22:         '''Return true if a interior node.'''
   23:         return (self.right and self.left)
   24:     
[34m-  25:     def _onlychild(self):[0m
[34m-  26:         '''Return string depending on children.'''[0m
[34m-  27:         if (self.left and not (self.right)):[0m
[34m-  28:             return 'left'[0m
[34m-  29:         if (self.right and not (self.left)):[0m
[34m-  30:             return 'right'[0m
[34m-  31:     [0m
[32m+  25:     @staticmethod[0m
[32m+  26:     def _onlychild(self):[0m
[32m+  27:         '''Return string depending on children.'''[0m
[32m+  28:         if (self.left and not (self.right)):[0m
[32m+  29:             return 'left'[0m
[32m+  30:         if (self.right and not (self.left)):[0m
[32m+  31:             return 'right'[0m
   32:     def _side(self):
   33:         '''Return if left or right child of parent.'''
   34:         if self.parent:
   35:             return 'left' if self.parent.left == self else 'right'
--------------------------------------------------------------------------------
[0.25762 s] [36mincompetent[0m

TypeError: bst2:233: TypeError: Node._onlychild() missing 1 required positional argument: 'self'

[36m   -[0m [# 158] SDI bst2: 
--------------------------------------------------------------------------------
   28:             return 'left'
   29:         if (self.right and not (self.left)):
   30:             return 'right'
   31:     
[34m-  32:     def _side(self):[0m
[34m-  33:         '''Return if left or right child of parent.'''[0m
[34m-  34:         if self.parent:[0m
[34m-  35:             return 'left' if self.parent.left == self else 'right'[0m
[34m-  36: [0m
[32m+  32:     @staticmethod[0m
[32m+  33:     def _side(self):[0m
[32m+  34:         '''Return if left or right child of parent.'''[0m
[32m+  35:         if self.parent:[0m
[32m+  36:             return 'left' if self.parent.left == self else 'right'[0m
   37: 
   38: class Bst(object):
   39:     '''Binary Search Tree.
   40: 
--------------------------------------------------------------------------------
[0.36423 s] [36mincompetent[0m

TypeError: bst2:222: TypeError: Node._side() missing 1 required positional argument: 'self'

[36m   -[0m [# 159] SDI bst2: 
--------------------------------------------------------------------------------
   74:     using breadth frist traversal, one at a time.
   75: 
   76:     '''
   77:     
[34m-  78:     def __init__(self, data=None):[0m
[34m-  79:         '''Initialize tree.'''[0m
[34m-  80:         self._size = 0[0m
[34m-  81:         self.root = None[0m
[34m-  82:         [0m
[34m-  83:         if data:[0m
[34m-  84:             for i in data:[0m
[34m-  85:                 self.insert(i)[0m
[34m-  86:     [0m
[32m+  78:     @staticmethod[0m
[32m+  79:     def __init__(self, data=None):[0m
[32m+  80:         '''Initialize tree.'''[0m
[32m+  81:         self._size = 0[0m
[32m+  82:         self.root = None[0m
[32m+  83:         [0m
[32m+  84:         if data:[0m
[32m+  85:             for i in data:[0m
[32m+  86:                 self.insert(i)[0m
   87:     def insert(self, val):
   88:         '''Insert val into BST. If val is already present will be ignored.'''
   89:         if not (self.root):
   90:             self.root = Node(val)
--------------------------------------------------------------------------------
[0.22550 s] [36mincompetent[0m

TypeError: /home/lucca/desktop/ic/experimento/testes/python_experiments2/bst2/0-ts/test_bst2.py:10: TypeError: Bst.__init__() missing 1 required positional argument: 'self'

[36m   -[0m [# 160] SDI bst2: 
--------------------------------------------------------------------------------
   83:         if data:
   84:             for i in data:
   85:                 self.insert(i)
   86:     
[34m-  87:     def insert(self, val):[0m
[34m-  88:         '''Insert val into BST. If val is already present will be ignored.'''[0m
[34m-  89:         if not (self.root):[0m
[34m-  90:             self.root = Node(val)[0m
[34m-  91:             self._size += 1[0m
[34m-  92:         else:[0m
[34m-  93:             self._step(val, self.root)[0m
[34m-  94:     [0m
[32m+  87:     @staticmethod[0m
[32m+  88:     def insert(self, val):[0m
[32m+  89:         '''Insert val into BST. If val is already present will be ignored.'''[0m
[32m+  90:         if not (self.root):[0m
[32m+  91:             self.root = Node(val)[0m
[32m+  92:             self._size += 1[0m
[32m+  93:         else:[0m
[32m+  94:             self._step(val, self.root)[0m
   95:     def _step(self, val, curr):
   96:         '''Decide left or right and returns height.'''
   97:         if val < curr.val:
   98:             curr = self._set_child(curr, 'left', val)
--------------------------------------------------------------------------------
[0.22765 s] [36mincompetent[0m

TypeError: bst2:85: TypeError: Bst.insert() missing 1 required positional argument: 'val'

[36m   -[0m [# 161] SDI bst2: 
--------------------------------------------------------------------------------
   91:             self._size += 1
   92:         else:
   93:             self._step(val, self.root)
   94:     
[34m-  95:     def _step(self, val, curr):[0m
[34m-  96:         '''Decide left or right and returns height.'''[0m
[34m-  97:         if val < curr.val:[0m
[34m-  98:             curr = self._set_child(curr, 'left', val)[0m
[34m-  99:         elif val > curr.val:[0m
[34m- 100:             curr = self._set_child(curr, 'right', val)[0m
[34m- 101:         return curr.height[0m
[34m- 102:     [0m
[32m+  95:     @staticmethod[0m
[32m+  96:     def _step(self, val, curr):[0m
[32m+  97:         '''Decide left or right and returns height.'''[0m
[32m+  98:         if val < curr.val:[0m
[32m+  99:             curr = self._set_child(curr, 'left', val)[0m
[32m+ 100:         elif val > curr.val:[0m
[32m+ 101:             curr = self._set_child(curr, 'right', val)[0m
[32m+ 102:         return curr.height[0m
  103:     def _set_child(self, curr, side, val):
  104:         '''Helping.'''
  105:         child = getattr(curr, side)
  106:         if child:
--------------------------------------------------------------------------------
[0.20827 s] [36mincompetent[0m

TypeError: bst2:93: TypeError: Bst._step() missing 1 required positional argument: 'curr'

[36m   -[0m [# 162] SDI bst2: 
--------------------------------------------------------------------------------
   99:         elif val > curr.val:
  100:             curr = self._set_child(curr, 'right', val)
  101:         return curr.height
  102:     
[34m- 103:     def _set_child(self, curr, side, val):[0m
[34m- 104:         '''Helping.'''[0m
[34m- 105:         child = getattr(curr, side)[0m
[34m- 106:         if child:[0m
[34m- 107:             count = self._step(val, child)[0m
[34m- 108:             if curr.height <= count:[0m
[34m- 109:                 curr.height += 1[0m
[34m- 110:         else:[0m
[34m- 111:             setattr(curr, side, Node(val, curr))[0m
[34m- 112:             self._size += 1[0m
[34m- 113:             if curr.height == 1:[0m
[34m- 114:                 curr.height += 1[0m
[34m- 115:         return curr[0m
[34m- 116:     [0m
[32m+ 103:     @staticmethod[0m
[32m+ 104:     def _set_child(self, curr, side, val):[0m
[32m+ 105:         '''Helping.'''[0m
[32m+ 106:         child = getattr(curr, side)[0m
[32m+ 107:         if child:[0m
[32m+ 108:             count = self._step(val, child)[0m
[32m+ 109:             if curr.height <= count:[0m
[32m+ 110:                 curr.height += 1[0m
[32m+ 111:         else:[0m
[32m+ 112:             setattr(curr, side, Node(val, curr))[0m
[32m+ 113:             self._size += 1[0m
[32m+ 114:             if curr.height == 1:[0m
[32m+ 115:                 curr.height += 1[0m
[32m+ 116:         return curr[0m
  117:     def search(self, val):
  118:         '''Return the node containing val.'''
  119:         curr = self.root
  120:         while curr:
--------------------------------------------------------------------------------
[0.41360 s] [36mincompetent[0m

TypeError: bst2:98: TypeError: Bst._set_child() missing 1 required positional argument: 'val'

[36m   -[0m [# 163] SDI bst2: 
--------------------------------------------------------------------------------
  113:             if curr.height == 1:
  114:                 curr.height += 1
  115:         return curr
  116:     
[34m- 117:     def search(self, val):[0m
[34m- 118:         '''Return the node containing val.'''[0m
[34m- 119:         curr = self.root[0m
[34m- 120:         while curr:[0m
[34m- 121:             if curr.val == val:[0m
[34m- 122:                 return curr[0m
[34m- 123:             elif val < curr.val:[0m
[34m- 124:                 curr = curr.left[0m
[34m- 125:             else:[0m
[34m- 126:                 curr = curr.right[0m
[34m- 127:     [0m
[32m+ 117:     @staticmethod[0m
[32m+ 118:     def search(self, val):[0m
[32m+ 119:         '''Return the node containing val.'''[0m
[32m+ 120:         curr = self.root[0m
[32m+ 121:         while curr:[0m
[32m+ 122:             if curr.val == val:[0m
[32m+ 123:                 return curr[0m
[32m+ 124:             elif val < curr.val:[0m
[32m+ 125:                 curr = curr.left[0m
[32m+ 126:             else:[0m
[32m+ 127:                 curr = curr.right[0m
  128:     def size(self):
  129:         '''Return the size of the BST.'''
  130:         return self._size
  131:     
--------------------------------------------------------------------------------
[0.20366 s] [36mincompetent[0m

TypeError: bst2:138: TypeError: Bst.search() missing 1 required positional argument: 'val'

[36m   -[0m [# 164] SDI bst2: 
--------------------------------------------------------------------------------
  124:                 curr = curr.left
  125:             else:
  126:                 curr = curr.right
  127:     
[34m- 128:     def size(self):[0m
[34m- 129:         '''Return the size of the BST.'''[0m
[34m- 130:         return self._size[0m
[34m- 131:     [0m
[32m+ 128:     @staticmethod[0m
[32m+ 129:     def size(self):[0m
[32m+ 130:         '''Return the size of the BST.'''[0m
[32m+ 131:         return self._size[0m
  132:     def depth(self):
  133:         '''Return depth of the BST, representing total levels.'''
  134:         return 0 if not (self.root) else self.root.height
  135:     
--------------------------------------------------------------------------------
[0.19505 s] [36mincompetent[0m

TypeError: /home/lucca/desktop/ic/experimento/testes/python_experiments2/bst2/0-ts/test_bst2.py:67: TypeError: Bst.size() missing 1 required positional argument: 'self'

[36m   -[0m [# 165] SDI bst2: 
--------------------------------------------------------------------------------
  128:     def size(self):
  129:         '''Return the size of the BST.'''
  130:         return self._size
  131:     
[34m- 132:     def depth(self):[0m
[34m- 133:         '''Return depth of the BST, representing total levels.'''[0m
[34m- 134:         return 0 if not (self.root) else self.root.height[0m
[34m- 135:     [0m
[32m+ 132:     @staticmethod[0m
[32m+ 133:     def depth(self):[0m
[32m+ 134:         '''Return depth of the BST, representing total levels.'''[0m
[32m+ 135:         return 0 if not (self.root) else self.root.height[0m
  136:     def contains(self, val):
  137:         '''Return true if val is in the bst.'''
  138:         return self.search(val) is not None
  139:     
--------------------------------------------------------------------------------
[0.22552 s] [36mincompetent[0m

TypeError: /home/lucca/desktop/ic/experimento/testes/python_experiments2/bst2/0-ts/test_bst2.py:85: TypeError: Bst.depth() missing 1 required positional argument: 'self'

[36m   -[0m [# 166] SDI bst2: 
--------------------------------------------------------------------------------
  132:     def depth(self):
  133:         '''Return depth of the BST, representing total levels.'''
  134:         return 0 if not (self.root) else self.root.height
  135:     
[34m- 136:     def contains(self, val):[0m
[34m- 137:         '''Return true if val is in the bst.'''[0m
[34m- 138:         return self.search(val) is not None[0m
[34m- 139:     [0m
[32m+ 136:     @staticmethod[0m
[32m+ 137:     def contains(self, val):[0m
[32m+ 138:         '''Return true if val is in the bst.'''[0m
[32m+ 139:         return self.search(val) is not None[0m
  140:     def balance(self, tree=None):
  141:         '''Return an integer of how well the tree is balanced.
  142: 
  143:         Trees which are higher on the left than the right should return a
--------------------------------------------------------------------------------
[0.23927 s] [36mincompetent[0m

TypeError: /home/lucca/desktop/ic/experimento/testes/python_experiments2/bst2/0-ts/test_bst2.py:72: TypeError: Bst.contains() missing 1 required positional argument: 'val'

[36m   -[0m [# 167] SDI bst2: 
--------------------------------------------------------------------------------
  136:     def contains(self, val):
  137:         '''Return true if val is in the bst.'''
  138:         return self.search(val) is not None
  139:     
[34m- 140:     def balance(self, tree=None):[0m
[34m- 141:         '''Return an integer of how well the tree is balanced.[0m
[34m- 142: [0m
[34m- 143:         Trees which are higher on the left than the right should return a[0m
[34m- 144:         positive value, trees which are higher on the right than the left[0m
[34m- 145:         should return a negative value. An ideally-balanced tree should[0m
[34m- 146:         return 0.[0m
[34m- 147:         '''[0m
[34m- 148:         if not tree:[0m
[34m- 149:             tree = self.root[0m
[34m- 150:             if not tree:[0m
[34m- 151:                 return 0[0m
[34m- 152:         [0m
[34m- 153:         leftbranch = 0 if not (tree.left) else tree.left.height[0m
[34m- 154:         rightbranch = 0 if not (tree.right) else tree.right.height[0m
[34m- 155:         [0m
[34m- 156:         return leftbranch - rightbranch[0m
[34m- 157:     [0m
[32m+ 140:     @staticmethod[0m
[32m+ 141:     def balance(self, tree=None):[0m
[32m+ 142:         '''Return an integer of how well the tree is balanced.[0m
[32m+ 143: [0m
[32m+ 144:         Trees which are higher on the left than the right should return a[0m
[32m+ 145:         positive value, trees which are higher on the right than the left[0m
[32m+ 146:         should return a negative value. An ideally-balanced tree should[0m
[32m+ 147:         return 0.[0m
[32m+ 148:         '''[0m
[32m+ 149:         if not tree:[0m
[32m+ 150:             tree = self.root[0m
[32m+ 151:             if not tree:[0m
[32m+ 152:                 return 0[0m
[32m+ 153:         [0m
[32m+ 154:         leftbranch = 0 if not (tree.left) else tree.left.height[0m
[32m+ 155:         rightbranch = 0 if not (tree.right) else tree.right.height[0m
[32m+ 156:         [0m
[32m+ 157:         return leftbranch - rightbranch[0m
  158:     def pre_order(self, node='root'):
  159:         '''Depth first pre-order traversal of tree.'''
  160:         if node == 'root':
  161:             node = self.root
--------------------------------------------------------------------------------
[0.25117 s] [36mincompetent[0m

TypeError: /home/lucca/desktop/ic/experimento/testes/python_experiments2/bst2/0-ts/test_bst2.py:92: TypeError: Bst.balance() missing 1 required positional argument: 'self'

[36m   -[0m [# 168] SDI bst2: 
--------------------------------------------------------------------------------
  154:         rightbranch = 0 if not (tree.right) else tree.right.height
  155:         
  156:         return leftbranch - rightbranch
  157:     
[34m- 158:     def pre_order(self, node='root'):[0m
[34m- 159:         '''Depth first pre-order traversal of tree.'''[0m
[34m- 160:         if node == 'root':[0m
[34m- 161:             node = self.root[0m
[34m- 162:         [0m
[34m- 163:         if not node:[0m
[34m- 164:             return[0m
[34m- 165:         [0m
[34m- 166:         yield node.val[0m
[34m- 167:         [0m
[34m- 168:         for n in self.pre_order(node=node.left):[0m
[34m- 169:             yield n[0m
[34m- 170:         for n in self.pre_order(node=node.right):[0m
[34m- 171:             yield n[0m
[34m- 172:     [0m
[32m+ 158:     @staticmethod[0m
[32m+ 159:     def pre_order(self, node='root'):[0m
[32m+ 160:         '''Depth first pre-order traversal of tree.'''[0m
[32m+ 161:         if node == 'root':[0m
[32m+ 162:             node = self.root[0m
[32m+ 163:         [0m
[32m+ 164:         if not node:[0m
[32m+ 165:             return[0m
[32m+ 166:         [0m
[32m+ 167:         yield node.val[0m
[32m+ 168:         [0m
[32m+ 169:         for n in self.pre_order(node=node.left):[0m
[32m+ 170:             yield n[0m
[32m+ 171:         for n in self.pre_order(node=node.right):[0m
[32m+ 172:             yield n[0m
  173:     def in_order(self, node='root'):
  174:         '''Depth first in-order traversal of tree.'''
  175:         if node == 'root':
  176:             node = self.root
--------------------------------------------------------------------------------
[0.24205 s] [36mincompetent[0m

TypeError: /home/lucca/desktop/ic/experimento/testes/python_experiments2/bst2/0-ts/test_bst2.py:103: TypeError: Bst.pre_order() missing 1 required positional argument: 'self'

[36m   -[0m [# 169] SDI bst2: 
--------------------------------------------------------------------------------
  169:             yield n
  170:         for n in self.pre_order(node=node.right):
  171:             yield n
  172:     
[34m- 173:     def in_order(self, node='root'):[0m
[34m- 174:         '''Depth first in-order traversal of tree.'''[0m
[34m- 175:         if node == 'root':[0m
[34m- 176:             node = self.root[0m
[34m- 177:         [0m
[34m- 178:         if not node:[0m
[34m- 179:             return[0m
[34m- 180:         [0m
[34m- 181:         for n in self.in_order(node=node.left):[0m
[34m- 182:             yield n[0m
[34m- 183:         yield node.val[0m
[34m- 184:         for n in self.in_order(node=node.right):[0m
[34m- 185:             yield n[0m
[34m- 186:     [0m
[32m+ 173:     @staticmethod[0m
[32m+ 174:     def in_order(self, node='root'):[0m
[32m+ 175:         '''Depth first in-order traversal of tree.'''[0m
[32m+ 176:         if node == 'root':[0m
[32m+ 177:             node = self.root[0m
[32m+ 178:         [0m
[32m+ 179:         if not node:[0m
[32m+ 180:             return[0m
[32m+ 181:         [0m
[32m+ 182:         for n in self.in_order(node=node.left):[0m
[32m+ 183:             yield n[0m
[32m+ 184:         yield node.val[0m
[32m+ 185:         for n in self.in_order(node=node.right):[0m
[32m+ 186:             yield n[0m
  187:     def post_order(self, node='root'):
  188:         '''Depth frist post_order traversal of tree.'''
  189:         if node == 'root':
  190:             node = self.root
--------------------------------------------------------------------------------
[0.25274 s] [36mincompetent[0m

TypeError: /home/lucca/desktop/ic/experimento/testes/python_experiments2/bst2/0-ts/test_bst2.py:109: TypeError: Bst.in_order() missing 1 required positional argument: 'self'

[36m   -[0m [# 170] SDI bst2: 
--------------------------------------------------------------------------------
  183:         yield node.val
  184:         for n in self.in_order(node=node.right):
  185:             yield n
  186:     
[34m- 187:     def post_order(self, node='root'):[0m
[34m- 188:         '''Depth frist post_order traversal of tree.'''[0m
[34m- 189:         if node == 'root':[0m
[34m- 190:             node = self.root[0m
[34m- 191:         [0m
[34m- 192:         if not node:[0m
[34m- 193:             return[0m
[34m- 194:         [0m
[34m- 195:         for n in self.post_order(node=node.left):[0m
[34m- 196:             yield n[0m
[34m- 197:         for n in self.post_order(node=node.right):[0m
[34m- 198:             yield n[0m
[34m- 199:         yield node.val[0m
[34m- 200:     [0m
[32m+ 187:     @staticmethod[0m
[32m+ 188:     def post_order(self, node='root'):[0m
[32m+ 189:         '''Depth frist post_order traversal of tree.'''[0m
[32m+ 190:         if node == 'root':[0m
[32m+ 191:             node = self.root[0m
[32m+ 192:         [0m
[32m+ 193:         if not node:[0m
[32m+ 194:             return[0m
[32m+ 195:         [0m
[32m+ 196:         for n in self.post_order(node=node.left):[0m
[32m+ 197:             yield n[0m
[32m+ 198:         for n in self.post_order(node=node.right):[0m
[32m+ 199:             yield n[0m
[32m+ 200:         yield node.val[0m
  201:     def breadth_first(self):
  202:         '''Breadth first traversal of tree.'''
  203:         q = Queue()
  204:         q.enqueue(self.root)
--------------------------------------------------------------------------------
[0.22403 s] [36mincompetent[0m

TypeError: /home/lucca/desktop/ic/experimento/testes/python_experiments2/bst2/0-ts/test_bst2.py:115: TypeError: Bst.post_order() missing 1 required positional argument: 'self'

[36m   -[0m [# 171] SDI bst2: 
--------------------------------------------------------------------------------
  197:         for n in self.post_order(node=node.right):
  198:             yield n
  199:         yield node.val
  200:     
[34m- 201:     def breadth_first(self):[0m
[34m- 202:         '''Breadth first traversal of tree.'''[0m
[34m- 203:         q = Queue()[0m
[34m- 204:         q.enqueue(self.root)[0m
[34m- 205:         while q.peek():[0m
[34m- 206:             node = q.dequeue()[0m
[34m- 207:             yield node.val[0m
[34m- 208:             if node.left:[0m
[34m- 209:                 q.enqueue(node.left)[0m
[34m- 210:             if node.right:[0m
[34m- 211:                 q.enqueue(node.right)[0m
[34m- 212:     [0m
[32m+ 201:     @staticmethod[0m
[32m+ 202:     def breadth_first(self):[0m
[32m+ 203:         '''Breadth first traversal of tree.'''[0m
[32m+ 204:         q = Queue()[0m
[32m+ 205:         q.enqueue(self.root)[0m
[32m+ 206:         while q.peek():[0m
[32m+ 207:             node = q.dequeue()[0m
[32m+ 208:             yield node.val[0m
[32m+ 209:             if node.left:[0m
[32m+ 210:                 q.enqueue(node.left)[0m
[32m+ 211:             if node.right:[0m
[32m+ 212:                 q.enqueue(node.right)[0m
  213:     def delete(self, val):
  214:         '''Remove a node from the tree.'''
  215:         if (self._size < 1 or not (self.contains(val))):
  216:             return
--------------------------------------------------------------------------------
[0.36230 s] [36mincompetent[0m

TypeError: /home/lucca/desktop/ic/experimento/testes/python_experiments2/bst2/0-ts/test_bst2.py:121: TypeError: Bst.breadth_first() missing 1 required positional argument: 'self'

[36m   -[0m [# 172] SDI bst2: 
--------------------------------------------------------------------------------
  209:                 q.enqueue(node.left)
  210:             if node.right:
  211:                 q.enqueue(node.right)
  212:     
[34m- 213:     def delete(self, val):[0m
[34m- 214:         '''Remove a node from the tree.'''[0m
[34m- 215:         if (self._size < 1 or not (self.contains(val))):[0m
[34m- 216:             return[0m
[34m- 217:         [0m
[34m- 218:         node = self.search(val)[0m
[34m- 219:         [0m
[34m- 220:         if node._is_leaf():[0m
[34m- 221:             if node.parent:[0m
[34m- 222:                 setattr(node.parent, node._side(), None)[0m
[34m- 223:             else:[0m
[34m- 224:                 self.root = None[0m
[34m- 225:         [0m
[34m- 226:         elif node._is_interior():[0m
[34m- 227:             next_node = self._find_replacement(node)[0m
[34m- 228:             self._size += 1[0m
[34m- 229:             self.delete(next_node.val)[0m
[34m- 230:             node.val = next_node.val[0m
[34m- 231:         else:[0m
[34m- 232:             [0m
[34m- 233:             child = getattr(node, node._onlychild())[0m
[34m- 234:             if node.parent:[0m
[34m- 235:                 child.parent = node.parent[0m
[34m- 236:                 setattr(node.parent, node._side(), child)[0m
[34m- 237:             else:[0m
[34m- 238:                 self.root = child[0m
[34m- 239:         [0m
[34m- 240:         self._size -= 1[0m
[34m- 241:     [0m
[32m+ 213:     @staticmethod[0m
[32m+ 214:     def delete(self, val):[0m
[32m+ 215:         '''Remove a node from the tree.'''[0m
[32m+ 216:         if (self._size < 1 or not (self.contains(val))):[0m
[32m+ 217:             return[0m
[32m+ 218:         [0m
[32m+ 219:         node = self.search(val)[0m
[32m+ 220:         [0m
[32m+ 221:         if node._is_leaf():[0m
[32m+ 222:             if node.parent:[0m
[32m+ 223:                 setattr(node.parent, node._side(), None)[0m
[32m+ 224:             else:[0m
[32m+ 225:                 self.root = None[0m
[32m+ 226:         [0m
[32m+ 227:         elif node._is_interior():[0m
[32m+ 228:             next_node = self._find_replacement(node)[0m
[32m+ 229:             self._size += 1[0m
[32m+ 230:             self.delete(next_node.val)[0m
[32m+ 231:             node.val = next_node.val[0m
[32m+ 232:         else:[0m
[32m+ 233:             [0m
[32m+ 234:             child = getattr(node, node._onlychild())[0m
[32m+ 235:             if node.parent:[0m
[32m+ 236:                 child.parent = node.parent[0m
[32m+ 237:                 setattr(node.parent, node._side(), child)[0m
[32m+ 238:             else:[0m
[32m+ 239:                 self.root = child[0m
[32m+ 240:         [0m
[32m+ 241:         self._size -= 1[0m
  242:     def _find_replacement(self, node):
  243:         '''Find left most node of right subtree.'''
  244:         if node.right:
  245:             return self._findmin(node.right)
--------------------------------------------------------------------------------
[0.23000 s] [36mincompetent[0m

TypeError: /home/lucca/desktop/ic/experimento/testes/python_experiments2/bst2/0-ts/test_bst2.py:134: TypeError: Bst.delete() missing 1 required positional argument: 'val'

[36m   -[0m [# 173] SDI bst2: 
--------------------------------------------------------------------------------
  238:                 self.root = child
  239:         
  240:         self._size -= 1
  241:     
[34m- 242:     def _find_replacement(self, node):[0m
[34m- 243:         '''Find left most node of right subtree.'''[0m
[34m- 244:         if node.right:[0m
[34m- 245:             return self._findmin(node.right)[0m
[34m- 246:         [0m
[34m- 247:         elif node.parent:[0m
[34m- 248:             if node._side() == 'left':[0m
[34m- 249:                 return self.parent[0m
[34m- 250:             else:[0m
[34m- 251:                 node.parent.right = None[0m
[34m- 252:                 tmp = self._find_replacement(node.parent)[0m
[34m- 253:                 node.parent.right = node[0m
[34m- 254:                 return tmp[0m
[34m- 255:     [0m
[32m+ 242:     @staticmethod[0m
[32m+ 243:     def _find_replacement(self, node):[0m
[32m+ 244:         '''Find left most node of right subtree.'''[0m
[32m+ 245:         if node.right:[0m
[32m+ 246:             return self._findmin(node.right)[0m
[32m+ 247:         [0m
[32m+ 248:         elif node.parent:[0m
[32m+ 249:             if node._side() == 'left':[0m
[32m+ 250:                 return self.parent[0m
[32m+ 251:             else:[0m
[32m+ 252:                 node.parent.right = None[0m
[32m+ 253:                 tmp = self._find_replacement(node.parent)[0m
[32m+ 254:                 node.parent.right = node[0m
[32m+ 255:                 return tmp[0m
  256:     def _findmin(self, node):
  257:         '''Find min of subtree, Min is always left most node.'''
  258:         while node.left:
  259:             node = node.left
--------------------------------------------------------------------------------
[0.26040 s] [36mincompetent[0m

TypeError: bst2:227: TypeError: Bst._find_replacement() missing 1 required positional argument: 'node'

[36m   -[0m [# 174] SDI bst2: 
--------------------------------------------------------------------------------
  252:                 tmp = self._find_replacement(node.parent)
  253:                 node.parent.right = node
  254:                 return tmp
  255:     
[34m- 256:     def _findmin(self, node):[0m
[34m- 257:         '''Find min of subtree, Min is always left most node.'''[0m
[34m- 258:         while node.left:[0m
[34m- 259:             node = node.left[0m
[34m- 260:         return node[0m
[32m+ 256:     @staticmethod[0m
[32m+ 257:     def _findmin(self, node):[0m
[32m+ 258:         '''Find min of subtree, Min is always left most node.'''[0m
[32m+ 259:         while node.left:[0m
[32m+ 260:             node = node.left[0m
[32m+ 261:         return node[0m
--------------------------------------------------------------------------------
[0.27043 s] [36mincompetent[0m

TypeError: bst2:245: TypeError: Bst._findmin() missing 1 required positional argument: 'node'

[36m   -[0m [# 175] SDL bst2: 
--------------------------------------------------------------------------------
    7:     '''Node, or leaf of the BST.'''
    8:     
    9:     def __init__(self, val=None, parent=None):
   10:         '''Create node object.'''
[34m-  11:         self.val = val[0m
[32m+  11:         pass[0m
   12:         self.right = None
   13:         self.left = None
   14:         self.parent = parent
   15:         self.height = 1
--------------------------------------------------------------------------------
[0.32975 s] [32mkilled[0m by 0-ts/test_bst2.py::test_node_is_leaf

@pytest.fixture
    def test_bsts():
        """Fixture for bst."""
        from bst2 import Bst
        empty = Bst()
        one = Bst([5])
>       three = Bst([5, 3, 7])

0-ts/test_bst2.py:12: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
bst2:85: in __init__
    ???
bst2:93: in insert
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x7ff227d0b670>, val = 3
curr = <bst2.Node object at 0x7ff227d0beb0>

>   ???
E   AttributeError: 'Node' object has no attribute 'val'

bst2:97: AttributeError
[36m   -[0m [# 176] SDL bst2: 
--------------------------------------------------------------------------------
    8:     
    9:     def __init__(self, val=None, parent=None):
   10:         '''Create node object.'''
   11:         self.val = val
[34m-  12:         self.right = None[0m
[32m+  12:         pass[0m
   13:         self.left = None
   14:         self.parent = parent
   15:         self.height = 1
   16:     
--------------------------------------------------------------------------------
[0.21415 s] [32mkilled[0m by 0-ts/test_bst2.py::test_node_is_leaf

@pytest.fixture
    def test_bsts():
        """Fixture for bst."""
        from bst2 import Bst
        empty = Bst()
        one = Bst([5])
>       three = Bst([5, 3, 7])

0-ts/test_bst2.py:12: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
bst2:85: in __init__
    ???
bst2:93: in insert
    ???
bst2:100: in _step
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x7ff22815d6f0>
curr = <bst2.Node object at 0x7ff22815f4c0>, side = 'right', val = 7

>   ???
E   AttributeError: 'Node' object has no attribute 'right'

bst2:105: AttributeError
[36m   -[0m [# 177] SDL bst2: 
--------------------------------------------------------------------------------
    9:     def __init__(self, val=None, parent=None):
   10:         '''Create node object.'''
   11:         self.val = val
   12:         self.right = None
[34m-  13:         self.left = None[0m
[32m+  13:         pass[0m
   14:         self.parent = parent
   15:         self.height = 1
   16:     
   17:     def _is_leaf(self):
--------------------------------------------------------------------------------
[0.21285 s] [32mkilled[0m by 0-ts/test_bst2.py::test_node_is_leaf

@pytest.fixture
    def test_bsts():
        """Fixture for bst."""
        from bst2 import Bst
        empty = Bst()
        one = Bst([5])
>       three = Bst([5, 3, 7])

0-ts/test_bst2.py:12: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
bst2:85: in __init__
    ???
bst2:93: in insert
    ???
bst2:98: in _step
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x7ff22820a620>
curr = <bst2.Node object at 0x7ff22820ac50>, side = 'left', val = 3

>   ???
E   AttributeError: 'Node' object has no attribute 'left'

bst2:105: AttributeError
[36m   -[0m [# 178] SDL bst2: 
--------------------------------------------------------------------------------
   10:         '''Create node object.'''
   11:         self.val = val
   12:         self.right = None
   13:         self.left = None
[34m-  14:         self.parent = parent[0m
[32m+  14:         pass[0m
   15:         self.height = 1
   16:     
   17:     def _is_leaf(self):
   18:         '''Return true if a leaf.'''
--------------------------------------------------------------------------------
[0.21557 s] [32mkilled[0m by 0-ts/test_bst2.py::test_insert_updates_pointers

test_bsts = (<bst2.Bst object at 0x7ff228136c20>, <bst2.Bst object at 0x7ff2281376a0>, <bst2.Bst object at 0x7ff228135120>, <bst2.Bst object at 0x7ff228136cb0>, <bst2.Bst object at 0x7ff228136e00>, <bst2.Bst object at 0x7ff228134a60>)

    def test_insert_updates_pointers(test_bsts):
        """Test insert updates pointers."""
        test_bsts[1].insert(3)
        assert test_bsts[1].root.left.val == 3
>       assert test_bsts[1].root.left.parent == test_bsts[1].root
E       AttributeError: 'Node' object has no attribute 'parent'

0-ts/test_bst2.py:49: AttributeError
[36m   -[0m [# 179] SDL bst2: 
--------------------------------------------------------------------------------
   11:         self.val = val
   12:         self.right = None
   13:         self.left = None
   14:         self.parent = parent
[34m-  15:         self.height = 1[0m
[32m+  15:         pass[0m
   16:     
   17:     def _is_leaf(self):
   18:         '''Return true if a leaf.'''
   19:         return not ((self.right or self.left))
--------------------------------------------------------------------------------
[0.21023 s] [32mkilled[0m by 0-ts/test_bst2.py::test_node_is_leaf

@pytest.fixture
    def test_bsts():
        """Fixture for bst."""
        from bst2 import Bst
        empty = Bst()
        one = Bst([5])
>       three = Bst([5, 3, 7])

0-ts/test_bst2.py:12: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
bst2:85: in __init__
    ???
bst2:93: in insert
    ???
bst2:98: in _step
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x7ff2280ecd30>
curr = <bst2.Node object at 0x7ff2280edf90>, side = 'left', val = 3

>   ???
E   AttributeError: 'Node' object has no attribute 'height'

bst2:113: AttributeError
[36m   -[0m [# 180] SDL bst2: 
--------------------------------------------------------------------------------
   15:         self.height = 1
   16:     
   17:     def _is_leaf(self):
   18:         '''Return true if a leaf.'''
[34m-  19:         return not ((self.right or self.left))[0m
[32m+  19:         pass[0m
   20:     
   21:     def _is_interior(self):
   22:         '''Return true if a interior node.'''
   23:         return (self.right and self.left)
--------------------------------------------------------------------------------
[0.35797 s] [32mkilled[0m by 0-ts/test_bst2.py::test_node_is_leaf

test_bsts = (<bst2.Bst object at 0x7ff228269150>, <bst2.Bst object at 0x7ff228269f90>, <bst2.Bst object at 0x7ff22826b820>, <bst2.Bst object at 0x7ff22826af20>, <bst2.Bst object at 0x7ff228269930>, <bst2.Bst object at 0x7ff228269480>)

    def test_node_is_leaf(test_bsts):
        """Test node is leaf bst."""
>       assert test_bsts[1].root._is_leaf()
E       AssertionError

0-ts/test_bst2.py:36: AssertionError
[36m   -[0m [# 181] SDL bst2: 
--------------------------------------------------------------------------------
   19:         return not ((self.right or self.left))
   20:     
   21:     def _is_interior(self):
   22:         '''Return true if a interior node.'''
[34m-  23:         return (self.right and self.left)[0m
[32m+  23:         pass[0m
   24:     
   25:     def _onlychild(self):
   26:         '''Return string depending on children.'''
   27:         if (self.left and not (self.right)):
--------------------------------------------------------------------------------
[0.24139 s] [36mincompetent[0m

TypeError: bst2:233: TypeError: getattr(): attribute name must be string

[36m   -[0m [# 182] SDL bst2: 
--------------------------------------------------------------------------------
   24:     
   25:     def _onlychild(self):
   26:         '''Return string depending on children.'''
   27:         if (self.left and not (self.right)):
[34m-  28:             return 'left'[0m
[32m+  28:             pass[0m
   29:         if (self.right and not (self.left)):
   30:             return 'right'
   31:     
   32:     def _side(self):
--------------------------------------------------------------------------------
[0.24596 s] [36mincompetent[0m

TypeError: bst2:233: TypeError: getattr(): attribute name must be string

[36m   -[0m [# 183] SDL bst2: 
--------------------------------------------------------------------------------
   26:         '''Return string depending on children.'''
   27:         if (self.left and not (self.right)):
   28:             return 'left'
   29:         if (self.right and not (self.left)):
[34m-  30:             return 'right'[0m
[32m+  30:             pass[0m
   31:     
   32:     def _side(self):
   33:         '''Return if left or right child of parent.'''
   34:         if self.parent:
--------------------------------------------------------------------------------
[0.25764 s] [36mincompetent[0m

TypeError: bst2:233: TypeError: getattr(): attribute name must be string

[36m   -[0m [# 184] SDL bst2: 
--------------------------------------------------------------------------------
   31:     
   32:     def _side(self):
   33:         '''Return if left or right child of parent.'''
   34:         if self.parent:
[34m-  35:             return 'left' if self.parent.left == self else 'right'[0m
[32m+  35:             pass[0m
   36: 
   37: 
   38: class Bst(object):
   39:     '''Binary Search Tree.
--------------------------------------------------------------------------------
[0.28636 s] [36mincompetent[0m

TypeError: bst2:222: TypeError: attribute name must be string, not 'NoneType'

[36m   -[0m [# 185] SDL bst2: 
--------------------------------------------------------------------------------
   76:     '''
   77:     
   78:     def __init__(self, data=None):
   79:         '''Initialize tree.'''
[34m-  80:         self._size = 0[0m
[32m+  80:         pass[0m
   81:         self.root = None
   82:         
   83:         if data:
   84:             for i in data:
--------------------------------------------------------------------------------
[0.22442 s] [32mkilled[0m by 0-ts/test_bst2.py::test_node_is_leaf

@pytest.fixture
    def test_bsts():
        """Fixture for bst."""
        from bst2 import Bst
        empty = Bst()
>       one = Bst([5])

0-ts/test_bst2.py:11: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
bst2:85: in __init__
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x7ff228348e50>, val = 5

>   ???
E   AttributeError: 'Bst' object has no attribute '_size'

bst2:91: AttributeError
[36m   -[0m [# 186] SDL bst2: 
--------------------------------------------------------------------------------
   77:     
   78:     def __init__(self, data=None):
   79:         '''Initialize tree.'''
   80:         self._size = 0
[34m-  81:         self.root = None[0m
[32m+  81:         pass[0m
   82:         
   83:         if data:
   84:             for i in data:
   85:                 self.insert(i)
--------------------------------------------------------------------------------
[0.21141 s] [32mkilled[0m by 0-ts/test_bst2.py::test_node_is_leaf

@pytest.fixture
    def test_bsts():
        """Fixture for bst."""
        from bst2 import Bst
        empty = Bst()
>       one = Bst([5])

0-ts/test_bst2.py:11: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
bst2:85: in __init__
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x7ff227aa9ae0>, val = 5

>   ???
E   AttributeError: 'Bst' object has no attribute 'root'

bst2:89: AttributeError
[36m   -[0m [# 187] SDL bst2: 
--------------------------------------------------------------------------------
   81:         self.root = None
   82:         
   83:         if data:
   84:             for i in data:
[34m-  85:                 self.insert(i)[0m
[32m+  85:                 pass[0m
   86:     
   87:     def insert(self, val):
   88:         '''Insert val into BST. If val is already present will be ignored.'''
   89:         if not (self.root):
--------------------------------------------------------------------------------
[0.22078 s] [32mkilled[0m by 0-ts/test_bst2.py::test_node_is_leaf

test_bsts = (<bst2.Bst object at 0x7ff227d40fd0>, <bst2.Bst object at 0x7ff227d41600>, <bst2.Bst object at 0x7ff227d401f0>, <bst2.Bst object at 0x7ff227d436a0>, <bst2.Bst object at 0x7ff227d41390>, <bst2.Bst object at 0x7ff227d41ff0>)

    def test_node_is_leaf(test_bsts):
        """Test node is leaf bst."""
>       assert test_bsts[1].root._is_leaf()
E       AttributeError: 'NoneType' object has no attribute '_is_leaf'

0-ts/test_bst2.py:36: AttributeError
[36m   -[0m [# 188] SDL bst2: 
--------------------------------------------------------------------------------
   86:     
   87:     def insert(self, val):
   88:         '''Insert val into BST. If val is already present will be ignored.'''
   89:         if not (self.root):
[34m-  90:             self.root = Node(val)[0m
[32m+  90:             pass[0m
   91:             self._size += 1
   92:         else:
   93:             self._step(val, self.root)
   94:     
--------------------------------------------------------------------------------
[0.23057 s] [32mkilled[0m by 0-ts/test_bst2.py::test_node_is_leaf

test_bsts = (<bst2.Bst object at 0x7ff227ffce50>, <bst2.Bst object at 0x7ff227ffcf10>, <bst2.Bst object at 0x7ff227ffc460>, <bst2.Bst object at 0x7ff227ffc220>, <bst2.Bst object at 0x7ff227ffc0d0>, <bst2.Bst object at 0x7ff227ffd6f0>)

    def test_node_is_leaf(test_bsts):
        """Test node is leaf bst."""
>       assert test_bsts[1].root._is_leaf()
E       AttributeError: 'NoneType' object has no attribute '_is_leaf'

0-ts/test_bst2.py:36: AttributeError
[36m   -[0m [# 189] SDL bst2: 
--------------------------------------------------------------------------------
   89:         if not (self.root):
   90:             self.root = Node(val)
   91:             self._size += 1
   92:         else:
[34m-  93:             self._step(val, self.root)[0m
[32m+  93:             pass[0m
   94:     
   95:     def _step(self, val, curr):
   96:         '''Decide left or right and returns height.'''
   97:         if val < curr.val:
--------------------------------------------------------------------------------
[0.39505 s] [32mkilled[0m by 0-ts/test_bst2.py::test_insert_updates_pointers

test_bsts = (<bst2.Bst object at 0x7ff227f76890>, <bst2.Bst object at 0x7ff227f74a90>, <bst2.Bst object at 0x7ff227f75ba0>, <bst2.Bst object at 0x7ff227f75ae0>, <bst2.Bst object at 0x7ff227f75e40>, <bst2.Bst object at 0x7ff227f76920>)

    def test_insert_updates_pointers(test_bsts):
        """Test insert updates pointers."""
        test_bsts[1].insert(3)
>       assert test_bsts[1].root.left.val == 3
E       AttributeError: 'NoneType' object has no attribute 'val'

0-ts/test_bst2.py:48: AttributeError
[36m   -[0m [# 190] SDL bst2: 
--------------------------------------------------------------------------------
   94:     
   95:     def _step(self, val, curr):
   96:         '''Decide left or right and returns height.'''
   97:         if val < curr.val:
[34m-  98:             curr = self._set_child(curr, 'left', val)[0m
[32m+  98:             pass[0m
   99:         elif val > curr.val:
  100:             curr = self._set_child(curr, 'right', val)
  101:         return curr.height
  102:     
--------------------------------------------------------------------------------
[0.21828 s] [32mkilled[0m by 0-ts/test_bst2.py::test_insert_updates_pointers

test_bsts = (<bst2.Bst object at 0x7ff227c47100>, <bst2.Bst object at 0x7ff227c463e0>, <bst2.Bst object at 0x7ff227c458a0>, <bst2.Bst object at 0x7ff227c46350>, <bst2.Bst object at 0x7ff227c45b10>, <bst2.Bst object at 0x7ff227c45900>)

    def test_insert_updates_pointers(test_bsts):
        """Test insert updates pointers."""
        test_bsts[1].insert(3)
>       assert test_bsts[1].root.left.val == 3
E       AttributeError: 'NoneType' object has no attribute 'val'

0-ts/test_bst2.py:48: AttributeError
[36m   -[0m [# 191] SDL bst2: 
--------------------------------------------------------------------------------
   96:         '''Decide left or right and returns height.'''
   97:         if val < curr.val:
   98:             curr = self._set_child(curr, 'left', val)
   99:         elif val > curr.val:
[34m- 100:             curr = self._set_child(curr, 'right', val)[0m
[32m+ 100:             pass[0m
  101:         return curr.height
  102:     
  103:     def _set_child(self, curr, side, val):
  104:         '''Helping.'''
--------------------------------------------------------------------------------
[0.22750 s] [32mkilled[0m by 0-ts/test_bst2.py::test_insert_largest_right

test_bsts = (<bst2.Bst object at 0x7ff227eedcf0>, <bst2.Bst object at 0x7ff227eee5c0>, <bst2.Bst object at 0x7ff227eee050>, <bst2.Bst object at 0x7ff227eee6b0>, <bst2.Bst object at 0x7ff227eef370>, <bst2.Bst object at 0x7ff227eeec20>)

    def test_insert_largest_right(test_bsts):
        """Test insert the largest to the right."""
        test_bsts[1].insert(7)
>       assert test_bsts[1].root.right.val > test_bsts[1].root.val
E       AttributeError: 'NoneType' object has no attribute 'val'

0-ts/test_bst2.py:61: AttributeError
[36m   -[0m [# 192] SDL bst2: 
--------------------------------------------------------------------------------
   97:         if val < curr.val:
   98:             curr = self._set_child(curr, 'left', val)
   99:         elif val > curr.val:
  100:             curr = self._set_child(curr, 'right', val)
[34m- 101:         return curr.height[0m
[32m+ 101:         pass[0m
  102:     
  103:     def _set_child(self, curr, side, val):
  104:         '''Helping.'''
  105:         child = getattr(curr, side)
--------------------------------------------------------------------------------
[0.21080 s] [36mincompetent[0m

TypeError: bst2:108: TypeError: '<=' not supported between instances of 'int' and 'NoneType'

[36m   -[0m [# 193] SDL bst2: 
--------------------------------------------------------------------------------
  101:         return curr.height
  102:     
  103:     def _set_child(self, curr, side, val):
  104:         '''Helping.'''
[34m- 105:         child = getattr(curr, side)[0m
[32m+ 105:         pass[0m
  106:         if child:
  107:             count = self._step(val, child)
  108:             if curr.height <= count:
  109:                 curr.height += 1
--------------------------------------------------------------------------------
[0.20535 s] [32mkilled[0m by 0-ts/test_bst2.py::test_node_is_leaf

@pytest.fixture
    def test_bsts():
        """Fixture for bst."""
        from bst2 import Bst
        empty = Bst()
        one = Bst([5])
>       three = Bst([5, 3, 7])

0-ts/test_bst2.py:12: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
bst2:85: in __init__
    ???
bst2:93: in insert
    ???
bst2:98: in _step
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x7ff227de03d0>
curr = <bst2.Node object at 0x7ff227de11e0>, side = 'left', val = 3

>   ???
E   NameError: name 'child' is not defined

bst2:106: NameError
[36m   -[0m [# 194] SDL bst2: 
--------------------------------------------------------------------------------
  103:     def _set_child(self, curr, side, val):
  104:         '''Helping.'''
  105:         child = getattr(curr, side)
  106:         if child:
[34m- 107:             count = self._step(val, child)[0m
[32m+ 107:             pass[0m
  108:             if curr.height <= count:
  109:                 curr.height += 1
  110:         else:
  111:             setattr(curr, side, Node(val, curr))
--------------------------------------------------------------------------------
[0.21306 s] [32mkilled[0m by 0-ts/test_bst2.py::test_node_is_leaf

@pytest.fixture
    def test_bsts():
        """Fixture for bst."""
        from bst2 import Bst
        empty = Bst()
        one = Bst([5])
        three = Bst([5, 3, 7])
>       balance = Bst([5, 3, 2, 4, 9, 7, 10])

0-ts/test_bst2.py:13: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
bst2:85: in __init__
    ???
bst2:93: in insert
    ???
bst2:98: in _step
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x7ff227d66da0>
curr = <bst2.Node object at 0x7ff227d64310>, side = 'left', val = 2

>   ???
E   NameError: name 'count' is not defined

bst2:108: NameError
[36m   -[0m [# 195] SDL bst2: 
--------------------------------------------------------------------------------
  107:             count = self._step(val, child)
  108:             if curr.height <= count:
  109:                 curr.height += 1
  110:         else:
[34m- 111:             setattr(curr, side, Node(val, curr))[0m
[32m+ 111:             pass[0m
  112:             self._size += 1
  113:             if curr.height == 1:
  114:                 curr.height += 1
  115:         return curr
--------------------------------------------------------------------------------
[0.20234 s] [32mkilled[0m by 0-ts/test_bst2.py::test_insert_updates_pointers

test_bsts = (<bst2.Bst object at 0x7ff227f462f0>, <bst2.Bst object at 0x7ff227f44520>, <bst2.Bst object at 0x7ff227f464a0>, <bst2.Bst object at 0x7ff227f451b0>, <bst2.Bst object at 0x7ff227f44130>, <bst2.Bst object at 0x7ff227f44df0>)

    def test_insert_updates_pointers(test_bsts):
        """Test insert updates pointers."""
        test_bsts[1].insert(3)
>       assert test_bsts[1].root.left.val == 3
E       AttributeError: 'NoneType' object has no attribute 'val'

0-ts/test_bst2.py:48: AttributeError
[36m   -[0m [# 196] SDL bst2: 
--------------------------------------------------------------------------------
  111:             setattr(curr, side, Node(val, curr))
  112:             self._size += 1
  113:             if curr.height == 1:
  114:                 curr.height += 1
[34m- 115:         return curr[0m
[32m+ 115:         pass[0m
  116:     
  117:     def search(self, val):
  118:         '''Return the node containing val.'''
  119:         curr = self.root
--------------------------------------------------------------------------------
[0.23039 s] [32mkilled[0m by 0-ts/test_bst2.py::test_node_is_leaf

@pytest.fixture
    def test_bsts():
        """Fixture for bst."""
        from bst2 import Bst
        empty = Bst()
        one = Bst([5])
>       three = Bst([5, 3, 7])

0-ts/test_bst2.py:12: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
bst2:85: in __init__
    ???
bst2:93: in insert
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x7ff227ce27d0>, val = 3, curr = None

>   ???
E   AttributeError: 'NoneType' object has no attribute 'height'

bst2:101: AttributeError
[36m   -[0m [# 197] SDL bst2: 
--------------------------------------------------------------------------------
  115:         return curr
  116:     
  117:     def search(self, val):
  118:         '''Return the node containing val.'''
[34m- 119:         curr = self.root[0m
[32m+ 119:         pass[0m
  120:         while curr:
  121:             if curr.val == val:
  122:                 return curr
  123:             elif val < curr.val:
--------------------------------------------------------------------------------
[0.32100 s] [32mkilled[0m by 0-ts/test_bst2.py::test_contains_method

test_bsts = (<bst2.Bst object at 0x7ff2281bbc70>, <bst2.Bst object at 0x7ff2281b9870>, <bst2.Bst object at 0x7ff2281baec0>, <bst2.Bst object at 0x7ff227e0c4f0>, <bst2.Bst object at 0x7ff227e0c4c0>, <bst2.Bst object at 0x7ff227e0c9d0>)

    def test_contains_method(test_bsts):
        """Test contains on number that exists."""
>       assert test_bsts[2].contains(5)

0-ts/test_bst2.py:72: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
bst2:138: in contains
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x7ff2281baec0>, val = 5

>   ???
E   UnboundLocalError: local variable 'curr' referenced before assignment

bst2:120: UnboundLocalError
[36m   -[0m [# 198] SDL bst2: 
--------------------------------------------------------------------------------
  118:         '''Return the node containing val.'''
  119:         curr = self.root
  120:         while curr:
  121:             if curr.val == val:
[34m- 122:                 return curr[0m
[32m+ 122:                 pass[0m
  123:             elif val < curr.val:
  124:                 curr = curr.left
  125:             else:
  126:                 curr = curr.right
--------------------------------------------------------------------------------
[5.00929 s] [33mtimeout[0m
[36m   -[0m [# 199] SDL bst2: 
--------------------------------------------------------------------------------
  120:         while curr:
  121:             if curr.val == val:
  122:                 return curr
  123:             elif val < curr.val:
[34m- 124:                 curr = curr.left[0m
[32m+ 124:                 pass[0m
  125:             else:
  126:                 curr = curr.right
  127:     
  128:     def size(self):
--------------------------------------------------------------------------------
[5.00840 s] [33mtimeout[0m
[36m   -[0m [# 200] SDL bst2: 
--------------------------------------------------------------------------------
  122:                 return curr
  123:             elif val < curr.val:
  124:                 curr = curr.left
  125:             else:
[34m- 126:                 curr = curr.right[0m
[32m+ 126:                 pass[0m
  127:     
  128:     def size(self):
  129:         '''Return the size of the BST.'''
  130:         return self._size
--------------------------------------------------------------------------------
[5.00797 s] [33mtimeout[0m
[36m   -[0m [# 201] SDL bst2: 
--------------------------------------------------------------------------------
  126:                 curr = curr.right
  127:     
  128:     def size(self):
  129:         '''Return the size of the BST.'''
[34m- 130:         return self._size[0m
[32m+ 130:         pass[0m
  131:     
  132:     def depth(self):
  133:         '''Return depth of the BST, representing total levels.'''
  134:         return 0 if not (self.root) else self.root.height
--------------------------------------------------------------------------------
[0.24478 s] [32mkilled[0m by 0-ts/test_bst2.py::test_insert_increases_size

test_bsts = (<bst2.Bst object at 0x7ff227c5eaa0>, <bst2.Bst object at 0x7ff227c5f7f0>, <bst2.Bst object at 0x7ff227c5eb60>, <bst2.Bst object at 0x7ff227c5e800>, <bst2.Bst object at 0x7ff227c5d8d0>, <bst2.Bst object at 0x7ff227c5da50>)

    def test_insert_increases_size(test_bsts):
        """Test insert increases size."""
        test_bsts[0].insert(4)
>       assert test_bsts[0].size() == 1
E       AssertionError

0-ts/test_bst2.py:67: AssertionError
[36m   -[0m [# 202] SDL bst2: 
--------------------------------------------------------------------------------
  130:         return self._size
  131:     
  132:     def depth(self):
  133:         '''Return depth of the BST, representing total levels.'''
[34m- 134:         return 0 if not (self.root) else self.root.height[0m
[32m+ 134:         pass[0m
  135:     
  136:     def contains(self, val):
  137:         '''Return true if val is in the bst.'''
  138:         return self.search(val) is not None
--------------------------------------------------------------------------------
[0.23106 s] [32mkilled[0m by 0-ts/test_bst2.py::test_depth_method

test_bsts = (<bst2.Bst object at 0x7ff228105210>, <bst2.Bst object at 0x7ff2281055a0>, <bst2.Bst object at 0x7ff228105a50>, <bst2.Bst object at 0x7ff228105d80>, <bst2.Bst object at 0x7ff228105e10>, <bst2.Bst object at 0x7ff2281062c0>)

    def test_depth_method(test_bsts):
        """Test depth method."""
        depths = [0, 1, 2, 3, 4, 6]
>       assert all(tree.depth() == depths[idx]
                   for idx, tree in enumerate(test_bsts))
E       AssertionError

0-ts/test_bst2.py:85: AssertionError
[36m   -[0m [# 203] SDL bst2: 
--------------------------------------------------------------------------------
  134:         return 0 if not (self.root) else self.root.height
  135:     
  136:     def contains(self, val):
  137:         '''Return true if val is in the bst.'''
[34m- 138:         return self.search(val) is not None[0m
[32m+ 138:         pass[0m
  139:     
  140:     def balance(self, tree=None):
  141:         '''Return an integer of how well the tree is balanced.
  142: 
--------------------------------------------------------------------------------
[0.34920 s] [32mkilled[0m by 0-ts/test_bst2.py::test_contains_method

test_bsts = (<bst2.Bst object at 0x7ff227fc4370>, <bst2.Bst object at 0x7ff2280bf160>, <bst2.Bst object at 0x7ff2280bfc70>, <bst2.Bst object at 0x7ff2280be830>, <bst2.Bst object at 0x7ff2280bec50>, <bst2.Bst object at 0x7ff2280bf700>)

    def test_contains_method(test_bsts):
        """Test contains on number that exists."""
>       assert test_bsts[2].contains(5)
E       AssertionError

0-ts/test_bst2.py:72: AssertionError
[36m   -[0m [# 204] SDL bst2: 
--------------------------------------------------------------------------------
  145:         should return a negative value. An ideally-balanced tree should
  146:         return 0.
  147:         '''
  148:         if not tree:
[34m- 149:             tree = self.root[0m
[32m+ 149:             pass[0m
  150:             if not tree:
  151:                 return 0
  152:         
  153:         leftbranch = 0 if not (tree.left) else tree.left.height
--------------------------------------------------------------------------------
[0.23434 s] [32mkilled[0m by 0-ts/test_bst2.py::test_balance_method

test_bsts = (<bst2.Bst object at 0x7ff228278fd0>, <bst2.Bst object at 0x7ff228278c70>, <bst2.Bst object at 0x7ff228279d20>, <bst2.Bst object at 0x7ff22827a170>, <bst2.Bst object at 0x7ff227f25ff0>, <bst2.Bst object at 0x7ff227f26680>)

    def test_balance_method(test_bsts):
        """Test the balance method."""
        balance = [0, 0, 0, 0, 3, -5]
>       assert all(tree.balance() == balance[idx]
                   for idx, tree in enumerate(test_bsts))
E       AssertionError

0-ts/test_bst2.py:92: AssertionError
[36m   -[0m [# 205] SDL bst2: 
--------------------------------------------------------------------------------
  147:         '''
  148:         if not tree:
  149:             tree = self.root
  150:             if not tree:
[34m- 151:                 return 0[0m
[32m+ 151:                 pass[0m
  152:         
  153:         leftbranch = 0 if not (tree.left) else tree.left.height
  154:         rightbranch = 0 if not (tree.right) else tree.right.height
  155:         
--------------------------------------------------------------------------------
[0.25568 s] [32mkilled[0m by 0-ts/test_bst2.py::test_balance_method

test_bsts = (<bst2.Bst object at 0x7ff22811da50>, <bst2.Bst object at 0x7ff22811ca00>, <bst2.Bst object at 0x7ff22811feb0>, <bst2.Bst object at 0x7ff22811f340>, <bst2.Bst object at 0x7ff22811f460>, <bst2.Bst object at 0x7ff22811e920>)

    def test_balance_method(test_bsts):
        """Test the balance method."""
        balance = [0, 0, 0, 0, 3, -5]
>       assert all(tree.balance() == balance[idx]
                   for idx, tree in enumerate(test_bsts))

0-ts/test_bst2.py:92: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
0-ts/test_bst2.py:92: in <genexpr>
    assert all(tree.balance() == balance[idx]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x7ff22811da50>, tree = None

>   ???
E   AttributeError: 'NoneType' object has no attribute 'left'

bst2:153: AttributeError
[36m   -[0m [# 206] SDL bst2: 
--------------------------------------------------------------------------------
  149:             tree = self.root
  150:             if not tree:
  151:                 return 0
  152:         
[34m- 153:         leftbranch = 0 if not (tree.left) else tree.left.height[0m
[32m+ 153:         pass[0m
  154:         rightbranch = 0 if not (tree.right) else tree.right.height
  155:         
  156:         return leftbranch - rightbranch
  157:     
--------------------------------------------------------------------------------
[0.23985 s] [32mkilled[0m by 0-ts/test_bst2.py::test_balance_method

test_bsts = (<bst2.Bst object at 0x7ff227d086d0>, <bst2.Bst object at 0x7ff227d088b0>, <bst2.Bst object at 0x7ff227d08c40>, <bst2.Bst object at 0x7ff227d09150>, <bst2.Bst object at 0x7ff227d094e0>, <bst2.Bst object at 0x7ff227d09990>)

    def test_balance_method(test_bsts):
        """Test the balance method."""
        balance = [0, 0, 0, 0, 3, -5]
>       assert all(tree.balance() == balance[idx]
                   for idx, tree in enumerate(test_bsts))

0-ts/test_bst2.py:92: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
0-ts/test_bst2.py:92: in <genexpr>
    assert all(tree.balance() == balance[idx]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x7ff227d088b0>
tree = <bst2.Node object at 0x7ff227d08c70>

>   ???
E   NameError: name 'leftbranch' is not defined

bst2:156: NameError
[36m   -[0m [# 207] SDL bst2: 
--------------------------------------------------------------------------------
  150:             if not tree:
  151:                 return 0
  152:         
  153:         leftbranch = 0 if not (tree.left) else tree.left.height
[34m- 154:         rightbranch = 0 if not (tree.right) else tree.right.height[0m
[32m+ 154:         pass[0m
  155:         
  156:         return leftbranch - rightbranch
  157:     
  158:     def pre_order(self, node='root'):
--------------------------------------------------------------------------------
[0.42381 s] [32mkilled[0m by 0-ts/test_bst2.py::test_balance_method

test_bsts = (<bst2.Bst object at 0x7ff227ef66b0>, <bst2.Bst object at 0x7ff227ef6b60>, <bst2.Bst object at 0x7ff227ef5a80>, <bst2.Bst object at 0x7ff227ef5030>, <bst2.Bst object at 0x7ff227ef6f20>, <bst2.Bst object at 0x7ff227ef73d0>)

    def test_balance_method(test_bsts):
        """Test the balance method."""
        balance = [0, 0, 0, 0, 3, -5]
>       assert all(tree.balance() == balance[idx]
                   for idx, tree in enumerate(test_bsts))

0-ts/test_bst2.py:92: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
0-ts/test_bst2.py:92: in <genexpr>
    assert all(tree.balance() == balance[idx]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x7ff227ef6b60>
tree = <bst2.Node object at 0x7ff227ef5e10>

>   ???
E   NameError: name 'rightbranch' is not defined

bst2:156: NameError
[36m   -[0m [# 208] SDL bst2: 
--------------------------------------------------------------------------------
  152:         
  153:         leftbranch = 0 if not (tree.left) else tree.left.height
  154:         rightbranch = 0 if not (tree.right) else tree.right.height
  155:         
[34m- 156:         return leftbranch - rightbranch[0m
[32m+ 156:         pass[0m
  157:     
  158:     def pre_order(self, node='root'):
  159:         '''Depth first pre-order traversal of tree.'''
  160:         if node == 'root':
--------------------------------------------------------------------------------
[0.22705 s] [32mkilled[0m by 0-ts/test_bst2.py::test_balance_method

test_bsts = (<bst2.Bst object at 0x7ff227f24d60>, <bst2.Bst object at 0x7ff227f24100>, <bst2.Bst object at 0x7ff227f25b70>, <bst2.Bst object at 0x7ff227f25fc0>, <bst2.Bst object at 0x7ff227f25d50>, <bst2.Bst object at 0x7ff227f263b0>)

    def test_balance_method(test_bsts):
        """Test the balance method."""
        balance = [0, 0, 0, 0, 3, -5]
>       assert all(tree.balance() == balance[idx]
                   for idx, tree in enumerate(test_bsts))
E       AssertionError

0-ts/test_bst2.py:92: AssertionError
[36m   -[0m [# 209] SDL bst2: 
--------------------------------------------------------------------------------
  157:     
  158:     def pre_order(self, node='root'):
  159:         '''Depth first pre-order traversal of tree.'''
  160:         if node == 'root':
[34m- 161:             node = self.root[0m
[32m+ 161:             pass[0m
  162:         
  163:         if not node:
  164:             return
  165:         
--------------------------------------------------------------------------------
[0.22362 s] [32mkilled[0m by 0-ts/test_bst2.py::test_pre_order

test_traversals = {'breadth': ['F', 'B', 'G', 'A', 'D', 'I', ...], 'empty': <bst2.Bst object at 0x7ff227e130d0>, 'in_order': ['A', 'B', 'C', 'D', 'E', 'F', ...], 'post_order': ['A', 'C', 'E', 'D', 'B', 'H', ...], ...}

    def test_pre_order(test_traversals):
        """Test preorder for a traversal."""
>       path = [i for i in test_traversals['tree'].pre_order()]

0-ts/test_bst2.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
0-ts/test_bst2.py:103: in <listcomp>
    path = [i for i in test_traversals['tree'].pre_order()]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x7ff227e12bc0>, node = 'root'

>   ???
E   AttributeError: 'str' object has no attribute 'val'

bst2:166: AttributeError
[36m   -[0m [# 210] SDL bst2: 
--------------------------------------------------------------------------------
  160:         if node == 'root':
  161:             node = self.root
  162:         
  163:         if not node:
[34m- 164:             return[0m
[32m+ 164:             pass[0m
  165:         
  166:         yield node.val
  167:         
  168:         for n in self.pre_order(node=node.left):
--------------------------------------------------------------------------------
[0.23109 s] [32mkilled[0m by 0-ts/test_bst2.py::test_pre_order

test_traversals = {'breadth': ['F', 'B', 'G', 'A', 'D', 'I', ...], 'empty': <bst2.Bst object at 0x7ff227daee90>, 'in_order': ['A', 'B', 'C', 'D', 'E', 'F', ...], 'post_order': ['A', 'C', 'E', 'D', 'B', 'H', ...], ...}

    def test_pre_order(test_traversals):
        """Test preorder for a traversal."""
>       path = [i for i in test_traversals['tree'].pre_order()]

0-ts/test_bst2.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
0-ts/test_bst2.py:103: in <listcomp>
    path = [i for i in test_traversals['tree'].pre_order()]
bst2:168: in pre_order
    ???
bst2:168: in pre_order
    ???
bst2:168: in pre_order
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x7ff227daf9d0>, node = None

>   ???
E   AttributeError: 'NoneType' object has no attribute 'val'

bst2:166: AttributeError
[36m   -[0m [# 211] SDL bst2: 
--------------------------------------------------------------------------------
  162:         
  163:         if not node:
  164:             return
  165:         
[34m- 166:         yield node.val[0m
[32m+ 166:         pass[0m
  167:         
  168:         for n in self.pre_order(node=node.left):
  169:             yield n
  170:         for n in self.pre_order(node=node.right):
--------------------------------------------------------------------------------
[0.23375 s] [32mkilled[0m by 0-ts/test_bst2.py::test_pre_order

test_traversals = {'breadth': ['F', 'B', 'G', 'A', 'D', 'I', ...], 'empty': <bst2.Bst object at 0x7ff2281bb3d0>, 'in_order': ['A', 'B', 'C', 'D', 'E', 'F', ...], 'post_order': ['A', 'C', 'E', 'D', 'B', 'H', ...], ...}

    def test_pre_order(test_traversals):
        """Test preorder for a traversal."""
        path = [i for i in test_traversals['tree'].pre_order()]
>       assert path == test_traversals['pre_order']
E       AssertionError

0-ts/test_bst2.py:104: AssertionError
[36m   -[0m [# 212] SDL bst2: 
--------------------------------------------------------------------------------
  165:         
  166:         yield node.val
  167:         
  168:         for n in self.pre_order(node=node.left):
[34m- 169:             yield n[0m
[32m+ 169:             pass[0m
  170:         for n in self.pre_order(node=node.right):
  171:             yield n
  172:     
  173:     def in_order(self, node='root'):
--------------------------------------------------------------------------------
[0.35019 s] [32mkilled[0m by 0-ts/test_bst2.py::test_pre_order

test_traversals = {'breadth': ['F', 'B', 'G', 'A', 'D', 'I', ...], 'empty': <bst2.Bst object at 0x7ff228269cc0>, 'in_order': ['A', 'B', 'C', 'D', 'E', 'F', ...], 'post_order': ['A', 'C', 'E', 'D', 'B', 'H', ...], ...}

    def test_pre_order(test_traversals):
        """Test preorder for a traversal."""
        path = [i for i in test_traversals['tree'].pre_order()]
>       assert path == test_traversals['pre_order']
E       AssertionError

0-ts/test_bst2.py:104: AssertionError
[36m   -[0m [# 213] SDL bst2: 
--------------------------------------------------------------------------------
  167:         
  168:         for n in self.pre_order(node=node.left):
  169:             yield n
  170:         for n in self.pre_order(node=node.right):
[34m- 171:             yield n[0m
[32m+ 171:             pass[0m
  172:     
  173:     def in_order(self, node='root'):
  174:         '''Depth first in-order traversal of tree.'''
  175:         if node == 'root':
--------------------------------------------------------------------------------
[0.20472 s] [32mkilled[0m by 0-ts/test_bst2.py::test_pre_order

test_traversals = {'breadth': ['F', 'B', 'G', 'A', 'D', 'I', ...], 'empty': <bst2.Bst object at 0x7ff22820a410>, 'in_order': ['A', 'B', 'C', 'D', 'E', 'F', ...], 'post_order': ['A', 'C', 'E', 'D', 'B', 'H', ...], ...}

    def test_pre_order(test_traversals):
        """Test preorder for a traversal."""
        path = [i for i in test_traversals['tree'].pre_order()]
>       assert path == test_traversals['pre_order']
E       AssertionError

0-ts/test_bst2.py:104: AssertionError
[36m   -[0m [# 214] SDL bst2: 
--------------------------------------------------------------------------------
  172:     
  173:     def in_order(self, node='root'):
  174:         '''Depth first in-order traversal of tree.'''
  175:         if node == 'root':
[34m- 176:             node = self.root[0m
[32m+ 176:             pass[0m
  177:         
  178:         if not node:
  179:             return
  180:         
--------------------------------------------------------------------------------
[0.22628 s] [32mkilled[0m by 0-ts/test_bst2.py::test_in_order

test_traversals = {'breadth': ['F', 'B', 'G', 'A', 'D', 'I', ...], 'empty': <bst2.Bst object at 0x7ff2282d9030>, 'in_order': ['A', 'B', 'C', 'D', 'E', 'F', ...], 'post_order': ['A', 'C', 'E', 'D', 'B', 'H', ...], ...}

    def test_in_order(test_traversals):
        """Test inorder for a traversal."""
>       path = [i for i in test_traversals['tree'].in_order()]

0-ts/test_bst2.py:109: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
0-ts/test_bst2.py:109: in <listcomp>
    path = [i for i in test_traversals['tree'].in_order()]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x7ff2282d9a20>, node = 'root'

>   ???
E   AttributeError: 'str' object has no attribute 'left'

bst2:181: AttributeError
[36m   -[0m [# 215] SDL bst2: 
--------------------------------------------------------------------------------
  175:         if node == 'root':
  176:             node = self.root
  177:         
  178:         if not node:
[34m- 179:             return[0m
[32m+ 179:             pass[0m
  180:         
  181:         for n in self.in_order(node=node.left):
  182:             yield n
  183:         yield node.val
--------------------------------------------------------------------------------
[0.21559 s] [32mkilled[0m by 0-ts/test_bst2.py::test_in_order

test_traversals = {'breadth': ['F', 'B', 'G', 'A', 'D', 'I', ...], 'empty': <bst2.Bst object at 0x7ff227cf30a0>, 'in_order': ['A', 'B', 'C', 'D', 'E', 'F', ...], 'post_order': ['A', 'C', 'E', 'D', 'B', 'H', ...], ...}

    def test_in_order(test_traversals):
        """Test inorder for a traversal."""
>       path = [i for i in test_traversals['tree'].in_order()]

0-ts/test_bst2.py:109: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
0-ts/test_bst2.py:109: in <listcomp>
    path = [i for i in test_traversals['tree'].in_order()]
bst2:181: in in_order
    ???
bst2:181: in in_order
    ???
bst2:181: in in_order
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x7ff227cf2110>, node = None

>   ???
E   AttributeError: 'NoneType' object has no attribute 'left'

bst2:181: AttributeError
[36m   -[0m [# 216] SDL bst2: 
--------------------------------------------------------------------------------
  178:         if not node:
  179:             return
  180:         
  181:         for n in self.in_order(node=node.left):
[34m- 182:             yield n[0m
[32m+ 182:             pass[0m
  183:         yield node.val
  184:         for n in self.in_order(node=node.right):
  185:             yield n
  186:     
--------------------------------------------------------------------------------
[0.22729 s] [32mkilled[0m by 0-ts/test_bst2.py::test_in_order

test_traversals = {'breadth': ['F', 'B', 'G', 'A', 'D', 'I', ...], 'empty': <bst2.Bst object at 0x7ff228128250>, 'in_order': ['A', 'B', 'C', 'D', 'E', 'F', ...], 'post_order': ['A', 'C', 'E', 'D', 'B', 'H', ...], ...}

    def test_in_order(test_traversals):
        """Test inorder for a traversal."""
        path = [i for i in test_traversals['tree'].in_order()]
>       assert path == test_traversals['in_order']
E       AssertionError

0-ts/test_bst2.py:110: AssertionError
[36m   -[0m [# 217] SDL bst2: 
--------------------------------------------------------------------------------
  179:             return
  180:         
  181:         for n in self.in_order(node=node.left):
  182:             yield n
[34m- 183:         yield node.val[0m
[32m+ 183:         pass[0m
  184:         for n in self.in_order(node=node.right):
  185:             yield n
  186:     
  187:     def post_order(self, node='root'):
--------------------------------------------------------------------------------
[0.23587 s] [32mkilled[0m by 0-ts/test_bst2.py::test_in_order

test_traversals = {'breadth': ['F', 'B', 'G', 'A', 'D', 'I', ...], 'empty': <bst2.Bst object at 0x7ff227c46110>, 'in_order': ['A', 'B', 'C', 'D', 'E', 'F', ...], 'post_order': ['A', 'C', 'E', 'D', 'B', 'H', ...], ...}

    def test_in_order(test_traversals):
        """Test inorder for a traversal."""
        path = [i for i in test_traversals['tree'].in_order()]
>       assert path == test_traversals['in_order']
E       AssertionError

0-ts/test_bst2.py:110: AssertionError
[36m   -[0m [# 218] SDL bst2: 
--------------------------------------------------------------------------------
  181:         for n in self.in_order(node=node.left):
  182:             yield n
  183:         yield node.val
  184:         for n in self.in_order(node=node.right):
[34m- 185:             yield n[0m
[32m+ 185:             pass[0m
  186:     
  187:     def post_order(self, node='root'):
  188:         '''Depth frist post_order traversal of tree.'''
  189:         if node == 'root':
--------------------------------------------------------------------------------
[0.24233 s] [32mkilled[0m by 0-ts/test_bst2.py::test_in_order

test_traversals = {'breadth': ['F', 'B', 'G', 'A', 'D', 'I', ...], 'empty': <bst2.Bst object at 0x7ff227b00b80>, 'in_order': ['A', 'B', 'C', 'D', 'E', 'F', ...], 'post_order': ['A', 'C', 'E', 'D', 'B', 'H', ...], ...}

    def test_in_order(test_traversals):
        """Test inorder for a traversal."""
        path = [i for i in test_traversals['tree'].in_order()]
>       assert path == test_traversals['in_order']
E       AssertionError

0-ts/test_bst2.py:110: AssertionError
[36m   -[0m [# 219] SDL bst2: 
--------------------------------------------------------------------------------
  186:     
  187:     def post_order(self, node='root'):
  188:         '''Depth frist post_order traversal of tree.'''
  189:         if node == 'root':
[34m- 190:             node = self.root[0m
[32m+ 190:             pass[0m
  191:         
  192:         if not node:
  193:             return
  194:         
--------------------------------------------------------------------------------
[0.23997 s] [32mkilled[0m by 0-ts/test_bst2.py::test_post_order

test_traversals = {'breadth': ['F', 'B', 'G', 'A', 'D', 'I', ...], 'empty': <bst2.Bst object at 0x7ff227de7bb0>, 'in_order': ['A', 'B', 'C', 'D', 'E', 'F', ...], 'post_order': ['A', 'C', 'E', 'D', 'B', 'H', ...], ...}

    def test_post_order(test_traversals):
        """Test postorder for a traversal."""
>       path = [i for i in test_traversals['tree'].post_order()]

0-ts/test_bst2.py:115: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
0-ts/test_bst2.py:115: in <listcomp>
    path = [i for i in test_traversals['tree'].post_order()]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x7ff228341f00>, node = 'root'

>   ???
E   AttributeError: 'str' object has no attribute 'left'

bst2:195: AttributeError
[36m   -[0m [# 220] SDL bst2: 
--------------------------------------------------------------------------------
  189:         if node == 'root':
  190:             node = self.root
  191:         
  192:         if not node:
[34m- 193:             return[0m
[32m+ 193:             pass[0m
  194:         
  195:         for n in self.post_order(node=node.left):
  196:             yield n
  197:         for n in self.post_order(node=node.right):
--------------------------------------------------------------------------------
[0.24841 s] [32mkilled[0m by 0-ts/test_bst2.py::test_post_order

test_traversals = {'breadth': ['F', 'B', 'G', 'A', 'D', 'I', ...], 'empty': <bst2.Bst object at 0x7ff228140730>, 'in_order': ['A', 'B', 'C', 'D', 'E', 'F', ...], 'post_order': ['A', 'C', 'E', 'D', 'B', 'H', ...], ...}

    def test_post_order(test_traversals):
        """Test postorder for a traversal."""
>       path = [i for i in test_traversals['tree'].post_order()]

0-ts/test_bst2.py:115: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
0-ts/test_bst2.py:115: in <listcomp>
    path = [i for i in test_traversals['tree'].post_order()]
bst2:195: in post_order
    ???
bst2:195: in post_order
    ???
bst2:195: in post_order
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x7ff228140310>, node = None

>   ???
E   AttributeError: 'NoneType' object has no attribute 'left'

bst2:195: AttributeError
[36m   -[0m [# 221] SDL bst2: 
--------------------------------------------------------------------------------
  192:         if not node:
  193:             return
  194:         
  195:         for n in self.post_order(node=node.left):
[34m- 196:             yield n[0m
[32m+ 196:             pass[0m
  197:         for n in self.post_order(node=node.right):
  198:             yield n
  199:         yield node.val
  200:     
--------------------------------------------------------------------------------
[0.36309 s] [32mkilled[0m by 0-ts/test_bst2.py::test_post_order

test_traversals = {'breadth': ['F', 'B', 'G', 'A', 'D', 'I', ...], 'empty': <bst2.Bst object at 0x7ff2280c8a90>, 'in_order': ['A', 'B', 'C', 'D', 'E', 'F', ...], 'post_order': ['A', 'C', 'E', 'D', 'B', 'H', ...], ...}

    def test_post_order(test_traversals):
        """Test postorder for a traversal."""
        path = [i for i in test_traversals['tree'].post_order()]
>       assert path == test_traversals['post_order']
E       AssertionError

0-ts/test_bst2.py:116: AssertionError
[36m   -[0m [# 222] SDL bst2: 
--------------------------------------------------------------------------------
  194:         
  195:         for n in self.post_order(node=node.left):
  196:             yield n
  197:         for n in self.post_order(node=node.right):
[34m- 198:             yield n[0m
[32m+ 198:             pass[0m
  199:         yield node.val
  200:     
  201:     def breadth_first(self):
  202:         '''Breadth first traversal of tree.'''
--------------------------------------------------------------------------------
[0.22062 s] [32mkilled[0m by 0-ts/test_bst2.py::test_post_order

test_traversals = {'breadth': ['F', 'B', 'G', 'A', 'D', 'I', ...], 'empty': <bst2.Bst object at 0x7ff228349810>, 'in_order': ['A', 'B', 'C', 'D', 'E', 'F', ...], 'post_order': ['A', 'C', 'E', 'D', 'B', 'H', ...], ...}

    def test_post_order(test_traversals):
        """Test postorder for a traversal."""
        path = [i for i in test_traversals['tree'].post_order()]
>       assert path == test_traversals['post_order']
E       AssertionError

0-ts/test_bst2.py:116: AssertionError
[36m   -[0m [# 223] SDL bst2: 
--------------------------------------------------------------------------------
  195:         for n in self.post_order(node=node.left):
  196:             yield n
  197:         for n in self.post_order(node=node.right):
  198:             yield n
[34m- 199:         yield node.val[0m
[32m+ 199:         pass[0m
  200:     
  201:     def breadth_first(self):
  202:         '''Breadth first traversal of tree.'''
  203:         q = Queue()
--------------------------------------------------------------------------------
[0.23039 s] [32mkilled[0m by 0-ts/test_bst2.py::test_post_order

test_traversals = {'breadth': ['F', 'B', 'G', 'A', 'D', 'I', ...], 'empty': <bst2.Bst object at 0x7ff227eef700>, 'in_order': ['A', 'B', 'C', 'D', 'E', 'F', ...], 'post_order': ['A', 'C', 'E', 'D', 'B', 'H', ...], ...}

    def test_post_order(test_traversals):
        """Test postorder for a traversal."""
        path = [i for i in test_traversals['tree'].post_order()]
>       assert path == test_traversals['post_order']
E       AssertionError

0-ts/test_bst2.py:116: AssertionError
[36m   -[0m [# 224] SDL bst2: 
--------------------------------------------------------------------------------
  199:         yield node.val
  200:     
  201:     def breadth_first(self):
  202:         '''Breadth first traversal of tree.'''
[34m- 203:         q = Queue()[0m
[32m+ 203:         pass[0m
  204:         q.enqueue(self.root)
  205:         while q.peek():
  206:             node = q.dequeue()
  207:             yield node.val
--------------------------------------------------------------------------------
[0.23052 s] [32mkilled[0m by 0-ts/test_bst2.py::test_breadth_first

test_traversals = {'breadth': ['F', 'B', 'G', 'A', 'D', 'I', ...], 'empty': <bst2.Bst object at 0x7ff228343df0>, 'in_order': ['A', 'B', 'C', 'D', 'E', 'F', ...], 'post_order': ['A', 'C', 'E', 'D', 'B', 'H', ...], ...}

    def test_breadth_first(test_traversals):
        """Test breadth first for a traversal."""
>       path = [i for i in test_traversals['tree'].breadth_first()]

0-ts/test_bst2.py:121: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
0-ts/test_bst2.py:121: in <listcomp>
    path = [i for i in test_traversals['tree'].breadth_first()]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x7ff228343d00>

>   ???
E   NameError: name 'q' is not defined

bst2:204: NameError
[36m   -[0m [# 225] SDL bst2: 
--------------------------------------------------------------------------------
  200:     
  201:     def breadth_first(self):
  202:         '''Breadth first traversal of tree.'''
  203:         q = Queue()
[34m- 204:         q.enqueue(self.root)[0m
[32m+ 204:         pass[0m
  205:         while q.peek():
  206:             node = q.dequeue()
  207:             yield node.val
  208:             if node.left:
--------------------------------------------------------------------------------
[0.21760 s] [32mkilled[0m by 0-ts/test_bst2.py::test_breadth_first

test_traversals = {'breadth': ['F', 'B', 'G', 'A', 'D', 'I', ...], 'empty': <bst2.Bst object at 0x7ff228167e80>, 'in_order': ['A', 'B', 'C', 'D', 'E', 'F', ...], 'post_order': ['A', 'C', 'E', 'D', 'B', 'H', ...], ...}

    def test_breadth_first(test_traversals):
        """Test breadth first for a traversal."""
        path = [i for i in test_traversals['tree'].breadth_first()]
>       assert path == test_traversals['breadth']
E       AssertionError

0-ts/test_bst2.py:122: AssertionError
[36m   -[0m [# 226] SDL bst2: 
--------------------------------------------------------------------------------
  202:         '''Breadth first traversal of tree.'''
  203:         q = Queue()
  204:         q.enqueue(self.root)
  205:         while q.peek():
[34m- 206:             node = q.dequeue()[0m
[32m+ 206:             pass[0m
  207:             yield node.val
  208:             if node.left:
  209:                 q.enqueue(node.left)
  210:             if node.right:
--------------------------------------------------------------------------------
[0.24706 s] [32mkilled[0m by 0-ts/test_bst2.py::test_breadth_first

test_traversals = {'breadth': ['F', 'B', 'G', 'A', 'D', 'I', ...], 'empty': <bst2.Bst object at 0x7ff228386f20>, 'in_order': ['A', 'B', 'C', 'D', 'E', 'F', ...], 'post_order': ['A', 'C', 'E', 'D', 'B', 'H', ...], ...}

    def test_breadth_first(test_traversals):
        """Test breadth first for a traversal."""
>       path = [i for i in test_traversals['tree'].breadth_first()]

0-ts/test_bst2.py:121: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
0-ts/test_bst2.py:121: in <listcomp>
    path = [i for i in test_traversals['tree'].breadth_first()]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x7ff228385ab0>

>   ???
E   NameError: name 'node' is not defined

bst2:207: NameError
[36m   -[0m [# 227] SDL bst2: 
--------------------------------------------------------------------------------
  203:         q = Queue()
  204:         q.enqueue(self.root)
  205:         while q.peek():
  206:             node = q.dequeue()
[34m- 207:             yield node.val[0m
[32m+ 207:             pass[0m
  208:             if node.left:
  209:                 q.enqueue(node.left)
  210:             if node.right:
  211:                 q.enqueue(node.right)
--------------------------------------------------------------------------------
[0.21292 s] [36mincompetent[0m

TypeError: /home/lucca/desktop/ic/experimento/testes/python_experiments2/bst2/0-ts/test_bst2.py:121: TypeError: 'NoneType' object is not iterable

[36m   -[0m [# 228] SDL bst2: 
--------------------------------------------------------------------------------
  205:         while q.peek():
  206:             node = q.dequeue()
  207:             yield node.val
  208:             if node.left:
[34m- 209:                 q.enqueue(node.left)[0m
[32m+ 209:                 pass[0m
  210:             if node.right:
  211:                 q.enqueue(node.right)
  212:     
  213:     def delete(self, val):
--------------------------------------------------------------------------------
[0.23822 s] [32mkilled[0m by 0-ts/test_bst2.py::test_breadth_first

test_traversals = {'breadth': ['F', 'B', 'G', 'A', 'D', 'I', ...], 'empty': <bst2.Bst object at 0x7ff2287fd7e0>, 'in_order': ['A', 'B', 'C', 'D', 'E', 'F', ...], 'post_order': ['A', 'C', 'E', 'D', 'B', 'H', ...], ...}

    def test_breadth_first(test_traversals):
        """Test breadth first for a traversal."""
        path = [i for i in test_traversals['tree'].breadth_first()]
>       assert path == test_traversals['breadth']
E       AssertionError

0-ts/test_bst2.py:122: AssertionError
[36m   -[0m [# 229] SDL bst2: 
--------------------------------------------------------------------------------
  207:             yield node.val
  208:             if node.left:
  209:                 q.enqueue(node.left)
  210:             if node.right:
[34m- 211:                 q.enqueue(node.right)[0m
[32m+ 211:                 pass[0m
  212:     
  213:     def delete(self, val):
  214:         '''Remove a node from the tree.'''
  215:         if (self._size < 1 or not (self.contains(val))):
--------------------------------------------------------------------------------
[0.21625 s] [32mkilled[0m by 0-ts/test_bst2.py::test_breadth_first

test_traversals = {'breadth': ['F', 'B', 'G', 'A', 'D', 'I', ...], 'empty': <bst2.Bst object at 0x7ff227b22980>, 'in_order': ['A', 'B', 'C', 'D', 'E', 'F', ...], 'post_order': ['A', 'C', 'E', 'D', 'B', 'H', ...], ...}

    def test_breadth_first(test_traversals):
        """Test breadth first for a traversal."""
        path = [i for i in test_traversals['tree'].breadth_first()]
>       assert path == test_traversals['breadth']
E       AssertionError

0-ts/test_bst2.py:122: AssertionError
[36m   -[0m [# 230] SDL bst2: 
--------------------------------------------------------------------------------
  212:     
  213:     def delete(self, val):
  214:         '''Remove a node from the tree.'''
  215:         if (self._size < 1 or not (self.contains(val))):
[34m- 216:             return[0m
[32m+ 216:             pass[0m
  217:         
  218:         node = self.search(val)
  219:         
  220:         if node._is_leaf():
--------------------------------------------------------------------------------
[0.34937 s] [32mkilled[0m by 0-ts/test_bst2.py::test_del_false

test_bsts = (<bst2.Bst object at 0x7ff227cbbdf0>, <bst2.Bst object at 0x7ff227cbaec0>, <bst2.Bst object at 0x7ff227cbaef0>, <bst2.Bst object at 0x7ff227cbad10>, <bst2.Bst object at 0x7ff227cbac20>, <bst2.Bst object at 0x7ff227cba650>)

    def test_del_false(test_bsts):
        """Test delete for a node not in tree."""
        size = test_bsts[2].size()
>       test_bsts[2].delete(1)

0-ts/test_bst2.py:134: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x7ff227cbaef0>, val = 1

>   ???
E   AttributeError: 'NoneType' object has no attribute '_is_leaf'

bst2:220: AttributeError
[36m   -[0m [# 231] SDL bst2: 
--------------------------------------------------------------------------------
  214:         '''Remove a node from the tree.'''
  215:         if (self._size < 1 or not (self.contains(val))):
  216:             return
  217:         
[34m- 218:         node = self.search(val)[0m
[32m+ 218:         pass[0m
  219:         
  220:         if node._is_leaf():
  221:             if node.parent:
  222:                 setattr(node.parent, node._side(), None)
--------------------------------------------------------------------------------
[0.23461 s] [32mkilled[0m by 0-ts/test_bst2.py::test_remove_leaf_left

test_bsts = (<bst2.Bst object at 0x7ff2281048b0>, <bst2.Bst object at 0x7ff228106320>, <bst2.Bst object at 0x7ff228105630>, <bst2.Bst object at 0x7ff228106b00>, <bst2.Bst object at 0x7ff228106950>, <bst2.Bst object at 0x7ff228106020>)

    def test_remove_leaf_left(test_bsts):
        """Test delete leaf on left."""
>       test_bsts[2].delete(3)

0-ts/test_bst2.py:146: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x7ff228105630>, val = 3

>   ???
E   NameError: name 'node' is not defined

bst2:220: NameError
[36m   -[0m [# 232] SDL bst2: 
--------------------------------------------------------------------------------
  218:         node = self.search(val)
  219:         
  220:         if node._is_leaf():
  221:             if node.parent:
[34m- 222:                 setattr(node.parent, node._side(), None)[0m
[32m+ 222:                 pass[0m
  223:             else:
  224:                 self.root = None
  225:         
  226:         elif node._is_interior():
--------------------------------------------------------------------------------
[0.25125 s] [32mkilled[0m by 0-ts/test_bst2.py::test_remove_leaf_left

test_bsts = (<bst2.Bst object at 0x7ff227c5e7d0>, <bst2.Bst object at 0x7ff227c5dea0>, <bst2.Bst object at 0x7ff227c5c940>, <bst2.Bst object at 0x7ff227c5db40>, <bst2.Bst object at 0x7ff227c5e080>, <bst2.Bst object at 0x7ff227c5f6a0>)

    def test_remove_leaf_left(test_bsts):
        """Test delete leaf on left."""
        test_bsts[2].delete(3)
>       assert not test_bsts[2].contains(3)
E       AssertionError

0-ts/test_bst2.py:147: AssertionError
[36m   -[0m [# 233] SDL bst2: 
--------------------------------------------------------------------------------
  220:         if node._is_leaf():
  221:             if node.parent:
  222:                 setattr(node.parent, node._side(), None)
  223:             else:
[34m- 224:                 self.root = None[0m
[32m+ 224:                 pass[0m
  225:         
  226:         elif node._is_interior():
  227:             next_node = self._find_replacement(node)
  228:             self._size += 1
--------------------------------------------------------------------------------
[0.23789 s] [32mkilled[0m by 0-ts/test_bst2.py::test_remove_leaf_root

test_bsts = (<bst2.Bst object at 0x7ff2281374c0>, <bst2.Bst object at 0x7ff228137c40>, <bst2.Bst object at 0x7ff2281344c0>, <bst2.Bst object at 0x7ff2281354e0>, <bst2.Bst object at 0x7ff228135360>, <bst2.Bst object at 0x7ff2281341c0>)

    def test_remove_leaf_root(test_bsts):
        """Test delete leaf that is root."""
        test_bsts[1].delete(5)
>       assert not test_bsts[1].contains(5)
E       AssertionError

0-ts/test_bst2.py:161: AssertionError
[36m   -[0m [# 234] SDL bst2: 
--------------------------------------------------------------------------------
  223:             else:
  224:                 self.root = None
  225:         
  226:         elif node._is_interior():
[34m- 227:             next_node = self._find_replacement(node)[0m
[32m+ 227:             pass[0m
  228:             self._size += 1
  229:             self.delete(next_node.val)
  230:             node.val = next_node.val
  231:         else:
--------------------------------------------------------------------------------
[0.25598 s] [32mkilled[0m by 0-ts/test_bst2.py::test_delete_two_children

test_bsts = (<bst2.Bst object at 0x7ff228342d40>, <bst2.Bst object at 0x7ff228343370>, <bst2.Bst object at 0x7ff227e28070>, <bst2.Bst object at 0x7ff227e28910>, <bst2.Bst object at 0x7ff227e28a60>, <bst2.Bst object at 0x7ff227e28f10>)

    def test_delete_two_children(test_bsts):
        """Test delete node with two children."""
>       test_bsts[3].delete(3)

0-ts/test_bst2.py:208: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x7ff227e28910>, val = 3

>   ???
E   NameError: name 'next_node' is not defined

bst2:229: NameError
[36m   -[0m [# 235] SDL bst2: 
--------------------------------------------------------------------------------
  225:         
  226:         elif node._is_interior():
  227:             next_node = self._find_replacement(node)
  228:             self._size += 1
[34m- 229:             self.delete(next_node.val)[0m
[32m+ 229:             pass[0m
  230:             node.val = next_node.val
  231:         else:
  232:             
  233:             child = getattr(node, node._onlychild())
--------------------------------------------------------------------------------
[0.36982 s] [32mkilled[0m by 0-ts/test_bst2.py::test_delete_two_children

test_bsts = (<bst2.Bst object at 0x7ff227c56620>, <bst2.Bst object at 0x7ff227c56230>, <bst2.Bst object at 0x7ff227c56410>, <bst2.Bst object at 0x7ff227c551b0>, <bst2.Bst object at 0x7ff227c55a20>, <bst2.Bst object at 0x7ff227c54310>)

    def test_delete_two_children(test_bsts):
        """Test delete node with two children."""
        test_bsts[3].delete(3)
        assert not test_bsts[3].contains(3)
>       assert test_bsts[3].size() is 6
E       AssertionError

0-ts/test_bst2.py:210: AssertionError
[36m   -[0m [# 236] SDL bst2: 
--------------------------------------------------------------------------------
  226:         elif node._is_interior():
  227:             next_node = self._find_replacement(node)
  228:             self._size += 1
  229:             self.delete(next_node.val)
[34m- 230:             node.val = next_node.val[0m
[32m+ 230:             pass[0m
  231:         else:
  232:             
  233:             child = getattr(node, node._onlychild())
  234:             if node.parent:
--------------------------------------------------------------------------------
[0.25342 s] [32mkilled[0m by 0-ts/test_bst2.py::test_delete_two_children

test_bsts = (<bst2.Bst object at 0x7ff228094eb0>, <bst2.Bst object at 0x7ff227c470d0>, <bst2.Bst object at 0x7ff227c44f70>, <bst2.Bst object at 0x7ff227c442b0>, <bst2.Bst object at 0x7ff227c451e0>, <bst2.Bst object at 0x7ff227c47e20>)

    def test_delete_two_children(test_bsts):
        """Test delete node with two children."""
        test_bsts[3].delete(3)
>       assert not test_bsts[3].contains(3)
E       AssertionError

0-ts/test_bst2.py:209: AssertionError
[36m   -[0m [# 237] SDL bst2: 
--------------------------------------------------------------------------------
  229:             self.delete(next_node.val)
  230:             node.val = next_node.val
  231:         else:
  232:             
[34m- 233:             child = getattr(node, node._onlychild())[0m
[32m+ 233:             pass[0m
  234:             if node.parent:
  235:                 child.parent = node.parent
  236:                 setattr(node.parent, node._side(), child)
  237:             else:
--------------------------------------------------------------------------------
[0.25366 s] [32mkilled[0m by 0-ts/test_bst2.py::test_remove_one_child_left

test_bsts = (<bst2.Bst object at 0x7ff227f24400>, <bst2.Bst object at 0x7ff227f27b20>, <bst2.Bst object at 0x7ff227f25c00>, <bst2.Bst object at 0x7ff227f24970>, <bst2.Bst object at 0x7ff228137d00>, <bst2.Bst object at 0x7ff228136830>)

    def test_remove_one_child_left(test_bsts):
        """Test delete node one child, left."""
>       test_bsts[4].delete(3)

0-ts/test_bst2.py:167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x7ff228137d00>, val = 3

>   ???
E   NameError: name 'child' is not defined

bst2:235: NameError
[36m   -[0m [# 238] SDL bst2: 
--------------------------------------------------------------------------------
  231:         else:
  232:             
  233:             child = getattr(node, node._onlychild())
  234:             if node.parent:
[34m- 235:                 child.parent = node.parent[0m
[32m+ 235:                 pass[0m
  236:                 setattr(node.parent, node._side(), child)
  237:             else:
  238:                 self.root = child
  239:         
--------------------------------------------------------------------------------
[0.21043 s] [31msurvived[0m
[36m   -[0m [# 239] SDL bst2: 
--------------------------------------------------------------------------------
  232:             
  233:             child = getattr(node, node._onlychild())
  234:             if node.parent:
  235:                 child.parent = node.parent
[34m- 236:                 setattr(node.parent, node._side(), child)[0m
[32m+ 236:                 pass[0m
  237:             else:
  238:                 self.root = child
  239:         
  240:         self._size -= 1
--------------------------------------------------------------------------------
[0.22835 s] [32mkilled[0m by 0-ts/test_bst2.py::test_remove_one_child_left

test_bsts = (<bst2.Bst object at 0x7ff227dc4730>, <bst2.Bst object at 0x7ff227dc7fa0>, <bst2.Bst object at 0x7ff227dc59c0>, <bst2.Bst object at 0x7ff227dc5ae0>, <bst2.Bst object at 0x7ff227dc4220>, <bst2.Bst object at 0x7ff227df3d30>)

    def test_remove_one_child_left(test_bsts):
        """Test delete node one child, left."""
        test_bsts[4].delete(3)
>       assert not test_bsts[4].contains(3)
E       AssertionError

0-ts/test_bst2.py:168: AssertionError
[36m   -[0m [# 240] SDL bst2: 
--------------------------------------------------------------------------------
  234:             if node.parent:
  235:                 child.parent = node.parent
  236:                 setattr(node.parent, node._side(), child)
  237:             else:
[34m- 238:                 self.root = child[0m
[32m+ 238:                 pass[0m
  239:         
  240:         self._size -= 1
  241:     
  242:     def _find_replacement(self, node):
--------------------------------------------------------------------------------
[0.24370 s] [32mkilled[0m by 0-ts/test_bst2.py::test_remove_one_child_root

test_bsts = (<bst2.Bst object at 0x7ff22843fb20>, <bst2.Bst object at 0x7ff22843dc30>, <bst2.Bst object at 0x7ff22843d840>, <bst2.Bst object at 0x7ff22843d2d0>, <bst2.Bst object at 0x7ff22843de40>, <bst2.Bst object at 0x7ff22843d990>)

    def test_remove_one_child_root(test_bsts):
        """Test delete node that is root with one child."""
        test_bsts[1].insert(7)
        test_bsts[1].delete(5)
>       assert not test_bsts[1].contains(5)
E       AssertionError

0-ts/test_bst2.py:201: AssertionError
[36m   -[0m [# 241] SDL bst2: 
--------------------------------------------------------------------------------
  241:     
  242:     def _find_replacement(self, node):
  243:         '''Find left most node of right subtree.'''
  244:         if node.right:
[34m- 245:             return self._findmin(node.right)[0m
[32m+ 245:             pass[0m
  246:         
  247:         elif node.parent:
  248:             if node._side() == 'left':
  249:                 return self.parent
--------------------------------------------------------------------------------
[0.25373 s] [32mkilled[0m by 0-ts/test_bst2.py::test_delete_two_children

test_bsts = (<bst2.Bst object at 0x7ff228134400>, <bst2.Bst object at 0x7ff228137a00>, <bst2.Bst object at 0x7ff2281352a0>, <bst2.Bst object at 0x7ff228137c10>, <bst2.Bst object at 0x7ff2281349d0>, <bst2.Bst object at 0x7ff228134af0>)

    def test_delete_two_children(test_bsts):
        """Test delete node with two children."""
>       test_bsts[3].delete(3)

0-ts/test_bst2.py:208: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x7ff228137c10>, val = 3

>   ???
E   AttributeError: 'NoneType' object has no attribute 'val'

bst2:229: AttributeError
[36m   -[0m [# 242] SDL bst2: 
--------------------------------------------------------------------------------
  245:             return self._findmin(node.right)
  246:         
  247:         elif node.parent:
  248:             if node._side() == 'left':
[34m- 249:                 return self.parent[0m
[32m+ 249:                 pass[0m
  250:             else:
  251:                 node.parent.right = None
  252:                 tmp = self._find_replacement(node.parent)
  253:                 node.parent.right = node
--------------------------------------------------------------------------------
[0.20049 s] [31msurvived[0m
[36m   -[0m [# 243] SDL bst2: 
--------------------------------------------------------------------------------
  247:         elif node.parent:
  248:             if node._side() == 'left':
  249:                 return self.parent
  250:             else:
[34m- 251:                 node.parent.right = None[0m
[32m+ 251:                 pass[0m
  252:                 tmp = self._find_replacement(node.parent)
  253:                 node.parent.right = node
  254:                 return tmp
  255:     
--------------------------------------------------------------------------------
[0.25294 s] [31msurvived[0m
[36m   -[0m [# 244] SDL bst2: 
--------------------------------------------------------------------------------
  248:             if node._side() == 'left':
  249:                 return self.parent
  250:             else:
  251:                 node.parent.right = None
[34m- 252:                 tmp = self._find_replacement(node.parent)[0m
[32m+ 252:                 pass[0m
  253:                 node.parent.right = node
  254:                 return tmp
  255:     
  256:     def _findmin(self, node):
--------------------------------------------------------------------------------
[0.32551 s] [31msurvived[0m
[36m   -[0m [# 245] SDL bst2: 
--------------------------------------------------------------------------------
  249:                 return self.parent
  250:             else:
  251:                 node.parent.right = None
  252:                 tmp = self._find_replacement(node.parent)
[34m- 253:                 node.parent.right = node[0m
[32m+ 253:                 pass[0m
  254:                 return tmp
  255:     
  256:     def _findmin(self, node):
  257:         '''Find min of subtree, Min is always left most node.'''
--------------------------------------------------------------------------------
[0.32395 s] [31msurvived[0m
[36m   -[0m [# 246] SDL bst2: 
--------------------------------------------------------------------------------
  250:             else:
  251:                 node.parent.right = None
  252:                 tmp = self._find_replacement(node.parent)
  253:                 node.parent.right = node
[34m- 254:                 return tmp[0m
[32m+ 254:                 pass[0m
  255:     
  256:     def _findmin(self, node):
  257:         '''Find min of subtree, Min is always left most node.'''
  258:         while node.left:
--------------------------------------------------------------------------------
[0.20941 s] [31msurvived[0m
[36m   -[0m [# 247] SDL bst2: 
--------------------------------------------------------------------------------
  255:     
  256:     def _findmin(self, node):
  257:         '''Find min of subtree, Min is always left most node.'''
  258:         while node.left:
[34m- 259:             node = node.left[0m
[32m+ 259:             pass[0m
  260:         return node
--------------------------------------------------------------------------------
[5.00713 s] [33mtimeout[0m
[36m   -[0m [# 248] SDL bst2: 
--------------------------------------------------------------------------------
  256:     def _findmin(self, node):
  257:         '''Find min of subtree, Min is always left most node.'''
  258:         while node.left:
  259:             node = node.left
[34m- 260:         return node[0m
[32m+ 260:         pass[0m
--------------------------------------------------------------------------------
[0.32638 s] [32mkilled[0m by 0-ts/test_bst2.py::test_delete_two_children

test_bsts = (<bst2.Bst object at 0x7ff227e12e60>, <bst2.Bst object at 0x7ff227e12b90>, <bst2.Bst object at 0x7ff227e13430>, <bst2.Bst object at 0x7ff227e6c7c0>, <bst2.Bst object at 0x7ff227e6c940>, <bst2.Bst object at 0x7ff227e6cdf0>)

    def test_delete_two_children(test_bsts):
        """Test delete node with two children."""
>       test_bsts[3].delete(3)

0-ts/test_bst2.py:208: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x7ff227e6c7c0>, val = 3

>   ???
E   AttributeError: 'NoneType' object has no attribute 'val'

bst2:229: AttributeError
[36m   -[0m [# 249] SVD bst2: 
--------------------------------------------------------------------------------
    7:     '''Node, or leaf of the BST.'''
    8:     
    9:     def __init__(self, val=None, parent=None):
   10:         '''Create node object.'''
[34m-  11:         self.val = val[0m
[32m+  11:         val = val[0m
   12:         self.right = None
   13:         self.left = None
   14:         self.parent = parent
   15:         self.height = 1
--------------------------------------------------------------------------------
[0.00000 s] [36mincompetent[0m

ValueError: expression must have Store context but has Load instead

[36m   -[0m [# 250] SVD bst2: 
--------------------------------------------------------------------------------
    8:     
    9:     def __init__(self, val=None, parent=None):
   10:         '''Create node object.'''
   11:         self.val = val
[34m-  12:         self.right = None[0m
[32m+  12:         right = None[0m
   13:         self.left = None
   14:         self.parent = parent
   15:         self.height = 1
   16:     
--------------------------------------------------------------------------------
[0.00000 s] [36mincompetent[0m

ValueError: expression must have Store context but has Load instead

[36m   -[0m [# 251] SVD bst2: 
--------------------------------------------------------------------------------
    9:     def __init__(self, val=None, parent=None):
   10:         '''Create node object.'''
   11:         self.val = val
   12:         self.right = None
[34m-  13:         self.left = None[0m
[32m+  13:         left = None[0m
   14:         self.parent = parent
   15:         self.height = 1
   16:     
   17:     def _is_leaf(self):
--------------------------------------------------------------------------------
[0.00000 s] [36mincompetent[0m

ValueError: expression must have Store context but has Load instead

[36m   -[0m [# 252] SVD bst2: 
--------------------------------------------------------------------------------
   10:         '''Create node object.'''
   11:         self.val = val
   12:         self.right = None
   13:         self.left = None
[34m-  14:         self.parent = parent[0m
[32m+  14:         parent = parent[0m
   15:         self.height = 1
   16:     
   17:     def _is_leaf(self):
   18:         '''Return true if a leaf.'''
--------------------------------------------------------------------------------
[0.00000 s] [36mincompetent[0m

ValueError: expression must have Store context but has Load instead

[36m   -[0m [# 253] SVD bst2: 
--------------------------------------------------------------------------------
   11:         self.val = val
   12:         self.right = None
   13:         self.left = None
   14:         self.parent = parent
[34m-  15:         self.height = 1[0m
[32m+  15:         height = 1[0m
   16:     
   17:     def _is_leaf(self):
   18:         '''Return true if a leaf.'''
   19:         return not ((self.right or self.left))
--------------------------------------------------------------------------------
[0.00000 s] [36mincompetent[0m

ValueError: expression must have Store context but has Load instead

[36m   -[0m [# 254] SVD bst2: 
--------------------------------------------------------------------------------
   15:         self.height = 1
   16:     
   17:     def _is_leaf(self):
   18:         '''Return true if a leaf.'''
[34m-  19:         return not ((self.right or self.left))[0m
[32m+  19:         return not ((right or self.left))[0m
   20:     
   21:     def _is_interior(self):
   22:         '''Return true if a interior node.'''
   23:         return (self.right and self.left)
--------------------------------------------------------------------------------
[0.25683 s] [32mkilled[0m by 0-ts/test_bst2.py::test_node_is_leaf

test_bsts = (<bst2.Bst object at 0x7ff2282d84f0>, <bst2.Bst object at 0x7ff2282d8640>, <bst2.Bst object at 0x7ff2282da7a0>, <bst2.Bst object at 0x7ff2282da260>, <bst2.Bst object at 0x7ff2282d8a30>, <bst2.Bst object at 0x7ff227c5ff40>)

    def test_node_is_leaf(test_bsts):
        """Test node is leaf bst."""
>       assert test_bsts[1].root._is_leaf()

0-ts/test_bst2.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Node object at 0x7ff2282da8f0>

>   ???
E   NameError: name 'right' is not defined

bst2:19: NameError
[36m   -[0m [# 255] SVD bst2: 
--------------------------------------------------------------------------------
   15:         self.height = 1
   16:     
   17:     def _is_leaf(self):
   18:         '''Return true if a leaf.'''
[34m-  19:         return not ((self.right or self.left))[0m
[32m+  19:         return not ((self.right or left))[0m
   20:     
   21:     def _is_interior(self):
   22:         '''Return true if a interior node.'''
   23:         return (self.right and self.left)
--------------------------------------------------------------------------------
[0.22726 s] [32mkilled[0m by 0-ts/test_bst2.py::test_node_is_leaf

test_bsts = (<bst2.Bst object at 0x7ff22843e020>, <bst2.Bst object at 0x7ff22843e3b0>, <bst2.Bst object at 0x7ff22843e830>, <bst2.Bst object at 0x7ff22843dab0>, <bst2.Bst object at 0x7ff22843fb20>, <bst2.Bst object at 0x7ff22843eb60>)

    def test_node_is_leaf(test_bsts):
        """Test node is leaf bst."""
>       assert test_bsts[1].root._is_leaf()

0-ts/test_bst2.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Node object at 0x7ff22843d0f0>

>   ???
E   NameError: name 'left' is not defined

bst2:19: NameError
[36m   -[0m [# 256] SVD bst2: 
--------------------------------------------------------------------------------
   19:         return not ((self.right or self.left))
   20:     
   21:     def _is_interior(self):
   22:         '''Return true if a interior node.'''
[34m-  23:         return (self.right and self.left)[0m
[32m+  23:         return (right and self.left)[0m
   24:     
   25:     def _onlychild(self):
   26:         '''Return string depending on children.'''
   27:         if (self.left and not (self.right)):
--------------------------------------------------------------------------------
[0.23645 s] [32mkilled[0m by 0-ts/test_bst2.py::test_remove_one_child_left

test_bsts = (<bst2.Bst object at 0x7ff227b000d0>, <bst2.Bst object at 0x7ff227b027d0>, <bst2.Bst object at 0x7ff22843de10>, <bst2.Bst object at 0x7ff22843f070>, <bst2.Bst object at 0x7ff22843ddb0>, <bst2.Bst object at 0x7ff22843e1a0>)

    def test_remove_one_child_left(test_bsts):
        """Test delete node one child, left."""
>       test_bsts[4].delete(3)

0-ts/test_bst2.py:167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
bst2:226: in delete
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Node object at 0x7ff22843cc40>

>   ???
E   NameError: name 'right' is not defined

bst2:23: NameError
[36m   -[0m [# 257] SVD bst2: 
--------------------------------------------------------------------------------
   19:         return not ((self.right or self.left))
   20:     
   21:     def _is_interior(self):
   22:         '''Return true if a interior node.'''
[34m-  23:         return (self.right and self.left)[0m
[32m+  23:         return (self.right and left)[0m
   24:     
   25:     def _onlychild(self):
   26:         '''Return string depending on children.'''
   27:         if (self.left and not (self.right)):
--------------------------------------------------------------------------------
[0.25067 s] [32mkilled[0m by 0-ts/test_bst2.py::test_remove_one_child_right

test_bsts = (<bst2.Bst object at 0x7ff2281a80a0>, <bst2.Bst object at 0x7ff2281a8b20>, <bst2.Bst object at 0x7ff2281a9090>, <bst2.Bst object at 0x7ff227de3e50>, <bst2.Bst object at 0x7ff227de3c10>, <bst2.Bst object at 0x7ff227de3430>)

    def test_remove_one_child_right(test_bsts):
        """Test delete node one child, right."""
>       test_bsts[5].delete(6)

0-ts/test_bst2.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
bst2:226: in delete
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Node object at 0x7ff227de3400>

>   ???
E   NameError: name 'left' is not defined

bst2:23: NameError
[36m   -[0m [# 258] SVD bst2: 
--------------------------------------------------------------------------------
   23:         return (self.right and self.left)
   24:     
   25:     def _onlychild(self):
   26:         '''Return string depending on children.'''
[34m-  27:         if (self.left and not (self.right)):[0m
[32m+  27:         if (left and not (self.right)):[0m
   28:             return 'left'
   29:         if (self.right and not (self.left)):
   30:             return 'right'
   31:     
--------------------------------------------------------------------------------
[0.39473 s] [32mkilled[0m by 0-ts/test_bst2.py::test_remove_one_child_left

test_bsts = (<bst2.Bst object at 0x7ff22834a440>, <bst2.Bst object at 0x7ff22834bd90>, <bst2.Bst object at 0x7ff228349a20>, <bst2.Bst object at 0x7ff22834b2b0>, <bst2.Bst object at 0x7ff22834b3a0>, <bst2.Bst object at 0x7ff228348c10>)

    def test_remove_one_child_left(test_bsts):
        """Test delete node one child, left."""
>       test_bsts[4].delete(3)

0-ts/test_bst2.py:167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
bst2:233: in delete
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Node object at 0x7ff228348e80>

>   ???
E   NameError: name 'left' is not defined

bst2:27: NameError
[36m   -[0m [# 259] SVD bst2: 
--------------------------------------------------------------------------------
   23:         return (self.right and self.left)
   24:     
   25:     def _onlychild(self):
   26:         '''Return string depending on children.'''
[34m-  27:         if (self.left and not (self.right)):[0m
[32m+  27:         if (self.left and not right):[0m
   28:             return 'left'
   29:         if (self.right and not (self.left)):
   30:             return 'right'
   31:     
--------------------------------------------------------------------------------
[0.26543 s] [32mkilled[0m by 0-ts/test_bst2.py::test_remove_one_child_left

test_bsts = (<bst2.Bst object at 0x7ff227c5e920>, <bst2.Bst object at 0x7ff227c5e8f0>, <bst2.Bst object at 0x7ff227c5cf10>, <bst2.Bst object at 0x7ff227c5cee0>, <bst2.Bst object at 0x7ff227c5e5c0>, <bst2.Bst object at 0x7ff2282d8640>)

    def test_remove_one_child_left(test_bsts):
        """Test delete node one child, left."""
>       test_bsts[4].delete(3)

0-ts/test_bst2.py:167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
bst2:233: in delete
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Node object at 0x7ff2282db0d0>

>   ???
E   NameError: name 'right' is not defined

bst2:27: NameError
[36m   -[0m [# 260] SVD bst2: 
--------------------------------------------------------------------------------
   25:     def _onlychild(self):
   26:         '''Return string depending on children.'''
   27:         if (self.left and not (self.right)):
   28:             return 'left'
[34m-  29:         if (self.right and not (self.left)):[0m
[32m+  29:         if (right and not (self.left)):[0m
   30:             return 'right'
   31:     
   32:     def _side(self):
   33:         '''Return if left or right child of parent.'''
--------------------------------------------------------------------------------
[0.30652 s] [32mkilled[0m by 0-ts/test_bst2.py::test_remove_one_child_right

test_bsts = (<bst2.Bst object at 0x7ff22811e2f0>, <bst2.Bst object at 0x7ff22811cbe0>, <bst2.Bst object at 0x7ff22811dea0>, <bst2.Bst object at 0x7ff227ecd510>, <bst2.Bst object at 0x7ff227ecdde0>, <bst2.Bst object at 0x7ff227ecc610>)

    def test_remove_one_child_right(test_bsts):
        """Test delete node one child, right."""
>       test_bsts[5].delete(6)

0-ts/test_bst2.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
bst2:233: in delete
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Node object at 0x7ff227ecd150>

>   ???
E   NameError: name 'right' is not defined

bst2:29: NameError
[36m   -[0m [# 261] SVD bst2: 
--------------------------------------------------------------------------------
   25:     def _onlychild(self):
   26:         '''Return string depending on children.'''
   27:         if (self.left and not (self.right)):
   28:             return 'left'
[34m-  29:         if (self.right and not (self.left)):[0m
[32m+  29:         if (self.right and not left):[0m
   30:             return 'right'
   31:     
   32:     def _side(self):
   33:         '''Return if left or right child of parent.'''
--------------------------------------------------------------------------------
[0.24728 s] [32mkilled[0m by 0-ts/test_bst2.py::test_remove_one_child_right

test_bsts = (<bst2.Bst object at 0x7ff2283408b0>, <bst2.Bst object at 0x7ff2283841f0>, <bst2.Bst object at 0x7ff228384940>, <bst2.Bst object at 0x7ff228384580>, <bst2.Bst object at 0x7ff2283865c0>, <bst2.Bst object at 0x7ff228385b40>)

    def test_remove_one_child_right(test_bsts):
        """Test delete node one child, right."""
>       test_bsts[5].delete(6)

0-ts/test_bst2.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
bst2:233: in delete
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Node object at 0x7ff2283859c0>

>   ???
E   NameError: name 'left' is not defined

bst2:29: NameError
[36m   -[0m [# 262] SVD bst2: 
--------------------------------------------------------------------------------
   30:             return 'right'
   31:     
   32:     def _side(self):
   33:         '''Return if left or right child of parent.'''
[34m-  34:         if self.parent:[0m
[32m+  34:         if parent:[0m
   35:             return 'left' if self.parent.left == self else 'right'
   36: 
   37: 
   38: class Bst(object):
--------------------------------------------------------------------------------
[0.34913 s] [32mkilled[0m by 0-ts/test_bst2.py::test_remove_leaf_left

test_bsts = (<bst2.Bst object at 0x7ff22826a8f0>, <bst2.Bst object at 0x7ff22826a440>, <bst2.Bst object at 0x7ff22826b4c0>, <bst2.Bst object at 0x7ff22826bee0>, <bst2.Bst object at 0x7ff228269e40>, <bst2.Bst object at 0x7ff228268250>)

    def test_remove_leaf_left(test_bsts):
        """Test delete leaf on left."""
>       test_bsts[2].delete(3)

0-ts/test_bst2.py:146: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
bst2:222: in delete
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Node object at 0x7ff22826a4d0>

>   ???
E   NameError: name 'parent' is not defined

bst2:34: NameError
[36m   -[0m [# 263] SVD bst2: 
--------------------------------------------------------------------------------
   31:     
   32:     def _side(self):
   33:         '''Return if left or right child of parent.'''
   34:         if self.parent:
[34m-  35:             return 'left' if self.parent.left == self else 'right'[0m
[32m+  35:             return 'left' if parent.left == self else 'right'[0m
   36: 
   37: 
   38: class Bst(object):
   39:     '''Binary Search Tree.
--------------------------------------------------------------------------------
[0.24098 s] [32mkilled[0m by 0-ts/test_bst2.py::test_remove_leaf_left

test_bsts = (<bst2.Bst object at 0x7ff227c46e30>, <bst2.Bst object at 0x7ff227c44220>, <bst2.Bst object at 0x7ff227c47400>, <bst2.Bst object at 0x7ff227c47850>, <bst2.Bst object at 0x7ff227c47d00>, <bst2.Bst object at 0x7ff227c453c0>)

    def test_remove_leaf_left(test_bsts):
        """Test delete leaf on left."""
>       test_bsts[2].delete(3)

0-ts/test_bst2.py:146: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
bst2:222: in delete
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Node object at 0x7ff227c44c70>

>   ???
E   NameError: name 'parent' is not defined

bst2:35: NameError
[36m   -[0m [# 264] SVD bst2: 
--------------------------------------------------------------------------------
   76:     '''
   77:     
   78:     def __init__(self, data=None):
   79:         '''Initialize tree.'''
[34m-  80:         self._size = 0[0m
[32m+  80:         _size = 0[0m
   81:         self.root = None
   82:         
   83:         if data:
   84:             for i in data:
--------------------------------------------------------------------------------
[0.00000 s] [36mincompetent[0m

ValueError: expression must have Store context but has Load instead

[36m   -[0m [# 265] SVD bst2: 
--------------------------------------------------------------------------------
   77:     
   78:     def __init__(self, data=None):
   79:         '''Initialize tree.'''
   80:         self._size = 0
[34m-  81:         self.root = None[0m
[32m+  81:         root = None[0m
   82:         
   83:         if data:
   84:             for i in data:
   85:                 self.insert(i)
--------------------------------------------------------------------------------
[0.00000 s] [36mincompetent[0m

ValueError: expression must have Store context but has Load instead

[36m   -[0m [# 266] SVD bst2: 
--------------------------------------------------------------------------------
   81:         self.root = None
   82:         
   83:         if data:
   84:             for i in data:
[34m-  85:                 self.insert(i)[0m
[32m+  85:                 insert(i)[0m
   86:     
   87:     def insert(self, val):
   88:         '''Insert val into BST. If val is already present will be ignored.'''
   89:         if not (self.root):
--------------------------------------------------------------------------------
[0.23943 s] [32mkilled[0m by 0-ts/test_bst2.py::test_node_is_leaf

@pytest.fixture
    def test_bsts():
        """Fixture for bst."""
        from bst2 import Bst
        empty = Bst()
>       one = Bst([5])

0-ts/test_bst2.py:11: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x7ff227c1b730>, data = [5]

>   ???
E   NameError: name 'insert' is not defined

bst2:85: NameError
[36m   -[0m [# 267] SVD bst2: 
--------------------------------------------------------------------------------
   85:                 self.insert(i)
   86:     
   87:     def insert(self, val):
   88:         '''Insert val into BST. If val is already present will be ignored.'''
[34m-  89:         if not (self.root):[0m
[32m+  89:         if not root:[0m
   90:             self.root = Node(val)
   91:             self._size += 1
   92:         else:
   93:             self._step(val, self.root)
--------------------------------------------------------------------------------
[0.38747 s] [32mkilled[0m by 0-ts/test_bst2.py::test_node_is_leaf

@pytest.fixture
    def test_bsts():
        """Fixture for bst."""
        from bst2 import Bst
        empty = Bst()
>       one = Bst([5])

0-ts/test_bst2.py:11: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
bst2:85: in __init__
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x7ff227aacd60>, val = 5

>   ???
E   NameError: name 'root' is not defined

bst2:89: NameError
[36m   -[0m [# 268] SVD bst2: 
--------------------------------------------------------------------------------
   86:     
   87:     def insert(self, val):
   88:         '''Insert val into BST. If val is already present will be ignored.'''
   89:         if not (self.root):
[34m-  90:             self.root = Node(val)[0m
[32m+  90:             root = Node(val)[0m
   91:             self._size += 1
   92:         else:
   93:             self._step(val, self.root)
   94:     
--------------------------------------------------------------------------------
[0.00000 s] [36mincompetent[0m

ValueError: expression must have Store context but has Load instead

[36m   -[0m [# 269] SVD bst2: 
--------------------------------------------------------------------------------
   87:     def insert(self, val):
   88:         '''Insert val into BST. If val is already present will be ignored.'''
   89:         if not (self.root):
   90:             self.root = Node(val)
[34m-  91:             self._size += 1[0m
[32m+  91:             _size += 1[0m
   92:         else:
   93:             self._step(val, self.root)
   94:     
   95:     def _step(self, val, curr):
--------------------------------------------------------------------------------
[0.00000 s] [36mincompetent[0m

ValueError: expression must have Store context but has Load instead

[36m   -[0m [# 270] SVD bst2: 
--------------------------------------------------------------------------------
   89:         if not (self.root):
   90:             self.root = Node(val)
   91:             self._size += 1
   92:         else:
[34m-  93:             self._step(val, self.root)[0m
[32m+  93:             _step(val, self.root)[0m
   94:     
   95:     def _step(self, val, curr):
   96:         '''Decide left or right and returns height.'''
   97:         if val < curr.val:
--------------------------------------------------------------------------------
[0.19408 s] [32mkilled[0m by 0-ts/test_bst2.py::test_node_is_leaf

@pytest.fixture
    def test_bsts():
        """Fixture for bst."""
        from bst2 import Bst
        empty = Bst()
        one = Bst([5])
>       three = Bst([5, 3, 7])

0-ts/test_bst2.py:12: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
bst2:85: in __init__
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x7ff228389240>, val = 3

>   ???
E   NameError: name '_step' is not defined

bst2:93: NameError
[36m   -[0m [# 271] SVD bst2: 
--------------------------------------------------------------------------------
   89:         if not (self.root):
   90:             self.root = Node(val)
   91:             self._size += 1
   92:         else:
[34m-  93:             self._step(val, self.root)[0m
[32m+  93:             self._step(val, root)[0m
   94:     
   95:     def _step(self, val, curr):
   96:         '''Decide left or right and returns height.'''
   97:         if val < curr.val:
--------------------------------------------------------------------------------
[0.22138 s] [32mkilled[0m by 0-ts/test_bst2.py::test_node_is_leaf

@pytest.fixture
    def test_bsts():
        """Fixture for bst."""
        from bst2 import Bst
        empty = Bst()
        one = Bst([5])
>       three = Bst([5, 3, 7])

0-ts/test_bst2.py:12: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
bst2:85: in __init__
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x7ff227df1cf0>, val = 3

>   ???
E   NameError: name 'root' is not defined

bst2:93: NameError
[36m   -[0m [# 272] SVD bst2: 
--------------------------------------------------------------------------------
   94:     
   95:     def _step(self, val, curr):
   96:         '''Decide left or right and returns height.'''
   97:         if val < curr.val:
[34m-  98:             curr = self._set_child(curr, 'left', val)[0m
[32m+  98:             curr = _set_child(curr, 'left', val)[0m
   99:         elif val > curr.val:
  100:             curr = self._set_child(curr, 'right', val)
  101:         return curr.height
  102:     
--------------------------------------------------------------------------------
[0.24727 s] [32mkilled[0m by 0-ts/test_bst2.py::test_node_is_leaf

@pytest.fixture
    def test_bsts():
        """Fixture for bst."""
        from bst2 import Bst
        empty = Bst()
        one = Bst([5])
>       three = Bst([5, 3, 7])

0-ts/test_bst2.py:12: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
bst2:85: in __init__
    ???
bst2:93: in insert
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x7ff227d02920>, val = 3
curr = <bst2.Node object at 0x7ff227d01ae0>

>   ???
E   NameError: name '_set_child' is not defined

bst2:98: NameError
[36m   -[0m [# 273] SVD bst2: 
--------------------------------------------------------------------------------
   96:         '''Decide left or right and returns height.'''
   97:         if val < curr.val:
   98:             curr = self._set_child(curr, 'left', val)
   99:         elif val > curr.val:
[34m- 100:             curr = self._set_child(curr, 'right', val)[0m
[32m+ 100:             curr = _set_child(curr, 'right', val)[0m
  101:         return curr.height
  102:     
  103:     def _set_child(self, curr, side, val):
  104:         '''Helping.'''
--------------------------------------------------------------------------------
[0.25127 s] [32mkilled[0m by 0-ts/test_bst2.py::test_node_is_leaf

@pytest.fixture
    def test_bsts():
        """Fixture for bst."""
        from bst2 import Bst
        empty = Bst()
        one = Bst([5])
>       three = Bst([5, 3, 7])

0-ts/test_bst2.py:12: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
bst2:85: in __init__
    ???
bst2:93: in insert
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x7ff227e3a770>, val = 7
curr = <bst2.Node object at 0x7ff227e398d0>

>   ???
E   NameError: name '_set_child' is not defined

bst2:100: NameError
[36m   -[0m [# 274] SVD bst2: 
--------------------------------------------------------------------------------
  103:     def _set_child(self, curr, side, val):
  104:         '''Helping.'''
  105:         child = getattr(curr, side)
  106:         if child:
[34m- 107:             count = self._step(val, child)[0m
[32m+ 107:             count = _step(val, child)[0m
  108:             if curr.height <= count:
  109:                 curr.height += 1
  110:         else:
  111:             setattr(curr, side, Node(val, curr))
--------------------------------------------------------------------------------
[0.22297 s] [32mkilled[0m by 0-ts/test_bst2.py::test_node_is_leaf

@pytest.fixture
    def test_bsts():
        """Fixture for bst."""
        from bst2 import Bst
        empty = Bst()
        one = Bst([5])
        three = Bst([5, 3, 7])
>       balance = Bst([5, 3, 2, 4, 9, 7, 10])

0-ts/test_bst2.py:13: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
bst2:85: in __init__
    ???
bst2:93: in insert
    ???
bst2:98: in _step
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x7ff228349bd0>
curr = <bst2.Node object at 0x7ff228348100>, side = 'left', val = 2

>   ???
E   NameError: name '_step' is not defined

bst2:107: NameError
[36m   -[0m [# 275] SVD bst2: 
--------------------------------------------------------------------------------
  108:             if curr.height <= count:
  109:                 curr.height += 1
  110:         else:
  111:             setattr(curr, side, Node(val, curr))
[34m- 112:             self._size += 1[0m
[32m+ 112:             _size += 1[0m
  113:             if curr.height == 1:
  114:                 curr.height += 1
  115:         return curr
  116:     
--------------------------------------------------------------------------------
[0.00000 s] [36mincompetent[0m

ValueError: expression must have Store context but has Load instead

[36m   -[0m [# 276] SVD bst2: 
--------------------------------------------------------------------------------
  115:         return curr
  116:     
  117:     def search(self, val):
  118:         '''Return the node containing val.'''
[34m- 119:         curr = self.root[0m
[32m+ 119:         curr = root[0m
  120:         while curr:
  121:             if curr.val == val:
  122:                 return curr
  123:             elif val < curr.val:
--------------------------------------------------------------------------------
[0.37990 s] [32mkilled[0m by 0-ts/test_bst2.py::test_contains_method

test_bsts = (<bst2.Bst object at 0x7ff227ecd2a0>, <bst2.Bst object at 0x7ff227ecc700>, <bst2.Bst object at 0x7ff227ecc910>, <bst2.Bst object at 0x7ff227ecc670>, <bst2.Bst object at 0x7ff227ecdb70>, <bst2.Bst object at 0x7ff227ecc9d0>)

    def test_contains_method(test_bsts):
        """Test contains on number that exists."""
>       assert test_bsts[2].contains(5)

0-ts/test_bst2.py:72: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
bst2:138: in contains
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x7ff227ecc910>, val = 5

>   ???
E   NameError: name 'root' is not defined

bst2:119: NameError
[36m   -[0m [# 277] SVD bst2: 
--------------------------------------------------------------------------------
  126:                 curr = curr.right
  127:     
  128:     def size(self):
  129:         '''Return the size of the BST.'''
[34m- 130:         return self._size[0m
[32m+ 130:         return _size[0m
  131:     
  132:     def depth(self):
  133:         '''Return depth of the BST, representing total levels.'''
  134:         return 0 if not (self.root) else self.root.height
--------------------------------------------------------------------------------
[0.24304 s] [32mkilled[0m by 0-ts/test_bst2.py::test_insert_increases_size

test_bsts = (<bst2.Bst object at 0x7ff2282d8a00>, <bst2.Bst object at 0x7ff2282da470>, <bst2.Bst object at 0x7ff2282d9ff0>, <bst2.Bst object at 0x7ff2282d9c60>, <bst2.Bst object at 0x7ff2282daad0>, <bst2.Bst object at 0x7ff2282d83a0>)

    def test_insert_increases_size(test_bsts):
        """Test insert increases size."""
        test_bsts[0].insert(4)
>       assert test_bsts[0].size() == 1

0-ts/test_bst2.py:67: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x7ff2282d8a00>

>   ???
E   NameError: name '_size' is not defined

bst2:130: NameError
[36m   -[0m [# 278] SVD bst2: 
--------------------------------------------------------------------------------
  130:         return self._size
  131:     
  132:     def depth(self):
  133:         '''Return depth of the BST, representing total levels.'''
[34m- 134:         return 0 if not (self.root) else self.root.height[0m
[32m+ 134:         return 0 if not root else self.root.height[0m
  135:     
  136:     def contains(self, val):
  137:         '''Return true if val is in the bst.'''
  138:         return self.search(val) is not None
--------------------------------------------------------------------------------
[0.25565 s] [32mkilled[0m by 0-ts/test_bst2.py::test_depth_method

test_bsts = (<bst2.Bst object at 0x7ff22827af50>, <bst2.Bst object at 0x7ff22827b310>, <bst2.Bst object at 0x7ff228278df0>, <bst2.Bst object at 0x7ff228278490>, <bst2.Bst object at 0x7ff22827af20>, <bst2.Bst object at 0x7ff228279d80>)

    def test_depth_method(test_bsts):
        """Test depth method."""
        depths = [0, 1, 2, 3, 4, 6]
>       assert all(tree.depth() == depths[idx]
                   for idx, tree in enumerate(test_bsts))

0-ts/test_bst2.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
0-ts/test_bst2.py:85: in <genexpr>
    assert all(tree.depth() == depths[idx]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x7ff22827af50>

>   ???
E   NameError: name 'root' is not defined

bst2:134: NameError
[36m   -[0m [# 279] SVD bst2: 
--------------------------------------------------------------------------------
  130:         return self._size
  131:     
  132:     def depth(self):
  133:         '''Return depth of the BST, representing total levels.'''
[34m- 134:         return 0 if not (self.root) else self.root.height[0m
[32m+ 134:         return 0 if not (self.root) else root.height[0m
  135:     
  136:     def contains(self, val):
  137:         '''Return true if val is in the bst.'''
  138:         return self.search(val) is not None
--------------------------------------------------------------------------------
[0.31016 s] [32mkilled[0m by 0-ts/test_bst2.py::test_depth_method

test_bsts = (<bst2.Bst object at 0x7ff227cb9f30>, <bst2.Bst object at 0x7ff227cb8250>, <bst2.Bst object at 0x7ff227cbac80>, <bst2.Bst object at 0x7ff227e102b0>, <bst2.Bst object at 0x7ff227e10640>, <bst2.Bst object at 0x7ff227e10af0>)

    def test_depth_method(test_bsts):
        """Test depth method."""
        depths = [0, 1, 2, 3, 4, 6]
>       assert all(tree.depth() == depths[idx]
                   for idx, tree in enumerate(test_bsts))

0-ts/test_bst2.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
0-ts/test_bst2.py:85: in <genexpr>
    assert all(tree.depth() == depths[idx]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x7ff227cb8250>

>   ???
E   NameError: name 'root' is not defined

bst2:134: NameError
[36m   -[0m [# 280] SVD bst2: 
--------------------------------------------------------------------------------
  134:         return 0 if not (self.root) else self.root.height
  135:     
  136:     def contains(self, val):
  137:         '''Return true if val is in the bst.'''
[34m- 138:         return self.search(val) is not None[0m
[32m+ 138:         return search(val) is not None[0m
  139:     
  140:     def balance(self, tree=None):
  141:         '''Return an integer of how well the tree is balanced.
  142: 
--------------------------------------------------------------------------------
[0.21351 s] [32mkilled[0m by 0-ts/test_bst2.py::test_contains_method

test_bsts = (<bst2.Bst object at 0x7ff227d00fd0>, <bst2.Bst object at 0x7ff227d00310>, <bst2.Bst object at 0x7ff227d005e0>, <bst2.Bst object at 0x7ff227d00a30>, <bst2.Bst object at 0x7ff227d00f70>, <bst2.Bst object at 0x7ff227d01480>)

    def test_contains_method(test_bsts):
        """Test contains on number that exists."""
>       assert test_bsts[2].contains(5)

0-ts/test_bst2.py:72: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x7ff227d005e0>, val = 5

>   ???
E   NameError: name 'search' is not defined

bst2:138: NameError
[36m   -[0m [# 281] SVD bst2: 
--------------------------------------------------------------------------------
  145:         should return a negative value. An ideally-balanced tree should
  146:         return 0.
  147:         '''
  148:         if not tree:
[34m- 149:             tree = self.root[0m
[32m+ 149:             tree = root[0m
  150:             if not tree:
  151:                 return 0
  152:         
  153:         leftbranch = 0 if not (tree.left) else tree.left.height
--------------------------------------------------------------------------------
[0.32926 s] [32mkilled[0m by 0-ts/test_bst2.py::test_balance_method

test_bsts = (<bst2.Bst object at 0x7ff227f45c00>, <bst2.Bst object at 0x7ff227f47490>, <bst2.Bst object at 0x7ff227f45e10>, <bst2.Bst object at 0x7ff227f44ee0>, <bst2.Bst object at 0x7ff227f442b0>, <bst2.Bst object at 0x7ff227f45420>)

    def test_balance_method(test_bsts):
        """Test the balance method."""
        balance = [0, 0, 0, 0, 3, -5]
>       assert all(tree.balance() == balance[idx]
                   for idx, tree in enumerate(test_bsts))

0-ts/test_bst2.py:92: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
0-ts/test_bst2.py:92: in <genexpr>
    assert all(tree.balance() == balance[idx]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x7ff227f45c00>, tree = None

>   ???
E   NameError: name 'root' is not defined

bst2:149: NameError
[36m   -[0m [# 282] SVD bst2: 
--------------------------------------------------------------------------------
  157:     
  158:     def pre_order(self, node='root'):
  159:         '''Depth first pre-order traversal of tree.'''
  160:         if node == 'root':
[34m- 161:             node = self.root[0m
[32m+ 161:             node = root[0m
  162:         
  163:         if not node:
  164:             return
  165:         
--------------------------------------------------------------------------------
[0.21073 s] [32mkilled[0m by 0-ts/test_bst2.py::test_pre_order

test_traversals = {'breadth': ['F', 'B', 'G', 'A', 'D', 'I', ...], 'empty': <bst2.Bst object at 0x7ff2280ce590>, 'in_order': ['A', 'B', 'C', 'D', 'E', 'F', ...], 'post_order': ['A', 'C', 'E', 'D', 'B', 'H', ...], ...}

    def test_pre_order(test_traversals):
        """Test preorder for a traversal."""
>       path = [i for i in test_traversals['tree'].pre_order()]

0-ts/test_bst2.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
0-ts/test_bst2.py:103: in <listcomp>
    path = [i for i in test_traversals['tree'].pre_order()]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x7ff2280cc9d0>, node = 'root'

>   ???
E   NameError: name 'root' is not defined

bst2:161: NameError
[36m   -[0m [# 283] SVD bst2: 
--------------------------------------------------------------------------------
  164:             return
  165:         
  166:         yield node.val
  167:         
[34m- 168:         for n in self.pre_order(node=node.left):[0m
[32m+ 168:         for n in pre_order(node=node.left):[0m
  169:             yield n
  170:         for n in self.pre_order(node=node.right):
  171:             yield n
  172:     
--------------------------------------------------------------------------------
[0.22756 s] [32mkilled[0m by 0-ts/test_bst2.py::test_pre_order

test_traversals = {'breadth': ['F', 'B', 'G', 'A', 'D', 'I', ...], 'empty': <bst2.Bst object at 0x7ff227b03370>, 'in_order': ['A', 'B', 'C', 'D', 'E', 'F', ...], 'post_order': ['A', 'C', 'E', 'D', 'B', 'H', ...], ...}

    def test_pre_order(test_traversals):
        """Test preorder for a traversal."""
>       path = [i for i in test_traversals['tree'].pre_order()]

0-ts/test_bst2.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
0-ts/test_bst2.py:103: in <listcomp>
    path = [i for i in test_traversals['tree'].pre_order()]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x7ff227b00550>
node = <bst2.Node object at 0x7ff227b03d30>

>   ???
E   NameError: name 'pre_order' is not defined

bst2:168: NameError
[36m   -[0m [# 284] SVD bst2: 
--------------------------------------------------------------------------------
  166:         yield node.val
  167:         
  168:         for n in self.pre_order(node=node.left):
  169:             yield n
[34m- 170:         for n in self.pre_order(node=node.right):[0m
[32m+ 170:         for n in pre_order(node=node.right):[0m
  171:             yield n
  172:     
  173:     def in_order(self, node='root'):
  174:         '''Depth first in-order traversal of tree.'''
--------------------------------------------------------------------------------
[0.24302 s] [32mkilled[0m by 0-ts/test_bst2.py::test_pre_order

test_traversals = {'breadth': ['F', 'B', 'G', 'A', 'D', 'I', ...], 'empty': <bst2.Bst object at 0x7ff227de2410>, 'in_order': ['A', 'B', 'C', 'D', 'E', 'F', ...], 'post_order': ['A', 'C', 'E', 'D', 'B', 'H', ...], ...}

    def test_pre_order(test_traversals):
        """Test preorder for a traversal."""
>       path = [i for i in test_traversals['tree'].pre_order()]

0-ts/test_bst2.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
0-ts/test_bst2.py:103: in <listcomp>
    path = [i for i in test_traversals['tree'].pre_order()]
bst2:168: in pre_order
    ???
bst2:168: in pre_order
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x7ff227de1f60>
node = <bst2.Node object at 0x7ff227de2740>

>   ???
E   NameError: name 'pre_order' is not defined

bst2:170: NameError
[36m   -[0m [# 285] SVD bst2: 
--------------------------------------------------------------------------------
  172:     
  173:     def in_order(self, node='root'):
  174:         '''Depth first in-order traversal of tree.'''
  175:         if node == 'root':
[34m- 176:             node = self.root[0m
[32m+ 176:             node = root[0m
  177:         
  178:         if not node:
  179:             return
  180:         
--------------------------------------------------------------------------------
[0.35963 s] [32mkilled[0m by 0-ts/test_bst2.py::test_in_order

test_traversals = {'breadth': ['F', 'B', 'G', 'A', 'D', 'I', ...], 'empty': <bst2.Bst object at 0x7ff227eb0460>, 'in_order': ['A', 'B', 'C', 'D', 'E', 'F', ...], 'post_order': ['A', 'C', 'E', 'D', 'B', 'H', ...], ...}

    def test_in_order(test_traversals):
        """Test inorder for a traversal."""
>       path = [i for i in test_traversals['tree'].in_order()]

0-ts/test_bst2.py:109: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
0-ts/test_bst2.py:109: in <listcomp>
    path = [i for i in test_traversals['tree'].in_order()]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x7ff227eb04c0>, node = 'root'

>   ???
E   NameError: name 'root' is not defined

bst2:176: NameError
[36m   -[0m [# 286] SVD bst2: 
--------------------------------------------------------------------------------
  177:         
  178:         if not node:
  179:             return
  180:         
[34m- 181:         for n in self.in_order(node=node.left):[0m
[32m+ 181:         for n in in_order(node=node.left):[0m
  182:             yield n
  183:         yield node.val
  184:         for n in self.in_order(node=node.right):
  185:             yield n
--------------------------------------------------------------------------------
[0.24644 s] [32mkilled[0m by 0-ts/test_bst2.py::test_in_order

test_traversals = {'breadth': ['F', 'B', 'G', 'A', 'D', 'I', ...], 'empty': <bst2.Bst object at 0x7ff22820b430>, 'in_order': ['A', 'B', 'C', 'D', 'E', 'F', ...], 'post_order': ['A', 'C', 'E', 'D', 'B', 'H', ...], ...}

    def test_in_order(test_traversals):
        """Test inorder for a traversal."""
>       path = [i for i in test_traversals['tree'].in_order()]

0-ts/test_bst2.py:109: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
0-ts/test_bst2.py:109: in <listcomp>
    path = [i for i in test_traversals['tree'].in_order()]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x7ff228208520>
node = <bst2.Node object at 0x7ff228208070>

>   ???
E   NameError: name 'in_order' is not defined

bst2:181: NameError
[36m   -[0m [# 287] SVD bst2: 
--------------------------------------------------------------------------------
  180:         
  181:         for n in self.in_order(node=node.left):
  182:             yield n
  183:         yield node.val
[34m- 184:         for n in self.in_order(node=node.right):[0m
[32m+ 184:         for n in in_order(node=node.right):[0m
  185:             yield n
  186:     
  187:     def post_order(self, node='root'):
  188:         '''Depth frist post_order traversal of tree.'''
--------------------------------------------------------------------------------
[0.24785 s] [32mkilled[0m by 0-ts/test_bst2.py::test_in_order

test_traversals = {'breadth': ['F', 'B', 'G', 'A', 'D', 'I', ...], 'empty': <bst2.Bst object at 0x7ff227d75d80>, 'in_order': ['A', 'B', 'C', 'D', 'E', 'F', ...], 'post_order': ['A', 'C', 'E', 'D', 'B', 'H', ...], ...}

    def test_in_order(test_traversals):
        """Test inorder for a traversal."""
>       path = [i for i in test_traversals['tree'].in_order()]

0-ts/test_bst2.py:109: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
0-ts/test_bst2.py:109: in <listcomp>
    path = [i for i in test_traversals['tree'].in_order()]
bst2:181: in in_order
    ???
bst2:181: in in_order
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x7ff227d76110>
node = <bst2.Node object at 0x7ff227d750f0>

>   ???
E   NameError: name 'in_order' is not defined

bst2:184: NameError
[36m   -[0m [# 288] SVD bst2: 
--------------------------------------------------------------------------------
  186:     
  187:     def post_order(self, node='root'):
  188:         '''Depth frist post_order traversal of tree.'''
  189:         if node == 'root':
[34m- 190:             node = self.root[0m
[32m+ 190:             node = root[0m
  191:         
  192:         if not node:
  193:             return
  194:         
--------------------------------------------------------------------------------
[0.22051 s] [32mkilled[0m by 0-ts/test_bst2.py::test_post_order

test_traversals = {'breadth': ['F', 'B', 'G', 'A', 'D', 'I', ...], 'empty': <bst2.Bst object at 0x7ff22811eb90>, 'in_order': ['A', 'B', 'C', 'D', 'E', 'F', ...], 'post_order': ['A', 'C', 'E', 'D', 'B', 'H', ...], ...}

    def test_post_order(test_traversals):
        """Test postorder for a traversal."""
>       path = [i for i in test_traversals['tree'].post_order()]

0-ts/test_bst2.py:115: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
0-ts/test_bst2.py:115: in <listcomp>
    path = [i for i in test_traversals['tree'].post_order()]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x7ff22811f340>, node = 'root'

>   ???
E   NameError: name 'root' is not defined

bst2:190: NameError
[36m   -[0m [# 289] SVD bst2: 
--------------------------------------------------------------------------------
  191:         
  192:         if not node:
  193:             return
  194:         
[34m- 195:         for n in self.post_order(node=node.left):[0m
[32m+ 195:         for n in post_order(node=node.left):[0m
  196:             yield n
  197:         for n in self.post_order(node=node.right):
  198:             yield n
  199:         yield node.val
--------------------------------------------------------------------------------
[0.23420 s] [32mkilled[0m by 0-ts/test_bst2.py::test_post_order

test_traversals = {'breadth': ['F', 'B', 'G', 'A', 'D', 'I', ...], 'empty': <bst2.Bst object at 0x7ff227bffe80>, 'in_order': ['A', 'B', 'C', 'D', 'E', 'F', ...], 'post_order': ['A', 'C', 'E', 'D', 'B', 'H', ...], ...}

    def test_post_order(test_traversals):
        """Test postorder for a traversal."""
>       path = [i for i in test_traversals['tree'].post_order()]

0-ts/test_bst2.py:115: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
0-ts/test_bst2.py:115: in <listcomp>
    path = [i for i in test_traversals['tree'].post_order()]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x7ff227bff190>
node = <bst2.Node object at 0x7ff227c18070>

>   ???
E   NameError: name 'post_order' is not defined

bst2:195: NameError
[36m   -[0m [# 290] SVD bst2: 
--------------------------------------------------------------------------------
  193:             return
  194:         
  195:         for n in self.post_order(node=node.left):
  196:             yield n
[34m- 197:         for n in self.post_order(node=node.right):[0m
[32m+ 197:         for n in post_order(node=node.right):[0m
  198:             yield n
  199:         yield node.val
  200:     
  201:     def breadth_first(self):
--------------------------------------------------------------------------------
[0.32632 s] [32mkilled[0m by 0-ts/test_bst2.py::test_post_order

test_traversals = {'breadth': ['F', 'B', 'G', 'A', 'D', 'I', ...], 'empty': <bst2.Bst object at 0x7ff22826bd30>, 'in_order': ['A', 'B', 'C', 'D', 'E', 'F', ...], 'post_order': ['A', 'C', 'E', 'D', 'B', 'H', ...], ...}

    def test_post_order(test_traversals):
        """Test postorder for a traversal."""
>       path = [i for i in test_traversals['tree'].post_order()]

0-ts/test_bst2.py:115: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
0-ts/test_bst2.py:115: in <listcomp>
    path = [i for i in test_traversals['tree'].post_order()]
bst2:195: in post_order
    ???
bst2:195: in post_order
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x7ff22826bb20>
node = <bst2.Node object at 0x7ff22826be20>

>   ???
E   NameError: name 'post_order' is not defined

bst2:197: NameError
[36m   -[0m [# 291] SVD bst2: 
--------------------------------------------------------------------------------
  200:     
  201:     def breadth_first(self):
  202:         '''Breadth first traversal of tree.'''
  203:         q = Queue()
[34m- 204:         q.enqueue(self.root)[0m
[32m+ 204:         q.enqueue(root)[0m
  205:         while q.peek():
  206:             node = q.dequeue()
  207:             yield node.val
  208:             if node.left:
--------------------------------------------------------------------------------
[0.23381 s] [32mkilled[0m by 0-ts/test_bst2.py::test_breadth_first

test_traversals = {'breadth': ['F', 'B', 'G', 'A', 'D', 'I', ...], 'empty': <bst2.Bst object at 0x7ff227d648b0>, 'in_order': ['A', 'B', 'C', 'D', 'E', 'F', ...], 'post_order': ['A', 'C', 'E', 'D', 'B', 'H', ...], ...}

    def test_breadth_first(test_traversals):
        """Test breadth first for a traversal."""
>       path = [i for i in test_traversals['tree'].breadth_first()]

0-ts/test_bst2.py:121: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
0-ts/test_bst2.py:121: in <listcomp>
    path = [i for i in test_traversals['tree'].breadth_first()]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x7ff227d65d80>

>   ???
E   NameError: name 'root' is not defined

bst2:204: NameError
[36m   -[0m [# 292] SVD bst2: 
--------------------------------------------------------------------------------
  211:                 q.enqueue(node.right)
  212:     
  213:     def delete(self, val):
  214:         '''Remove a node from the tree.'''
[34m- 215:         if (self._size < 1 or not (self.contains(val))):[0m
[32m+ 215:         if (_size < 1 or not (self.contains(val))):[0m
  216:             return
  217:         
  218:         node = self.search(val)
  219:         
--------------------------------------------------------------------------------
[0.30235 s] [32mkilled[0m by 0-ts/test_bst2.py::test_del_false

test_bsts = (<bst2.Bst object at 0x7ff22834a530>, <bst2.Bst object at 0x7ff2283491e0>, <bst2.Bst object at 0x7ff22834aec0>, <bst2.Bst object at 0x7ff22834bf10>, <bst2.Bst object at 0x7ff22834bac0>, <bst2.Bst object at 0x7ff2283480a0>)

    def test_del_false(test_bsts):
        """Test delete for a node not in tree."""
        size = test_bsts[2].size()
>       test_bsts[2].delete(1)

0-ts/test_bst2.py:134: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x7ff22834aec0>, val = 1

>   ???
E   NameError: name '_size' is not defined

bst2:215: NameError
[36m   -[0m [# 293] SVD bst2: 
--------------------------------------------------------------------------------
  211:                 q.enqueue(node.right)
  212:     
  213:     def delete(self, val):
  214:         '''Remove a node from the tree.'''
[34m- 215:         if (self._size < 1 or not (self.contains(val))):[0m
[32m+ 215:         if (self._size < 1 or not (contains(val))):[0m
  216:             return
  217:         
  218:         node = self.search(val)
  219:         
--------------------------------------------------------------------------------
[0.26446 s] [32mkilled[0m by 0-ts/test_bst2.py::test_del_false

test_bsts = (<bst2.Bst object at 0x7ff227dac160>, <bst2.Bst object at 0x7ff227dad870>, <bst2.Bst object at 0x7ff227daf4c0>, <bst2.Bst object at 0x7ff227dac430>, <bst2.Bst object at 0x7ff227dad6f0>, <bst2.Bst object at 0x7ff227dafe80>)

    def test_del_false(test_bsts):
        """Test delete for a node not in tree."""
        size = test_bsts[2].size()
>       test_bsts[2].delete(1)

0-ts/test_bst2.py:134: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x7ff227daf4c0>, val = 1

>   ???
E   NameError: name 'contains' is not defined

bst2:215: NameError
[36m   -[0m [# 294] SVD bst2: 
--------------------------------------------------------------------------------
  214:         '''Remove a node from the tree.'''
  215:         if (self._size < 1 or not (self.contains(val))):
  216:             return
  217:         
[34m- 218:         node = self.search(val)[0m
[32m+ 218:         node = search(val)[0m
  219:         
  220:         if node._is_leaf():
  221:             if node.parent:
  222:                 setattr(node.parent, node._side(), None)
--------------------------------------------------------------------------------
[0.24796 s] [32mkilled[0m by 0-ts/test_bst2.py::test_remove_leaf_left

test_bsts = (<bst2.Bst object at 0x7ff227d4e3b0>, <bst2.Bst object at 0x7ff227d4e290>, <bst2.Bst object at 0x7ff227d4f4f0>, <bst2.Bst object at 0x7ff227d4fcd0>, <bst2.Bst object at 0x7ff227d4df30>, <bst2.Bst object at 0x7ff227d4dae0>)

    def test_remove_leaf_left(test_bsts):
        """Test delete leaf on left."""
>       test_bsts[2].delete(3)

0-ts/test_bst2.py:146: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x7ff227d4f4f0>, val = 3

>   ???
E   NameError: name 'search' is not defined

bst2:218: NameError
[36m   -[0m [# 295] SVD bst2: 
--------------------------------------------------------------------------------
  220:         if node._is_leaf():
  221:             if node.parent:
  222:                 setattr(node.parent, node._side(), None)
  223:             else:
[34m- 224:                 self.root = None[0m
[32m+ 224:                 root = None[0m
  225:         
  226:         elif node._is_interior():
  227:             next_node = self._find_replacement(node)
  228:             self._size += 1
--------------------------------------------------------------------------------
[0.00000 s] [36mincompetent[0m

ValueError: expression must have Store context but has Load instead

[36m   -[0m [# 296] SVD bst2: 
--------------------------------------------------------------------------------
  223:             else:
  224:                 self.root = None
  225:         
  226:         elif node._is_interior():
[34m- 227:             next_node = self._find_replacement(node)[0m
[32m+ 227:             next_node = _find_replacement(node)[0m
  228:             self._size += 1
  229:             self.delete(next_node.val)
  230:             node.val = next_node.val
  231:         else:
--------------------------------------------------------------------------------
[0.24749 s] [32mkilled[0m by 0-ts/test_bst2.py::test_delete_two_children

test_bsts = (<bst2.Bst object at 0x7ff227c44370>, <bst2.Bst object at 0x7ff227c44eb0>, <bst2.Bst object at 0x7ff227c462f0>, <bst2.Bst object at 0x7ff227c44af0>, <bst2.Bst object at 0x7ff227c46c80>, <bst2.Bst object at 0x7ff227c45090>)

    def test_delete_two_children(test_bsts):
        """Test delete node with two children."""
>       test_bsts[3].delete(3)

0-ts/test_bst2.py:208: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x7ff227c44af0>, val = 3

>   ???
E   NameError: name '_find_replacement' is not defined

bst2:227: NameError
[36m   -[0m [# 297] SVD bst2: 
--------------------------------------------------------------------------------
  224:                 self.root = None
  225:         
  226:         elif node._is_interior():
  227:             next_node = self._find_replacement(node)
[34m- 228:             self._size += 1[0m
[32m+ 228:             _size += 1[0m
  229:             self.delete(next_node.val)
  230:             node.val = next_node.val
  231:         else:
  232:             
--------------------------------------------------------------------------------
[0.00000 s] [36mincompetent[0m

ValueError: expression must have Store context but has Load instead

[36m   -[0m [# 298] SVD bst2: 
--------------------------------------------------------------------------------
  225:         
  226:         elif node._is_interior():
  227:             next_node = self._find_replacement(node)
  228:             self._size += 1
[34m- 229:             self.delete(next_node.val)[0m
[32m+ 229:             delete(next_node.val)[0m
  230:             node.val = next_node.val
  231:         else:
  232:             
  233:             child = getattr(node, node._onlychild())
--------------------------------------------------------------------------------
[0.26506 s] [32mkilled[0m by 0-ts/test_bst2.py::test_delete_two_children

test_bsts = (<bst2.Bst object at 0x7ff227e90790>, <bst2.Bst object at 0x7ff227e91f60>, <bst2.Bst object at 0x7ff227e904c0>, <bst2.Bst object at 0x7ff227e925c0>, <bst2.Bst object at 0x7ff227e903d0>, <bst2.Bst object at 0x7ff227e937f0>)

    def test_delete_two_children(test_bsts):
        """Test delete node with two children."""
>       test_bsts[3].delete(3)

0-ts/test_bst2.py:208: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x7ff227e925c0>, val = 3

>   ???
E   NameError: name 'delete' is not defined

bst2:229: NameError
[36m   -[0m [# 299] SVD bst2: 
--------------------------------------------------------------------------------
  234:             if node.parent:
  235:                 child.parent = node.parent
  236:                 setattr(node.parent, node._side(), child)
  237:             else:
[34m- 238:                 self.root = child[0m
[32m+ 238:                 root = child[0m
  239:         
  240:         self._size -= 1
  241:     
  242:     def _find_replacement(self, node):
--------------------------------------------------------------------------------
[0.00000 s] [36mincompetent[0m

ValueError: expression must have Store context but has Load instead

[36m   -[0m [# 300] SVD bst2: 
--------------------------------------------------------------------------------
  236:                 setattr(node.parent, node._side(), child)
  237:             else:
  238:                 self.root = child
  239:         
[34m- 240:         self._size -= 1[0m
[32m+ 240:         _size -= 1[0m
  241:     
  242:     def _find_replacement(self, node):
  243:         '''Find left most node of right subtree.'''
  244:         if node.right:
--------------------------------------------------------------------------------
[0.00000 s] [36mincompetent[0m

ValueError: expression must have Store context but has Load instead

[36m   -[0m [# 301] SVD bst2: 
--------------------------------------------------------------------------------
  241:     
  242:     def _find_replacement(self, node):
  243:         '''Find left most node of right subtree.'''
  244:         if node.right:
[34m- 245:             return self._findmin(node.right)[0m
[32m+ 245:             return _findmin(node.right)[0m
  246:         
  247:         elif node.parent:
  248:             if node._side() == 'left':
  249:                 return self.parent
--------------------------------------------------------------------------------
[0.28027 s] [32mkilled[0m by 0-ts/test_bst2.py::test_delete_two_children

test_bsts = (<bst2.Bst object at 0x7ff227b02800>, <bst2.Bst object at 0x7ff227daff70>, <bst2.Bst object at 0x7ff227dad150>, <bst2.Bst object at 0x7ff228036dd0>, <bst2.Bst object at 0x7ff2280374c0>, <bst2.Bst object at 0x7ff228035e40>)

    def test_delete_two_children(test_bsts):
        """Test delete node with two children."""
>       test_bsts[3].delete(3)

0-ts/test_bst2.py:208: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
bst2:227: in delete
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x7ff228036dd0>
node = <bst2.Node object at 0x7ff228035450>

>   ???
E   NameError: name '_findmin' is not defined

bst2:245: NameError
[36m   -[0m [# 302] SVD bst2: 
--------------------------------------------------------------------------------
  245:             return self._findmin(node.right)
  246:         
  247:         elif node.parent:
  248:             if node._side() == 'left':
[34m- 249:                 return self.parent[0m
[32m+ 249:                 return parent[0m
  250:             else:
  251:                 node.parent.right = None
  252:                 tmp = self._find_replacement(node.parent)
  253:                 node.parent.right = node
--------------------------------------------------------------------------------
[0.21295 s] [31msurvived[0m
[36m   -[0m [# 303] SVD bst2: 
--------------------------------------------------------------------------------
  248:             if node._side() == 'left':
  249:                 return self.parent
  250:             else:
  251:                 node.parent.right = None
[34m- 252:                 tmp = self._find_replacement(node.parent)[0m
[32m+ 252:                 tmp = _find_replacement(node.parent)[0m
  253:                 node.parent.right = node
  254:                 return tmp
  255:     
  256:     def _findmin(self, node):
--------------------------------------------------------------------------------
[0.20341 s] [31msurvived[0m
[36m   -[0m [# 304] ZIL bst2: 
--------------------------------------------------------------------------------
   81:         self.root = None
   82:         
   83:         if data:
   84:             for i in data:
[34m-  85:                 self.insert(i)[0m
[32m+  85:                 break[0m
   86:     
   87:     def insert(self, val):
   88:         '''Insert val into BST. If val is already present will be ignored.'''
   89:         if not (self.root):
--------------------------------------------------------------------------------
[0.21257 s] [32mkilled[0m by 0-ts/test_bst2.py::test_node_is_leaf

test_bsts = (<bst2.Bst object at 0x7ff22815d930>, <bst2.Bst object at 0x7ff22815c2b0>, <bst2.Bst object at 0x7ff22815dab0>, <bst2.Bst object at 0x7ff22815c400>, <bst2.Bst object at 0x7ff22815c040>, <bst2.Bst object at 0x7ff22815e380>)

    def test_node_is_leaf(test_bsts):
        """Test node is leaf bst."""
>       assert test_bsts[1].root._is_leaf()
E       AttributeError: 'NoneType' object has no attribute '_is_leaf'

0-ts/test_bst2.py:36: AttributeError
[36m   -[0m [# 305] ZIL bst2: 
--------------------------------------------------------------------------------
  117:     def search(self, val):
  118:         '''Return the node containing val.'''
  119:         curr = self.root
  120:         while curr:
[34m- 121:             if curr.val == val:[0m
[34m- 122:                 return curr[0m
[34m- 123:             elif val < curr.val:[0m
[34m- 124:                 curr = curr.left[0m
[34m- 125:             else:[0m
[34m- 126:                 curr = curr.right[0m
[32m+ 121:             break[0m
[32m+ 122:     [0m
[32m+ 123:     [0m
[32m+ 124:     [0m
[32m+ 125:     [0m
[32m+ 126:     [0m
  127:     
  128:     def size(self):
  129:         '''Return the size of the BST.'''
  130:         return self._size
--------------------------------------------------------------------------------
[0.21230 s] [32mkilled[0m by 0-ts/test_bst2.py::test_contains_method

test_bsts = (<bst2.Bst object at 0x7ff227d65e40>, <bst2.Bst object at 0x7ff227d663e0>, <bst2.Bst object at 0x7ff227d64400>, <bst2.Bst object at 0x7ff227d67c40>, <bst2.Bst object at 0x7ff227d64c70>, <bst2.Bst object at 0x7ff227d67730>)

    def test_contains_method(test_bsts):
        """Test contains on number that exists."""
>       assert test_bsts[2].contains(5)
E       AssertionError

0-ts/test_bst2.py:72: AssertionError
[36m   -[0m [# 306] ZIL bst2: 
--------------------------------------------------------------------------------
  165:         
  166:         yield node.val
  167:         
  168:         for n in self.pre_order(node=node.left):
[34m- 169:             yield n[0m
[32m+ 169:             break[0m
  170:         for n in self.pre_order(node=node.right):
  171:             yield n
  172:     
  173:     def in_order(self, node='root'):
--------------------------------------------------------------------------------
[0.23046 s] [32mkilled[0m by 0-ts/test_bst2.py::test_pre_order

test_traversals = {'breadth': ['F', 'B', 'G', 'A', 'D', 'I', ...], 'empty': <bst2.Bst object at 0x7ff227c5f190>, 'in_order': ['A', 'B', 'C', 'D', 'E', 'F', ...], 'post_order': ['A', 'C', 'E', 'D', 'B', 'H', ...], ...}

    def test_pre_order(test_traversals):
        """Test preorder for a traversal."""
        path = [i for i in test_traversals['tree'].pre_order()]
>       assert path == test_traversals['pre_order']
E       AssertionError

0-ts/test_bst2.py:104: AssertionError
[36m   -[0m [# 307] ZIL bst2: 
--------------------------------------------------------------------------------
  167:         
  168:         for n in self.pre_order(node=node.left):
  169:             yield n
  170:         for n in self.pre_order(node=node.right):
[34m- 171:             yield n[0m
[32m+ 171:             break[0m
  172:     
  173:     def in_order(self, node='root'):
  174:         '''Depth first in-order traversal of tree.'''
  175:         if node == 'root':
--------------------------------------------------------------------------------
[0.21608 s] [32mkilled[0m by 0-ts/test_bst2.py::test_pre_order

test_traversals = {'breadth': ['F', 'B', 'G', 'A', 'D', 'I', ...], 'empty': <bst2.Bst object at 0x7ff227bfea70>, 'in_order': ['A', 'B', 'C', 'D', 'E', 'F', ...], 'post_order': ['A', 'C', 'E', 'D', 'B', 'H', ...], ...}

    def test_pre_order(test_traversals):
        """Test preorder for a traversal."""
        path = [i for i in test_traversals['tree'].pre_order()]
>       assert path == test_traversals['pre_order']
E       AssertionError

0-ts/test_bst2.py:104: AssertionError
[36m   -[0m [# 308] ZIL bst2: 
--------------------------------------------------------------------------------
  178:         if not node:
  179:             return
  180:         
  181:         for n in self.in_order(node=node.left):
[34m- 182:             yield n[0m
[32m+ 182:             break[0m
  183:         yield node.val
  184:         for n in self.in_order(node=node.right):
  185:             yield n
  186:     
--------------------------------------------------------------------------------
[0.37613 s] [32mkilled[0m by 0-ts/test_bst2.py::test_in_order

test_traversals = {'breadth': ['F', 'B', 'G', 'A', 'D', 'I', ...], 'empty': <bst2.Bst object at 0x7ff227df0850>, 'in_order': ['A', 'B', 'C', 'D', 'E', 'F', ...], 'post_order': ['A', 'C', 'E', 'D', 'B', 'H', ...], ...}

    def test_in_order(test_traversals):
        """Test inorder for a traversal."""
        path = [i for i in test_traversals['tree'].in_order()]
>       assert path == test_traversals['in_order']
E       AssertionError

0-ts/test_bst2.py:110: AssertionError
[36m   -[0m [# 309] ZIL bst2: 
--------------------------------------------------------------------------------
  181:         for n in self.in_order(node=node.left):
  182:             yield n
  183:         yield node.val
  184:         for n in self.in_order(node=node.right):
[34m- 185:             yield n[0m
[32m+ 185:             break[0m
  186:     
  187:     def post_order(self, node='root'):
  188:         '''Depth frist post_order traversal of tree.'''
  189:         if node == 'root':
--------------------------------------------------------------------------------
[0.24044 s] [32mkilled[0m by 0-ts/test_bst2.py::test_in_order

test_traversals = {'breadth': ['F', 'B', 'G', 'A', 'D', 'I', ...], 'empty': <bst2.Bst object at 0x7ff22802e5f0>, 'in_order': ['A', 'B', 'C', 'D', 'E', 'F', ...], 'post_order': ['A', 'C', 'E', 'D', 'B', 'H', ...], ...}

    def test_in_order(test_traversals):
        """Test inorder for a traversal."""
        path = [i for i in test_traversals['tree'].in_order()]
>       assert path == test_traversals['in_order']
E       AssertionError

0-ts/test_bst2.py:110: AssertionError
[36m   -[0m [# 310] ZIL bst2: 
--------------------------------------------------------------------------------
  192:         if not node:
  193:             return
  194:         
  195:         for n in self.post_order(node=node.left):
[34m- 196:             yield n[0m
[32m+ 196:             break[0m
  197:         for n in self.post_order(node=node.right):
  198:             yield n
  199:         yield node.val
  200:     
--------------------------------------------------------------------------------
[0.38953 s] [32mkilled[0m by 0-ts/test_bst2.py::test_post_order

test_traversals = {'breadth': ['F', 'B', 'G', 'A', 'D', 'I', ...], 'empty': <bst2.Bst object at 0x7ff228209bd0>, 'in_order': ['A', 'B', 'C', 'D', 'E', 'F', ...], 'post_order': ['A', 'C', 'E', 'D', 'B', 'H', ...], ...}

    def test_post_order(test_traversals):
        """Test postorder for a traversal."""
        path = [i for i in test_traversals['tree'].post_order()]
>       assert path == test_traversals['post_order']
E       AssertionError

0-ts/test_bst2.py:116: AssertionError
[36m   -[0m [# 311] ZIL bst2: 
--------------------------------------------------------------------------------
  194:         
  195:         for n in self.post_order(node=node.left):
  196:             yield n
  197:         for n in self.post_order(node=node.right):
[34m- 198:             yield n[0m
[32m+ 198:             break[0m
  199:         yield node.val
  200:     
  201:     def breadth_first(self):
  202:         '''Breadth first traversal of tree.'''
--------------------------------------------------------------------------------
[0.27144 s] [32mkilled[0m by 0-ts/test_bst2.py::test_post_order

test_traversals = {'breadth': ['F', 'B', 'G', 'A', 'D', 'I', ...], 'empty': <bst2.Bst object at 0x7ff228036d40>, 'in_order': ['A', 'B', 'C', 'D', 'E', 'F', ...], 'post_order': ['A', 'C', 'E', 'D', 'B', 'H', ...], ...}

    def test_post_order(test_traversals):
        """Test postorder for a traversal."""
        path = [i for i in test_traversals['tree'].post_order()]
>       assert path == test_traversals['post_order']
E       AssertionError

0-ts/test_bst2.py:116: AssertionError
[36m   -[0m [# 312] ZIL bst2: 
--------------------------------------------------------------------------------
  202:         '''Breadth first traversal of tree.'''
  203:         q = Queue()
  204:         q.enqueue(self.root)
  205:         while q.peek():
[34m- 206:             node = q.dequeue()[0m
[34m- 207:             yield node.val[0m
[34m- 208:             if node.left:[0m
[34m- 209:                 q.enqueue(node.left)[0m
[34m- 210:             if node.right:[0m
[34m- 211:                 q.enqueue(node.right)[0m
[32m+ 206:             break[0m
[32m+ 207:     [0m
[32m+ 208:     [0m
[32m+ 209:     [0m
[32m+ 210:     [0m
[32m+ 211:     [0m
  212:     
  213:     def delete(self, val):
  214:         '''Remove a node from the tree.'''
  215:         if (self._size < 1 or not (self.contains(val))):
--------------------------------------------------------------------------------
[0.27705 s] [36mincompetent[0m

TypeError: /home/lucca/desktop/ic/experimento/testes/python_experiments2/bst2/0-ts/test_bst2.py:121: TypeError: 'NoneType' object is not iterable

[36m   -[0m [# 313] ZIL bst2: 
--------------------------------------------------------------------------------
  255:     
  256:     def _findmin(self, node):
  257:         '''Find min of subtree, Min is always left most node.'''
  258:         while node.left:
[34m- 259:             node = node.left[0m
[32m+ 259:             break[0m
  260:         return node
--------------------------------------------------------------------------------
[0.48670 s] [32mkilled[0m by 0-ts/test_bst2.py::test_delete_two_children_root

test_bsts = (<bst2.Bst object at 0x7ff228348700>, <bst2.Bst object at 0x7ff2283485e0>, <bst2.Bst object at 0x7ff228349a20>, <bst2.Bst object at 0x7ff228349a80>, <bst2.Bst object at 0x7ff22834ae90>, <bst2.Bst object at 0x7ff227f47910>)

    def test_delete_two_children_root(test_bsts):
        """Test delete node with two children root."""
        test_bsts[3].delete(5)
        assert not test_bsts[3].contains(5)
        assert test_bsts[3].size() is 6
>       assert test_bsts[3].root.val is 7
E       AssertionError

0-ts/test_bst2.py:218: AssertionError
[34m[*][0m Mutation score [181.65360 s]: [1m[34m92.1%[0m
[36m   -[0m all: 313
[36m   -[0m killed: 229 (73.2%)
[36m   -[0m survived: 20 (6.4%)
[36m   -[0m incompetent: 60 (19.2%)
[36m   -[0m timeout: 4 (1.3%)
