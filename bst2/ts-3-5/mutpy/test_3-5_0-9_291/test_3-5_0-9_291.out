[*] Start mutation process:
   - targets: bst2.py
   - tests: ts-3-5/test_3-5_0-9_291.py
[*] 15 tests passed:
   - test_3-5_0-9_291 [0.13475 s]
[*] Start mutants generation and execution:
   - [#   1] AOR bst2: 
--------------------------------------------------------------------------------
  152:         
  153:         leftbranch = 0 if not (tree.left) else tree.left.height
  154:         rightbranch = 0 if not (tree.right) else tree.right.height
  155:         
- 156:         return leftbranch - rightbranch
+ 156:         return leftbranch + rightbranch
  157:     
  158:     def pre_order(self, node='root'):
  159:         '''Depth first pre-order traversal of tree.'''
  160:         if node == 'root':
--------------------------------------------------------------------------------
[0.15474 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_balance

self = <test_3-5_0-9_291.TestBst object at 0x70408bf90d60>
bst_instance = <bst2.Bst object at 0x70408bf90a60>

    def test_balance(self, bst_instance):
>       assert bst_instance.balance() == 0
E       AssertionError

ts-3-5/test_3-5_0-9_291.py:37: AssertionError
   - [#   2] ASR bst2: 
--------------------------------------------------------------------------------
   87:     def insert(self, val):
   88:         '''Insert val into BST. If val is already present will be ignored.'''
   89:         if not (self.root):
   90:             self.root = Node(val)
-  91:             self._size += 1
+  91:             self._size -= 1
   92:         else:
   93:             self._step(val, self.root)
   94:     
   95:     def _step(self, val, curr):
--------------------------------------------------------------------------------
[0.14783 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_insert

self = <test_3-5_0-9_291.TestBst object at 0x70408be7b310>
bst_instance = <bst2.Bst object at 0x70408be94790>

    def test_insert(self, bst_instance):
        bst_instance.insert(10)
>       assert bst_instance.size() == 8
E       AssertionError

ts-3-5/test_3-5_0-9_291.py:19: AssertionError
   - [#   3] ASR bst2: 
--------------------------------------------------------------------------------
  105:         child = getattr(curr, side)
  106:         if child:
  107:             count = self._step(val, child)
  108:             if curr.height <= count:
- 109:                 curr.height += 1
+ 109:                 curr.height -= 1
  110:         else:
  111:             setattr(curr, side, Node(val, curr))
  112:             self._size += 1
  113:             if curr.height == 1:
--------------------------------------------------------------------------------
[0.15217 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_depth

self = <test_3-5_0-9_291.TestBst object at 0x70408bc40f70>
bst_instance = <bst2.Bst object at 0x70408bc40ca0>

    def test_depth(self, bst_instance):
>       assert bst_instance.depth() == 3
E       AssertionError

ts-3-5/test_3-5_0-9_291.py:30: AssertionError
   - [#   4] ASR bst2: 
--------------------------------------------------------------------------------
  108:             if curr.height <= count:
  109:                 curr.height += 1
  110:         else:
  111:             setattr(curr, side, Node(val, curr))
- 112:             self._size += 1
+ 112:             self._size -= 1
  113:             if curr.height == 1:
  114:                 curr.height += 1
  115:         return curr
  116:     
--------------------------------------------------------------------------------
[0.15436 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_insert

self = <test_3-5_0-9_291.TestBst object at 0x70408bd09d50>
bst_instance = <bst2.Bst object at 0x70408bd09e70>

    def test_insert(self, bst_instance):
        bst_instance.insert(10)
>       assert bst_instance.size() == 8
E       AssertionError

ts-3-5/test_3-5_0-9_291.py:19: AssertionError
   - [#   5] ASR bst2: 
--------------------------------------------------------------------------------
  110:         else:
  111:             setattr(curr, side, Node(val, curr))
  112:             self._size += 1
  113:             if curr.height == 1:
- 114:                 curr.height += 1
+ 114:                 curr.height -= 1
  115:         return curr
  116:     
  117:     def search(self, val):
  118:         '''Return the node containing val.'''
--------------------------------------------------------------------------------
[0.18758 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_depth

self = <test_3-5_0-9_291.TestBst object at 0x70408c0b8730>
bst_instance = <bst2.Bst object at 0x70408c0b9120>

    def test_depth(self, bst_instance):
>       assert bst_instance.depth() == 3
E       AssertionError

ts-3-5/test_3-5_0-9_291.py:30: AssertionError
   - [#   6] ASR bst2: 
--------------------------------------------------------------------------------
  224:                 self.root = None
  225:         
  226:         elif node._is_interior():
  227:             next_node = self._find_replacement(node)
- 228:             self._size += 1
+ 228:             self._size -= 1
  229:             self.delete(next_node.val)
  230:             node.val = next_node.val
  231:         else:
  232:             
--------------------------------------------------------------------------------
[0.13031 s] survived
   - [#   7] ASR bst2: 
--------------------------------------------------------------------------------
  236:                 setattr(node.parent, node._side(), child)
  237:             else:
  238:                 self.root = child
  239:         
- 240:         self._size -= 1
+ 240:         self._size += 1
  241:     
  242:     def _find_replacement(self, node):
  243:         '''Find left most node of right subtree.'''
  244:         if node.right:
--------------------------------------------------------------------------------
[0.16253 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_delete

self = <test_3-5_0-9_291.TestBst object at 0x70408c011570>
bst_instance = <bst2.Bst object at 0x70408c011270>

    def test_delete(self, bst_instance):
        bst_instance.delete(1)
>       assert bst_instance.size() == 6
E       AssertionError

ts-3-5/test_3-5_0-9_291.py:53: AssertionError
   - [#   8] CDI bst2: 
--------------------------------------------------------------------------------
    5: 
    6: class Node(object):
    7:     '''Node, or leaf of the BST.'''
    8:     
-   9:     def __init__(self, val=None, parent=None):
-  10:         '''Create node object.'''
-  11:         self.val = val
-  12:         self.right = None
-  13:         self.left = None
-  14:         self.parent = parent
-  15:         self.height = 1
-  16:     
+   9:     @classmethod
+  10:     def __init__(self, val=None, parent=None):
+  11:         '''Create node object.'''
+  12:         self.val = val
+  13:         self.right = None
+  14:         self.left = None
+  15:         self.parent = parent
+  16:         self.height = 1
   17:     def _is_leaf(self):
   18:         '''Return true if a leaf.'''
   19:         return (self.right is None and self.left is None)
   20:     
--------------------------------------------------------------------------------
[0.15493 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_search

self = <test_3-5_0-9_291.TestBst object at 0x70408becb1c0>
bst_instance = <bst2.Bst object at 0x70408bb28160>

    def test_search(self, bst_instance):
>       assert bst_instance.search(4).val == 4
E       AttributeError: 'NoneType' object has no attribute 'val'

ts-3-5/test_3-5_0-9_291.py:23: AttributeError
   - [#   9] CDI bst2: 
--------------------------------------------------------------------------------
   13:         self.left = None
   14:         self.parent = parent
   15:         self.height = 1
   16:     
-  17:     def _is_leaf(self):
-  18:         '''Return true if a leaf.'''
-  19:         return (self.right is None and self.left is None)
-  20:     
+  17:     @classmethod
+  18:     def _is_leaf(self):
+  19:         '''Return true if a leaf.'''
+  20:         return (self.right is None and self.left is None)
   21:     def _is_interior(self):
   22:         '''Return true if a interior node.'''
   23:         return (self.right is not None and self.left is not None)
   24:     
--------------------------------------------------------------------------------
[0.16605 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_delete

self = <test_3-5_0-9_291.TestBst object at 0x70408bd4b3a0>
bst_instance = <bst2.Bst object at 0x70408bd49d20>

    def test_delete(self, bst_instance):
>       bst_instance.delete(1)

ts-3-5/test_3-5_0-9_291.py:52: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
bst2:220: in delete
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <class 'bst2.Node'>

>   ???
E   AttributeError: type object 'Node' has no attribute 'right'

bst2:20: AttributeError
   - [#  10] CDI bst2: 
--------------------------------------------------------------------------------
   17:     def _is_leaf(self):
   18:         '''Return true if a leaf.'''
   19:         return (self.right is None and self.left is None)
   20:     
-  21:     def _is_interior(self):
-  22:         '''Return true if a interior node.'''
-  23:         return (self.right is not None and self.left is not None)
-  24:     
+  21:     @classmethod
+  22:     def _is_interior(self):
+  23:         '''Return true if a interior node.'''
+  24:         return (self.right is not None and self.left is not None)
   25:     def _onlychild(self):
   26:         '''Return string depending on children.'''
   27:         if (self.left and not (self.right)):
   28:             return 'left'
--------------------------------------------------------------------------------
[0.17231 s] killed by ts-3-5/test_3-5_0-9_291.py::TestNode::test_is_interior

self = <test_3-5_0-9_291.TestNode object at 0x70408bfcddb0>

    def test_is_interior(self):
        node = Node(5)
>       assert node._is_interior() is False

ts-3-5/test_3-5_0-9_291.py:64: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <class 'bst2.Node'>

>   ???
E   AttributeError: type object 'Node' has no attribute 'right'

bst2:24: AttributeError
   - [#  11] CDI bst2: 
--------------------------------------------------------------------------------
   21:     def _is_interior(self):
   22:         '''Return true if a interior node.'''
   23:         return (self.right is not None and self.left is not None)
   24:     
-  25:     def _onlychild(self):
-  26:         '''Return string depending on children.'''
-  27:         if (self.left and not (self.right)):
-  28:             return 'left'
-  29:         if (self.right and not (self.left)):
-  30:             return 'right'
-  31:     
+  25:     @classmethod
+  26:     def _onlychild(self):
+  27:         '''Return string depending on children.'''
+  28:         if (self.left and not (self.right)):
+  29:             return 'left'
+  30:         if (self.right and not (self.left)):
+  31:             return 'right'
   32:     def _side(self):
   33:         '''Return if left or right child of parent.'''
   34:         if self.parent:
   35:             return 'left' if self.parent.left == self else 'right'
--------------------------------------------------------------------------------
[0.17334 s] killed by ts-3-5/test_3-5_0-9_291.py::TestNode::test_onlychild

self = <test_3-5_0-9_291.TestNode object at 0x70408c3d1ea0>

    def test_onlychild(self):
        node = Node(5)
        node.left = Node(3)
>       assert node._onlychild() == 'left'

ts-3-5/test_3-5_0-9_291.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <class 'bst2.Node'>

>   ???
E   AttributeError: type object 'Node' has no attribute 'left'

bst2:28: AttributeError
   - [#  12] CDI bst2: 
--------------------------------------------------------------------------------
   28:             return 'left'
   29:         if (self.right and not (self.left)):
   30:             return 'right'
   31:     
-  32:     def _side(self):
-  33:         '''Return if left or right child of parent.'''
-  34:         if self.parent:
-  35:             return 'left' if self.parent.left == self else 'right'
-  36: 
+  32:     @classmethod
+  33:     def _side(self):
+  34:         '''Return if left or right child of parent.'''
+  35:         if self.parent:
+  36:             return 'left' if self.parent.left == self else 'right'
   37: 
   38: class Bst(object):
   39:     '''Binary Search Tree.
   40: 
--------------------------------------------------------------------------------
[0.16423 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_delete

self = <test_3-5_0-9_291.TestBst object at 0x70408bd78fa0>
bst_instance = <bst2.Bst object at 0x70408bd78ca0>

    def test_delete(self, bst_instance):
>       bst_instance.delete(1)

ts-3-5/test_3-5_0-9_291.py:52: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
bst2:222: in delete
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <class 'bst2.Node'>

>   ???
E   AttributeError: type object 'Node' has no attribute 'parent'

bst2:35: AttributeError
   - [#  13] CDI bst2: 
--------------------------------------------------------------------------------
   74:     using breadth frist traversal, one at a time.
   75: 
   76:     '''
   77:     
-  78:     def __init__(self, data=None):
-  79:         '''Initialize tree.'''
-  80:         self._size = 0
-  81:         self.root = None
-  82:         
-  83:         if data:
-  84:             for i in data:
-  85:                 self.insert(i)
-  86:     
+  78:     @classmethod
+  79:     def __init__(self, data=None):
+  80:         '''Initialize tree.'''
+  81:         self._size = 0
+  82:         self.root = None
+  83:         
+  84:         if data:
+  85:             for i in data:
+  86:                 self.insert(i)
   87:     def insert(self, val):
   88:         '''Insert val into BST. If val is already present will be ignored.'''
   89:         if not (self.root):
   90:             self.root = Node(val)
--------------------------------------------------------------------------------
[0.15607 s] incompetent

TypeError: bst2:86: TypeError: Bst.insert() missing 1 required positional argument: 'val'

   - [#  14] CDI bst2: 
--------------------------------------------------------------------------------
   83:         if data:
   84:             for i in data:
   85:                 self.insert(i)
   86:     
-  87:     def insert(self, val):
-  88:         '''Insert val into BST. If val is already present will be ignored.'''
-  89:         if not (self.root):
-  90:             self.root = Node(val)
-  91:             self._size += 1
-  92:         else:
-  93:             self._step(val, self.root)
-  94:     
+  87:     @classmethod
+  88:     def insert(self, val):
+  89:         '''Insert val into BST. If val is already present will be ignored.'''
+  90:         if not (self.root):
+  91:             self.root = Node(val)
+  92:             self._size += 1
+  93:         else:
+  94:             self._step(val, self.root)
   95:     def _step(self, val, curr):
   96:         '''Decide left or right and returns height.'''
   97:         if val < curr.val:
   98:             curr = self._set_child(curr, 'left', val)
--------------------------------------------------------------------------------
[0.15830 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_insert

self = <test_3-5_0-9_291.TestBst object at 0x70408bc11180>

    @pytest.fixture
    def bst_instance(self):
>       return Bst([5, 3, 8, 1, 4, 7, 9])

ts-3-5/test_3-5_0-9_291.py:15: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
bst2:85: in __init__
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <class 'bst2.Bst'>, val = 5

>   ???
E   AttributeError: type object 'Bst' has no attribute 'root'

bst2:90: AttributeError
   - [#  15] CDI bst2: 
--------------------------------------------------------------------------------
   91:             self._size += 1
   92:         else:
   93:             self._step(val, self.root)
   94:     
-  95:     def _step(self, val, curr):
-  96:         '''Decide left or right and returns height.'''
-  97:         if val < curr.val:
-  98:             curr = self._set_child(curr, 'left', val)
-  99:         elif val > curr.val:
- 100:             curr = self._set_child(curr, 'right', val)
- 101:         return curr.height
- 102:     
+  95:     @classmethod
+  96:     def _step(self, val, curr):
+  97:         '''Decide left or right and returns height.'''
+  98:         if val < curr.val:
+  99:             curr = self._set_child(curr, 'left', val)
+ 100:         elif val > curr.val:
+ 101:             curr = self._set_child(curr, 'right', val)
+ 102:         return curr.height
  103:     def _set_child(self, curr, side, val):
  104:         '''Helping.'''
  105:         child = getattr(curr, side)
  106:         if child:
--------------------------------------------------------------------------------
[0.16099 s] incompetent

TypeError: bst2:99: TypeError: Bst._set_child() missing 1 required positional argument: 'val'

   - [#  16] CDI bst2: 
--------------------------------------------------------------------------------
   99:         elif val > curr.val:
  100:             curr = self._set_child(curr, 'right', val)
  101:         return curr.height
  102:     
- 103:     def _set_child(self, curr, side, val):
- 104:         '''Helping.'''
- 105:         child = getattr(curr, side)
- 106:         if child:
- 107:             count = self._step(val, child)
- 108:             if curr.height <= count:
- 109:                 curr.height += 1
- 110:         else:
- 111:             setattr(curr, side, Node(val, curr))
- 112:             self._size += 1
- 113:             if curr.height == 1:
- 114:                 curr.height += 1
- 115:         return curr
- 116:     
+ 103:     @classmethod
+ 104:     def _set_child(self, curr, side, val):
+ 105:         '''Helping.'''
+ 106:         child = getattr(curr, side)
+ 107:         if child:
+ 108:             count = self._step(val, child)
+ 109:             if curr.height <= count:
+ 110:                 curr.height += 1
+ 111:         else:
+ 112:             setattr(curr, side, Node(val, curr))
+ 113:             self._size += 1
+ 114:             if curr.height == 1:
+ 115:                 curr.height += 1
+ 116:         return curr
  117:     def search(self, val):
  118:         '''Return the node containing val.'''
  119:         curr = self.root
  120:         while curr:
--------------------------------------------------------------------------------
[0.16106 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_insert

self = <test_3-5_0-9_291.TestBst object at 0x70408bfceb60>

    @pytest.fixture
    def bst_instance(self):
>       return Bst([5, 3, 8, 1, 4, 7, 9])

ts-3-5/test_3-5_0-9_291.py:15: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
bst2:85: in __init__
    ???
bst2:93: in insert
    ???
bst2:98: in _step
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <class 'bst2.Bst'>, curr = <bst2.Node object at 0x70408bcdc100>
side = 'left', val = 3

>   ???
E   AttributeError: type object 'Bst' has no attribute '_size'. Did you mean: 'size'?

bst2:113: AttributeError
   - [#  17] CDI bst2: 
--------------------------------------------------------------------------------
  113:             if curr.height == 1:
  114:                 curr.height += 1
  115:         return curr
  116:     
- 117:     def search(self, val):
- 118:         '''Return the node containing val.'''
- 119:         curr = self.root
- 120:         while curr:
- 121:             if curr.val == val:
- 122:                 return curr
- 123:             elif val < curr.val:
- 124:                 curr = curr.left
- 125:             else:
- 126:                 curr = curr.right
- 127:     
+ 117:     @classmethod
+ 118:     def search(self, val):
+ 119:         '''Return the node containing val.'''
+ 120:         curr = self.root
+ 121:         while curr:
+ 122:             if curr.val == val:
+ 123:                 return curr
+ 124:             elif val < curr.val:
+ 125:                 curr = curr.left
+ 126:             else:
+ 127:                 curr = curr.right
  128:     def size(self):
  129:         '''Return the size of the BST.'''
  130:         return self._size
  131:     
--------------------------------------------------------------------------------
[0.15841 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_insert

self = <test_3-5_0-9_291.TestBst object at 0x70408bebd0f0>
bst_instance = <bst2.Bst object at 0x70408bebd210>

    def test_insert(self, bst_instance):
        bst_instance.insert(10)
        assert bst_instance.size() == 8
>       assert bst_instance.search(10).val == 10

ts-3-5/test_3-5_0-9_291.py:20: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <class 'bst2.Bst'>, val = 10

>   ???
E   AttributeError: type object 'Bst' has no attribute 'root'

bst2:120: AttributeError
   - [#  18] CDI bst2: 
--------------------------------------------------------------------------------
  124:                 curr = curr.left
  125:             else:
  126:                 curr = curr.right
  127:     
- 128:     def size(self):
- 129:         '''Return the size of the BST.'''
- 130:         return self._size
- 131:     
+ 128:     @classmethod
+ 129:     def size(self):
+ 130:         '''Return the size of the BST.'''
+ 131:         return self._size
  132:     def depth(self):
  133:         '''Return depth of the BST, representing total levels.'''
  134:         return 0 if not (self.root) else self.root.height
  135:     
--------------------------------------------------------------------------------
[0.18804 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_insert

self = <test_3-5_0-9_291.TestBst object at 0x70408ba7fc10>
bst_instance = <bst2.Bst object at 0x70408ba7db10>

    def test_insert(self, bst_instance):
        bst_instance.insert(10)
>       assert bst_instance.size() == 8

ts-3-5/test_3-5_0-9_291.py:19: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <class 'bst2.Bst'>

>   ???
E   AttributeError: type object 'Bst' has no attribute '_size'. Did you mean: 'size'?

bst2:131: AttributeError
   - [#  19] CDI bst2: 
--------------------------------------------------------------------------------
  128:     def size(self):
  129:         '''Return the size of the BST.'''
  130:         return self._size
  131:     
- 132:     def depth(self):
- 133:         '''Return depth of the BST, representing total levels.'''
- 134:         return 0 if not (self.root) else self.root.height
- 135:     
+ 132:     @classmethod
+ 133:     def depth(self):
+ 134:         '''Return depth of the BST, representing total levels.'''
+ 135:         return 0 if not (self.root) else self.root.height
  136:     def contains(self, val):
  137:         '''Return true if val is in the bst.'''
  138:         return self.search(val) is not None
  139:     
--------------------------------------------------------------------------------
[0.16181 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_depth

self = <test_3-5_0-9_291.TestBst object at 0x70408c1fcaf0>
bst_instance = <bst2.Bst object at 0x70408c1fcf10>

    def test_depth(self, bst_instance):
>       assert bst_instance.depth() == 3

ts-3-5/test_3-5_0-9_291.py:30: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <class 'bst2.Bst'>

>   ???
E   AttributeError: type object 'Bst' has no attribute 'root'

bst2:135: AttributeError
   - [#  20] CDI bst2: 
--------------------------------------------------------------------------------
  132:     def depth(self):
  133:         '''Return depth of the BST, representing total levels.'''
  134:         return 0 if not (self.root) else self.root.height
  135:     
- 136:     def contains(self, val):
- 137:         '''Return true if val is in the bst.'''
- 138:         return self.search(val) is not None
- 139:     
+ 136:     @classmethod
+ 137:     def contains(self, val):
+ 138:         '''Return true if val is in the bst.'''
+ 139:         return self.search(val) is not None
  140:     def balance(self, tree=None):
  141:         '''Return an integer of how well the tree is balanced.
  142: 
  143:         Trees which are higher on the left than the right should return a
--------------------------------------------------------------------------------
[0.15823 s] incompetent

TypeError: bst2:139: TypeError: Bst.search() missing 1 required positional argument: 'val'

   - [#  21] CDI bst2: 
--------------------------------------------------------------------------------
  136:     def contains(self, val):
  137:         '''Return true if val is in the bst.'''
  138:         return self.search(val) is not None
  139:     
- 140:     def balance(self, tree=None):
- 141:         '''Return an integer of how well the tree is balanced.
- 142: 
- 143:         Trees which are higher on the left than the right should return a
- 144:         positive value, trees which are higher on the right than the left
- 145:         should return a negative value. An ideally-balanced tree should
- 146:         return 0.
- 147:         '''
- 148:         if not tree:
- 149:             tree = self.root
- 150:             if not tree:
- 151:                 return 0
- 152:         
- 153:         leftbranch = 0 if not (tree.left) else tree.left.height
- 154:         rightbranch = 0 if not (tree.right) else tree.right.height
- 155:         
- 156:         return leftbranch - rightbranch
- 157:     
+ 140:     @classmethod
+ 141:     def balance(self, tree=None):
+ 142:         '''Return an integer of how well the tree is balanced.
+ 143: 
+ 144:         Trees which are higher on the left than the right should return a
+ 145:         positive value, trees which are higher on the right than the left
+ 146:         should return a negative value. An ideally-balanced tree should
+ 147:         return 0.
+ 148:         '''
+ 149:         if not tree:
+ 150:             tree = self.root
+ 151:             if not tree:
+ 152:                 return 0
+ 153:         
+ 154:         leftbranch = 0 if not (tree.left) else tree.left.height
+ 155:         rightbranch = 0 if not (tree.right) else tree.right.height
+ 156:         
+ 157:         return leftbranch - rightbranch
  158:     def pre_order(self, node='root'):
  159:         '''Depth first pre-order traversal of tree.'''
  160:         if node == 'root':
  161:             node = self.root
--------------------------------------------------------------------------------
[0.15540 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_balance

self = <test_3-5_0-9_291.TestBst object at 0x70408beda3e0>
bst_instance = <bst2.Bst object at 0x70408bedb7c0>

    def test_balance(self, bst_instance):
>       assert bst_instance.balance() == 0

ts-3-5/test_3-5_0-9_291.py:37: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <class 'bst2.Bst'>, tree = None

>   ???
E   AttributeError: type object 'Bst' has no attribute 'root'

bst2:150: AttributeError
   - [#  22] CDI bst2: 
--------------------------------------------------------------------------------
  154:         rightbranch = 0 if not (tree.right) else tree.right.height
  155:         
  156:         return leftbranch - rightbranch
  157:     
- 158:     def pre_order(self, node='root'):
- 159:         '''Depth first pre-order traversal of tree.'''
- 160:         if node == 'root':
- 161:             node = self.root
- 162:         
- 163:         if not node:
- 164:             return
- 165:         
- 166:         yield node.val
- 167:         
- 168:         for n in self.pre_order(node=node.left):
- 169:             yield n
- 170:         for n in self.pre_order(node=node.right):
- 171:             yield n
- 172:     
+ 158:     @classmethod
+ 159:     def pre_order(self, node='root'):
+ 160:         '''Depth first pre-order traversal of tree.'''
+ 161:         if node == 'root':
+ 162:             node = self.root
+ 163:         
+ 164:         if not node:
+ 165:             return
+ 166:         
+ 167:         yield node.val
+ 168:         
+ 169:         for n in self.pre_order(node=node.left):
+ 170:             yield n
+ 171:         for n in self.pre_order(node=node.right):
+ 172:             yield n
  173:     def in_order(self, node='root'):
  174:         '''Depth first in-order traversal of tree.'''
  175:         if node == 'root':
  176:             node = self.root
--------------------------------------------------------------------------------
[0.15604 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_pre_order

self = <test_3-5_0-9_291.TestBst object at 0x70408bb39a20>
bst_instance = <bst2.Bst object at 0x70408bb38d60>

    def test_pre_order(self, bst_instance):
>       assert list(bst_instance.pre_order()) == [5, 3, 1, 4, 8, 7, 9]

ts-3-5/test_3-5_0-9_291.py:40: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <class 'bst2.Bst'>, node = 'root'

>   ???
E   AttributeError: type object 'Bst' has no attribute 'root'

bst2:162: AttributeError
   - [#  23] CDI bst2: 
--------------------------------------------------------------------------------
  169:             yield n
  170:         for n in self.pre_order(node=node.right):
  171:             yield n
  172:     
- 173:     def in_order(self, node='root'):
- 174:         '''Depth first in-order traversal of tree.'''
- 175:         if node == 'root':
- 176:             node = self.root
- 177:         
- 178:         if not node:
- 179:             return
- 180:         
- 181:         for n in self.in_order(node=node.left):
- 182:             yield n
- 183:         yield node.val
- 184:         for n in self.in_order(node=node.right):
- 185:             yield n
- 186:     
+ 173:     @classmethod
+ 174:     def in_order(self, node='root'):
+ 175:         '''Depth first in-order traversal of tree.'''
+ 176:         if node == 'root':
+ 177:             node = self.root
+ 178:         
+ 179:         if not node:
+ 180:             return
+ 181:         
+ 182:         for n in self.in_order(node=node.left):
+ 183:             yield n
+ 184:         yield node.val
+ 185:         for n in self.in_order(node=node.right):
+ 186:             yield n
  187:     def post_order(self, node='root'):
  188:         '''Depth frist post_order traversal of tree.'''
  189:         if node == 'root':
  190:             node = self.root
--------------------------------------------------------------------------------
[0.15640 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_in_order

self = <test_3-5_0-9_291.TestBst object at 0x70408be199f0>
bst_instance = <bst2.Bst object at 0x70408be1ba30>

    def test_in_order(self, bst_instance):
>       assert list(bst_instance.in_order()) == [1, 3, 4, 5, 7, 8, 9]

ts-3-5/test_3-5_0-9_291.py:43: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <class 'bst2.Bst'>, node = 'root'

>   ???
E   AttributeError: type object 'Bst' has no attribute 'root'

bst2:177: AttributeError
   - [#  24] CDI bst2: 
--------------------------------------------------------------------------------
  183:         yield node.val
  184:         for n in self.in_order(node=node.right):
  185:             yield n
  186:     
- 187:     def post_order(self, node='root'):
- 188:         '''Depth frist post_order traversal of tree.'''
- 189:         if node == 'root':
- 190:             node = self.root
- 191:         
- 192:         if not node:
- 193:             return
- 194:         
- 195:         for n in self.post_order(node=node.left):
- 196:             yield n
- 197:         for n in self.post_order(node=node.right):
- 198:             yield n
- 199:         yield node.val
- 200:     
+ 187:     @classmethod
+ 188:     def post_order(self, node='root'):
+ 189:         '''Depth frist post_order traversal of tree.'''
+ 190:         if node == 'root':
+ 191:             node = self.root
+ 192:         
+ 193:         if not node:
+ 194:             return
+ 195:         
+ 196:         for n in self.post_order(node=node.left):
+ 197:             yield n
+ 198:         for n in self.post_order(node=node.right):
+ 199:             yield n
+ 200:         yield node.val
  201:     def breadth_first(self):
  202:         '''Breadth first traversal of tree.'''
  203:         q = Queue()
  204:         q.enqueue(self.root)
--------------------------------------------------------------------------------
[0.16542 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_post_order

self = <test_3-5_0-9_291.TestBst object at 0x70408be07340>
bst_instance = <bst2.Bst object at 0x70408bc402e0>

    def test_post_order(self, bst_instance):
>       assert list(bst_instance.post_order()) == [1, 4, 3, 7, 9, 8, 5]

ts-3-5/test_3-5_0-9_291.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <class 'bst2.Bst'>, node = 'root'

>   ???
E   AttributeError: type object 'Bst' has no attribute 'root'

bst2:191: AttributeError
   - [#  25] CDI bst2: 
--------------------------------------------------------------------------------
  197:         for n in self.post_order(node=node.right):
  198:             yield n
  199:         yield node.val
  200:     
- 201:     def breadth_first(self):
- 202:         '''Breadth first traversal of tree.'''
- 203:         q = Queue()
- 204:         q.enqueue(self.root)
- 205:         while q.peek():
- 206:             node = q.dequeue()
- 207:             yield node.val
- 208:             if node.left:
- 209:                 q.enqueue(node.left)
- 210:             if node.right:
- 211:                 q.enqueue(node.right)
- 212:     
+ 201:     @classmethod
+ 202:     def breadth_first(self):
+ 203:         '''Breadth first traversal of tree.'''
+ 204:         q = Queue()
+ 205:         q.enqueue(self.root)
+ 206:         while q.peek():
+ 207:             node = q.dequeue()
+ 208:             yield node.val
+ 209:             if node.left:
+ 210:                 q.enqueue(node.left)
+ 211:             if node.right:
+ 212:                 q.enqueue(node.right)
  213:     def delete(self, val):
  214:         '''Remove a node from the tree.'''
  215:         if (self._size < 1 or not (self.contains(val))):
  216:             return
--------------------------------------------------------------------------------
[0.15584 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_breadth_first

self = <test_3-5_0-9_291.TestBst object at 0x70408c0092d0>
bst_instance = <bst2.Bst object at 0x70408c008fd0>

    def test_breadth_first(self, bst_instance):
>       assert list(bst_instance.breadth_first()) == [5, 3, 8, 1, 4, 7, 9]

ts-3-5/test_3-5_0-9_291.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <class 'bst2.Bst'>

>   ???
E   AttributeError: type object 'Bst' has no attribute 'root'

bst2:205: AttributeError
   - [#  26] CDI bst2: 
--------------------------------------------------------------------------------
  209:                 q.enqueue(node.left)
  210:             if node.right:
  211:                 q.enqueue(node.right)
  212:     
- 213:     def delete(self, val):
- 214:         '''Remove a node from the tree.'''
- 215:         if (self._size < 1 or not (self.contains(val))):
- 216:             return
- 217:         
- 218:         node = self.search(val)
- 219:         
- 220:         if node._is_leaf():
- 221:             if node.parent:
- 222:                 setattr(node.parent, node._side(), None)
- 223:             else:
- 224:                 self.root = None
- 225:         
- 226:         elif node._is_interior():
- 227:             next_node = self._find_replacement(node)
- 228:             self._size += 1
- 229:             self.delete(next_node.val)
- 230:             node.val = next_node.val
- 231:         else:
- 232:             
- 233:             child = getattr(node, node._onlychild())
- 234:             if node.parent:
- 235:                 child.parent = node.parent
- 236:                 setattr(node.parent, node._side(), child)
- 237:             else:
- 238:                 self.root = child
- 239:         
- 240:         self._size -= 1
- 241:     
+ 213:     @classmethod
+ 214:     def delete(self, val):
+ 215:         '''Remove a node from the tree.'''
+ 216:         if (self._size < 1 or not (self.contains(val))):
+ 217:             return
+ 218:         
+ 219:         node = self.search(val)
+ 220:         
+ 221:         if node._is_leaf():
+ 222:             if node.parent:
+ 223:                 setattr(node.parent, node._side(), None)
+ 224:             else:
+ 225:                 self.root = None
+ 226:         
+ 227:         elif node._is_interior():
+ 228:             next_node = self._find_replacement(node)
+ 229:             self._size += 1
+ 230:             self.delete(next_node.val)
+ 231:             node.val = next_node.val
+ 232:         else:
+ 233:             
+ 234:             child = getattr(node, node._onlychild())
+ 235:             if node.parent:
+ 236:                 child.parent = node.parent
+ 237:                 setattr(node.parent, node._side(), child)
+ 238:             else:
+ 239:                 self.root = child
+ 240:         
+ 241:         self._size -= 1
  242:     def _find_replacement(self, node):
  243:         '''Find left most node of right subtree.'''
  244:         if node.right:
  245:             return self._findmin(node.right)
--------------------------------------------------------------------------------
[0.16372 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_delete

self = <test_3-5_0-9_291.TestBst object at 0x70408baca920>
bst_instance = <bst2.Bst object at 0x70408baca620>

    def test_delete(self, bst_instance):
>       bst_instance.delete(1)

ts-3-5/test_3-5_0-9_291.py:52: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <class 'bst2.Bst'>, val = 1

>   ???
E   AttributeError: type object 'Bst' has no attribute '_size'. Did you mean: 'size'?

bst2:216: AttributeError
   - [#  27] CDI bst2: 
--------------------------------------------------------------------------------
  238:                 self.root = child
  239:         
  240:         self._size -= 1
  241:     
- 242:     def _find_replacement(self, node):
- 243:         '''Find left most node of right subtree.'''
- 244:         if node.right:
- 245:             return self._findmin(node.right)
- 246:         
- 247:         elif node.parent:
- 248:             if node._side() == 'left':
- 249:                 return self.parent
- 250:             else:
- 251:                 node.parent.right = None
- 252:                 tmp = self._find_replacement(node.parent)
- 253:                 node.parent.right = node
- 254:                 return tmp
- 255:     
+ 242:     @classmethod
+ 243:     def _find_replacement(self, node):
+ 244:         '''Find left most node of right subtree.'''
+ 245:         if node.right:
+ 246:             return self._findmin(node.right)
+ 247:         
+ 248:         elif node.parent:
+ 249:             if node._side() == 'left':
+ 250:                 return self.parent
+ 251:             else:
+ 252:                 node.parent.right = None
+ 253:                 tmp = self._find_replacement(node.parent)
+ 254:                 node.parent.right = node
+ 255:                 return tmp
  256:     def _findmin(self, node):
  257:         '''Find min of subtree, Min is always left most node.'''
  258:         while node.left:
  259:             node = node.left
--------------------------------------------------------------------------------
[0.13105 s] survived
   - [#  28] CDI bst2: 
--------------------------------------------------------------------------------
  252:                 tmp = self._find_replacement(node.parent)
  253:                 node.parent.right = node
  254:                 return tmp
  255:     
- 256:     def _findmin(self, node):
- 257:         '''Find min of subtree, Min is always left most node.'''
- 258:         while node.left:
- 259:             node = node.left
- 260:         return node
+ 256:     @classmethod
+ 257:     def _findmin(self, node):
+ 258:         '''Find min of subtree, Min is always left most node.'''
+ 259:         while node.left:
+ 260:             node = node.left
+ 261:         return node
--------------------------------------------------------------------------------
[0.14049 s] survived
   - [#  29] COD bst2: 
--------------------------------------------------------------------------------
   23:         return (self.right is not None and self.left is not None)
   24:     
   25:     def _onlychild(self):
   26:         '''Return string depending on children.'''
-  27:         if (self.left and not (self.right)):
+  27:         if (self.left and self.right):
   28:             return 'left'
   29:         if (self.right and not (self.left)):
   30:             return 'right'
   31:     
--------------------------------------------------------------------------------
[0.15920 s] killed by ts-3-5/test_3-5_0-9_291.py::TestNode::test_onlychild

self = <test_3-5_0-9_291.TestNode object at 0x70408bc65450>

    def test_onlychild(self):
        node = Node(5)
        node.left = Node(3)
>       assert node._onlychild() == 'left'
E       AssertionError

ts-3-5/test_3-5_0-9_291.py:69: AssertionError
   - [#  30] COD bst2: 
--------------------------------------------------------------------------------
   25:     def _onlychild(self):
   26:         '''Return string depending on children.'''
   27:         if (self.left and not (self.right)):
   28:             return 'left'
-  29:         if (self.right and not (self.left)):
+  29:         if (self.right and self.left):
   30:             return 'right'
   31:     
   32:     def _side(self):
   33:         '''Return if left or right child of parent.'''
--------------------------------------------------------------------------------
[0.13033 s] survived
   - [#  31] COD bst2: 
--------------------------------------------------------------------------------
   85:                 self.insert(i)
   86:     
   87:     def insert(self, val):
   88:         '''Insert val into BST. If val is already present will be ignored.'''
-  89:         if not (self.root):
+  89:         if self.root:
   90:             self.root = Node(val)
   91:             self._size += 1
   92:         else:
   93:             self._step(val, self.root)
--------------------------------------------------------------------------------
[0.18130 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_insert

self = <test_3-5_0-9_291.TestBst object at 0x70408bd2a080>

    @pytest.fixture
    def bst_instance(self):
>       return Bst([5, 3, 8, 1, 4, 7, 9])

ts-3-5/test_3-5_0-9_291.py:15: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
bst2:85: in __init__
    ???
bst2:93: in insert
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x70408bd284f0>, val = 5, curr = None

>   ???
E   AttributeError: 'NoneType' object has no attribute 'val'

bst2:97: AttributeError
   - [#  32] COD bst2: 
--------------------------------------------------------------------------------
  130:         return self._size
  131:     
  132:     def depth(self):
  133:         '''Return depth of the BST, representing total levels.'''
- 134:         return 0 if not (self.root) else self.root.height
+ 134:         return 0 if self.root else self.root.height
  135:     
  136:     def contains(self, val):
  137:         '''Return true if val is in the bst.'''
  138:         return self.search(val) is not None
--------------------------------------------------------------------------------
[0.14315 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_depth

self = <test_3-5_0-9_291.TestBst object at 0x70408be1af80>
bst_instance = <bst2.Bst object at 0x70408be18ee0>

    def test_depth(self, bst_instance):
>       assert bst_instance.depth() == 3
E       AssertionError

ts-3-5/test_3-5_0-9_291.py:30: AssertionError
   - [#  33] COD bst2: 
--------------------------------------------------------------------------------
  144:         positive value, trees which are higher on the right than the left
  145:         should return a negative value. An ideally-balanced tree should
  146:         return 0.
  147:         '''
- 148:         if not tree:
+ 148:         if tree:
  149:             tree = self.root
  150:             if not tree:
  151:                 return 0
  152:         
--------------------------------------------------------------------------------
[0.14926 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_balance

self = <test_3-5_0-9_291.TestBst object at 0x70408bbcfa30>
bst_instance = <bst2.Bst object at 0x70408c2f0bb0>

    def test_balance(self, bst_instance):
>       assert bst_instance.balance() == 0

ts-3-5/test_3-5_0-9_291.py:37: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x70408c2f0bb0>, tree = None

>   ???
E   AttributeError: 'NoneType' object has no attribute 'left'

bst2:153: AttributeError
   - [#  34] COD bst2: 
--------------------------------------------------------------------------------
  146:         return 0.
  147:         '''
  148:         if not tree:
  149:             tree = self.root
- 150:             if not tree:
+ 150:             if tree:
  151:                 return 0
  152:         
  153:         leftbranch = 0 if not (tree.left) else tree.left.height
  154:         rightbranch = 0 if not (tree.right) else tree.right.height
--------------------------------------------------------------------------------
[0.12435 s] survived
   - [#  35] COD bst2: 
--------------------------------------------------------------------------------
  149:             tree = self.root
  150:             if not tree:
  151:                 return 0
  152:         
- 153:         leftbranch = 0 if not (tree.left) else tree.left.height
+ 153:         leftbranch = 0 if tree.left else tree.left.height
  154:         rightbranch = 0 if not (tree.right) else tree.right.height
  155:         
  156:         return leftbranch - rightbranch
  157:     
--------------------------------------------------------------------------------
[0.14809 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_balance

self = <test_3-5_0-9_291.TestBst object at 0x70408c0913f0>
bst_instance = <bst2.Bst object at 0x70408c090be0>

    def test_balance(self, bst_instance):
>       assert bst_instance.balance() == 0
E       AssertionError

ts-3-5/test_3-5_0-9_291.py:37: AssertionError
   - [#  36] COD bst2: 
--------------------------------------------------------------------------------
  150:             if not tree:
  151:                 return 0
  152:         
  153:         leftbranch = 0 if not (tree.left) else tree.left.height
- 154:         rightbranch = 0 if not (tree.right) else tree.right.height
+ 154:         rightbranch = 0 if tree.right else tree.right.height
  155:         
  156:         return leftbranch - rightbranch
  157:     
  158:     def pre_order(self, node='root'):
--------------------------------------------------------------------------------
[0.14779 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_balance

self = <test_3-5_0-9_291.TestBst object at 0x70408bc40880>
bst_instance = <bst2.Bst object at 0x70408bc428c0>

    def test_balance(self, bst_instance):
>       assert bst_instance.balance() == 0
E       AssertionError

ts-3-5/test_3-5_0-9_291.py:37: AssertionError
   - [#  37] COD bst2: 
--------------------------------------------------------------------------------
  159:         '''Depth first pre-order traversal of tree.'''
  160:         if node == 'root':
  161:             node = self.root
  162:         
- 163:         if not node:
+ 163:         if node:
  164:             return
  165:         
  166:         yield node.val
  167:         
--------------------------------------------------------------------------------
[0.14531 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_pre_order

self = <test_3-5_0-9_291.TestBst object at 0x70408c3d2080>
bst_instance = <bst2.Bst object at 0x70408c3d3130>

    def test_pre_order(self, bst_instance):
>       assert list(bst_instance.pre_order()) == [5, 3, 1, 4, 8, 7, 9]
E       AssertionError

ts-3-5/test_3-5_0-9_291.py:40: AssertionError
   - [#  38] COD bst2: 
--------------------------------------------------------------------------------
  174:         '''Depth first in-order traversal of tree.'''
  175:         if node == 'root':
  176:             node = self.root
  177:         
- 178:         if not node:
+ 178:         if node:
  179:             return
  180:         
  181:         for n in self.in_order(node=node.left):
  182:             yield n
--------------------------------------------------------------------------------
[0.15100 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_in_order

self = <test_3-5_0-9_291.TestBst object at 0x70408bb69960>
bst_instance = <bst2.Bst object at 0x70408bb68640>

    def test_in_order(self, bst_instance):
>       assert list(bst_instance.in_order()) == [1, 3, 4, 5, 7, 8, 9]
E       AssertionError

ts-3-5/test_3-5_0-9_291.py:43: AssertionError
   - [#  39] COD bst2: 
--------------------------------------------------------------------------------
  188:         '''Depth frist post_order traversal of tree.'''
  189:         if node == 'root':
  190:             node = self.root
  191:         
- 192:         if not node:
+ 192:         if node:
  193:             return
  194:         
  195:         for n in self.post_order(node=node.left):
  196:             yield n
--------------------------------------------------------------------------------
[0.16548 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_post_order

self = <test_3-5_0-9_291.TestBst object at 0x70408bedf1c0>
bst_instance = <bst2.Bst object at 0x70408bede350>

    def test_post_order(self, bst_instance):
>       assert list(bst_instance.post_order()) == [1, 4, 3, 7, 9, 8, 5]
E       AssertionError

ts-3-5/test_3-5_0-9_291.py:46: AssertionError
   - [#  40] COD bst2: 
--------------------------------------------------------------------------------
  211:                 q.enqueue(node.right)
  212:     
  213:     def delete(self, val):
  214:         '''Remove a node from the tree.'''
- 215:         if (self._size < 1 or not (self.contains(val))):
+ 215:         if (self._size < 1 or self.contains(val)):
  216:             return
  217:         
  218:         node = self.search(val)
  219:         
--------------------------------------------------------------------------------
[0.19164 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_delete

self = <test_3-5_0-9_291.TestBst object at 0x70408bbc6230>
bst_instance = <bst2.Bst object at 0x70408bbc4e50>

    def test_delete(self, bst_instance):
        bst_instance.delete(1)
>       assert bst_instance.size() == 6
E       AssertionError

ts-3-5/test_3-5_0-9_291.py:53: AssertionError
   - [#  41] COI bst2: 
--------------------------------------------------------------------------------
   23:         return (self.right is not None and self.left is not None)
   24:     
   25:     def _onlychild(self):
   26:         '''Return string depending on children.'''
-  27:         if (self.left and not (self.right)):
+  27:         if not ((self.left and not (self.right))):
   28:             return 'left'
   29:         if (self.right and not (self.left)):
   30:             return 'right'
   31:     
--------------------------------------------------------------------------------
[0.16008 s] killed by ts-3-5/test_3-5_0-9_291.py::TestNode::test_onlychild

self = <test_3-5_0-9_291.TestNode object at 0x70408c15c7f0>

    def test_onlychild(self):
        node = Node(5)
        node.left = Node(3)
>       assert node._onlychild() == 'left'
E       AssertionError

ts-3-5/test_3-5_0-9_291.py:69: AssertionError
   - [#  42] COI bst2: 
--------------------------------------------------------------------------------
   25:     def _onlychild(self):
   26:         '''Return string depending on children.'''
   27:         if (self.left and not (self.right)):
   28:             return 'left'
-  29:         if (self.right and not (self.left)):
+  29:         if not ((self.right and not (self.left))):
   30:             return 'right'
   31:     
   32:     def _side(self):
   33:         '''Return if left or right child of parent.'''
--------------------------------------------------------------------------------
[0.13115 s] survived
   - [#  43] COI bst2: 
--------------------------------------------------------------------------------
   30:             return 'right'
   31:     
   32:     def _side(self):
   33:         '''Return if left or right child of parent.'''
-  34:         if self.parent:
+  34:         if not (self.parent):
   35:             return 'left' if self.parent.left == self else 'right'
   36: 
   37: 
   38: class Bst(object):
--------------------------------------------------------------------------------
[0.15665 s] incompetent

TypeError: bst2:222: TypeError: attribute name must be string, not 'NoneType'

   - [#  44] COI bst2: 
--------------------------------------------------------------------------------
   79:         '''Initialize tree.'''
   80:         self._size = 0
   81:         self.root = None
   82:         
-  83:         if data:
+  83:         if not data:
   84:             for i in data:
   85:                 self.insert(i)
   86:     
   87:     def insert(self, val):
--------------------------------------------------------------------------------
[0.14971 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_insert

self = <test_3-5_0-9_291.TestBst object at 0x70408be41510>
bst_instance = <bst2.Bst object at 0x70408be41630>

    def test_insert(self, bst_instance):
        bst_instance.insert(10)
>       assert bst_instance.size() == 8
E       AssertionError

ts-3-5/test_3-5_0-9_291.py:19: AssertionError
   - [#  45] COI bst2: 
--------------------------------------------------------------------------------
   85:                 self.insert(i)
   86:     
   87:     def insert(self, val):
   88:         '''Insert val into BST. If val is already present will be ignored.'''
-  89:         if not (self.root):
+  89:         if not ((not (self.root))):
   90:             self.root = Node(val)
   91:             self._size += 1
   92:         else:
   93:             self._step(val, self.root)
--------------------------------------------------------------------------------
[0.15126 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_insert

self = <test_3-5_0-9_291.TestBst object at 0x70408c0fb550>

    @pytest.fixture
    def bst_instance(self):
>       return Bst([5, 3, 8, 1, 4, 7, 9])

ts-3-5/test_3-5_0-9_291.py:15: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
bst2:85: in __init__
    ???
bst2:93: in insert
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x70408c0f8370>, val = 5, curr = None

>   ???
E   AttributeError: 'NoneType' object has no attribute 'val'

bst2:97: AttributeError
   - [#  46] COI bst2: 
--------------------------------------------------------------------------------
   93:             self._step(val, self.root)
   94:     
   95:     def _step(self, val, curr):
   96:         '''Decide left or right and returns height.'''
-  97:         if val < curr.val:
+  97:         if not (val < curr.val):
   98:             curr = self._set_child(curr, 'left', val)
   99:         elif val > curr.val:
  100:             curr = self._set_child(curr, 'right', val)
  101:         return curr.height
--------------------------------------------------------------------------------
[0.14783 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_insert

self = <test_3-5_0-9_291.TestBst object at 0x70408bbeb610>
bst_instance = <bst2.Bst object at 0x70408bbeb8b0>

    def test_insert(self, bst_instance):
        bst_instance.insert(10)
>       assert bst_instance.size() == 8
E       AssertionError

ts-3-5/test_3-5_0-9_291.py:19: AssertionError
   - [#  47] COI bst2: 
--------------------------------------------------------------------------------
   95:     def _step(self, val, curr):
   96:         '''Decide left or right and returns height.'''
   97:         if val < curr.val:
   98:             curr = self._set_child(curr, 'left', val)
-  99:         elif val > curr.val:
+  99:         elif not (val > curr.val):
  100:             curr = self._set_child(curr, 'right', val)
  101:         return curr.height
  102:     
  103:     def _set_child(self, curr, side, val):
--------------------------------------------------------------------------------
[0.15183 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_insert

self = <test_3-5_0-9_291.TestBst object at 0x70408c1f0070>
bst_instance = <bst2.Bst object at 0x70408c1f2710>

    def test_insert(self, bst_instance):
        bst_instance.insert(10)
>       assert bst_instance.size() == 8
E       AssertionError

ts-3-5/test_3-5_0-9_291.py:19: AssertionError
   - [#  48] COI bst2: 
--------------------------------------------------------------------------------
  102:     
  103:     def _set_child(self, curr, side, val):
  104:         '''Helping.'''
  105:         child = getattr(curr, side)
- 106:         if child:
+ 106:         if not child:
  107:             count = self._step(val, child)
  108:             if curr.height <= count:
  109:                 curr.height += 1
  110:         else:
--------------------------------------------------------------------------------
[0.15445 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_insert

self = <test_3-5_0-9_291.TestBst object at 0x70408bf98070>

    @pytest.fixture
    def bst_instance(self):
>       return Bst([5, 3, 8, 1, 4, 7, 9])

ts-3-5/test_3-5_0-9_291.py:15: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
bst2:85: in __init__
    ???
bst2:93: in insert
    ???
bst2:98: in _step
    ???
bst2:107: in _set_child
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x70408bf99390>, val = 3, curr = None

>   ???
E   AttributeError: 'NoneType' object has no attribute 'val'

bst2:97: AttributeError
   - [#  49] COI bst2: 
--------------------------------------------------------------------------------
  104:         '''Helping.'''
  105:         child = getattr(curr, side)
  106:         if child:
  107:             count = self._step(val, child)
- 108:             if curr.height <= count:
+ 108:             if not (curr.height <= count):
  109:                 curr.height += 1
  110:         else:
  111:             setattr(curr, side, Node(val, curr))
  112:             self._size += 1
--------------------------------------------------------------------------------
[0.18197 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_depth

self = <test_3-5_0-9_291.TestBst object at 0x70408c0705b0>
bst_instance = <bst2.Bst object at 0x70408c076920>

    def test_depth(self, bst_instance):
>       assert bst_instance.depth() == 3
E       AssertionError

ts-3-5/test_3-5_0-9_291.py:30: AssertionError
   - [#  50] COI bst2: 
--------------------------------------------------------------------------------
  109:                 curr.height += 1
  110:         else:
  111:             setattr(curr, side, Node(val, curr))
  112:             self._size += 1
- 113:             if curr.height == 1:
+ 113:             if not (curr.height == 1):
  114:                 curr.height += 1
  115:         return curr
  116:     
  117:     def search(self, val):
--------------------------------------------------------------------------------
[0.15212 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_depth

self = <test_3-5_0-9_291.TestBst object at 0x70408bbeab30>
bst_instance = <bst2.Bst object at 0x70408bbe8a30>

    def test_depth(self, bst_instance):
>       assert bst_instance.depth() == 3
E       AssertionError

ts-3-5/test_3-5_0-9_291.py:30: AssertionError
   - [#  51] COI bst2: 
--------------------------------------------------------------------------------
  116:     
  117:     def search(self, val):
  118:         '''Return the node containing val.'''
  119:         curr = self.root
- 120:         while curr:
+ 120:         while not curr:
  121:             if curr.val == val:
  122:                 return curr
  123:             elif val < curr.val:
  124:                 curr = curr.left
--------------------------------------------------------------------------------
[0.15090 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_insert

self = <test_3-5_0-9_291.TestBst object at 0x70408bc3d540>
bst_instance = <bst2.Bst object at 0x70408be1ad40>

    def test_insert(self, bst_instance):
        bst_instance.insert(10)
        assert bst_instance.size() == 8
>       assert bst_instance.search(10).val == 10
E       AttributeError: 'NoneType' object has no attribute 'val'

ts-3-5/test_3-5_0-9_291.py:20: AttributeError
   - [#  52] COI bst2: 
--------------------------------------------------------------------------------
  117:     def search(self, val):
  118:         '''Return the node containing val.'''
  119:         curr = self.root
  120:         while curr:
- 121:             if curr.val == val:
+ 121:             if not (curr.val == val):
  122:                 return curr
  123:             elif val < curr.val:
  124:                 curr = curr.left
  125:             else:
--------------------------------------------------------------------------------
[0.15956 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_insert

self = <test_3-5_0-9_291.TestBst object at 0x70408bc35090>
bst_instance = <bst2.Bst object at 0x70408bc351b0>

    def test_insert(self, bst_instance):
        bst_instance.insert(10)
        assert bst_instance.size() == 8
>       assert bst_instance.search(10).val == 10
E       AssertionError

ts-3-5/test_3-5_0-9_291.py:20: AssertionError
   - [#  53] COI bst2: 
--------------------------------------------------------------------------------
  119:         curr = self.root
  120:         while curr:
  121:             if curr.val == val:
  122:                 return curr
- 123:             elif val < curr.val:
+ 123:             elif not (val < curr.val):
  124:                 curr = curr.left
  125:             else:
  126:                 curr = curr.right
  127:     
--------------------------------------------------------------------------------
[0.15214 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_insert

self = <test_3-5_0-9_291.TestBst object at 0x70408c0b2a70>
bst_instance = <bst2.Bst object at 0x70408bc45cf0>

    def test_insert(self, bst_instance):
        bst_instance.insert(10)
        assert bst_instance.size() == 8
>       assert bst_instance.search(10).val == 10
E       AttributeError: 'NoneType' object has no attribute 'val'

ts-3-5/test_3-5_0-9_291.py:20: AttributeError
   - [#  54] COI bst2: 
--------------------------------------------------------------------------------
  144:         positive value, trees which are higher on the right than the left
  145:         should return a negative value. An ideally-balanced tree should
  146:         return 0.
  147:         '''
- 148:         if not tree:
+ 148:         if not ((not tree)):
  149:             tree = self.root
  150:             if not tree:
  151:                 return 0
  152:         
--------------------------------------------------------------------------------
[0.15351 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_balance

self = <test_3-5_0-9_291.TestBst object at 0x70408bf5f850>
bst_instance = <bst2.Bst object at 0x70408bf5c130>

    def test_balance(self, bst_instance):
>       assert bst_instance.balance() == 0

ts-3-5/test_3-5_0-9_291.py:37: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x70408bf5c130>, tree = None

>   ???
E   AttributeError: 'NoneType' object has no attribute 'left'

bst2:153: AttributeError
   - [#  55] COI bst2: 
--------------------------------------------------------------------------------
  146:         return 0.
  147:         '''
  148:         if not tree:
  149:             tree = self.root
- 150:             if not tree:
+ 150:             if not ((not tree)):
  151:                 return 0
  152:         
  153:         leftbranch = 0 if not (tree.left) else tree.left.height
  154:         rightbranch = 0 if not (tree.right) else tree.right.height
--------------------------------------------------------------------------------
[0.13325 s] survived
   - [#  56] COI bst2: 
--------------------------------------------------------------------------------
  156:         return leftbranch - rightbranch
  157:     
  158:     def pre_order(self, node='root'):
  159:         '''Depth first pre-order traversal of tree.'''
- 160:         if node == 'root':
+ 160:         if not (node == 'root'):
  161:             node = self.root
  162:         
  163:         if not node:
  164:             return
--------------------------------------------------------------------------------
[0.16069 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_pre_order

self = <test_3-5_0-9_291.TestBst object at 0x70408c0c61d0>
bst_instance = <bst2.Bst object at 0x70408c0c4580>

    def test_pre_order(self, bst_instance):
>       assert list(bst_instance.pre_order()) == [5, 3, 1, 4, 8, 7, 9]

ts-3-5/test_3-5_0-9_291.py:40: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x70408c0c4580>, node = 'root'

>   ???
E   AttributeError: 'str' object has no attribute 'val'

bst2:166: AttributeError
   - [#  57] COI bst2: 
--------------------------------------------------------------------------------
  159:         '''Depth first pre-order traversal of tree.'''
  160:         if node == 'root':
  161:             node = self.root
  162:         
- 163:         if not node:
+ 163:         if not ((not node)):
  164:             return
  165:         
  166:         yield node.val
  167:         
--------------------------------------------------------------------------------
[0.14269 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_pre_order

self = <test_3-5_0-9_291.TestBst object at 0x70408baaca90>
bst_instance = <bst2.Bst object at 0x70408baac790>

    def test_pre_order(self, bst_instance):
>       assert list(bst_instance.pre_order()) == [5, 3, 1, 4, 8, 7, 9]
E       AssertionError

ts-3-5/test_3-5_0-9_291.py:40: AssertionError
   - [#  58] COI bst2: 
--------------------------------------------------------------------------------
  171:             yield n
  172:     
  173:     def in_order(self, node='root'):
  174:         '''Depth first in-order traversal of tree.'''
- 175:         if node == 'root':
+ 175:         if not (node == 'root'):
  176:             node = self.root
  177:         
  178:         if not node:
  179:             return
--------------------------------------------------------------------------------
[0.18254 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_in_order

self = <test_3-5_0-9_291.TestBst object at 0x70408baa4f10>
bst_instance = <bst2.Bst object at 0x70408baa40d0>

    def test_in_order(self, bst_instance):
>       assert list(bst_instance.in_order()) == [1, 3, 4, 5, 7, 8, 9]

ts-3-5/test_3-5_0-9_291.py:43: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x70408baa40d0>, node = 'root'

>   ???
E   AttributeError: 'str' object has no attribute 'left'

bst2:181: AttributeError
   - [#  59] COI bst2: 
--------------------------------------------------------------------------------
  174:         '''Depth first in-order traversal of tree.'''
  175:         if node == 'root':
  176:             node = self.root
  177:         
- 178:         if not node:
+ 178:         if not ((not node)):
  179:             return
  180:         
  181:         for n in self.in_order(node=node.left):
  182:             yield n
--------------------------------------------------------------------------------
[0.15627 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_in_order

self = <test_3-5_0-9_291.TestBst object at 0x70408b911de0>
bst_instance = <bst2.Bst object at 0x70408b9116c0>

    def test_in_order(self, bst_instance):
>       assert list(bst_instance.in_order()) == [1, 3, 4, 5, 7, 8, 9]
E       AssertionError

ts-3-5/test_3-5_0-9_291.py:43: AssertionError
   - [#  60] COI bst2: 
--------------------------------------------------------------------------------
  185:             yield n
  186:     
  187:     def post_order(self, node='root'):
  188:         '''Depth frist post_order traversal of tree.'''
- 189:         if node == 'root':
+ 189:         if not (node == 'root'):
  190:             node = self.root
  191:         
  192:         if not node:
  193:             return
--------------------------------------------------------------------------------
[0.16087 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_post_order

self = <test_3-5_0-9_291.TestBst object at 0x70408bc447c0>
bst_instance = <bst2.Bst object at 0x70408bc441c0>

    def test_post_order(self, bst_instance):
>       assert list(bst_instance.post_order()) == [1, 4, 3, 7, 9, 8, 5]

ts-3-5/test_3-5_0-9_291.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x70408bc441c0>, node = 'root'

>   ???
E   AttributeError: 'str' object has no attribute 'left'

bst2:195: AttributeError
   - [#  61] COI bst2: 
--------------------------------------------------------------------------------
  188:         '''Depth frist post_order traversal of tree.'''
  189:         if node == 'root':
  190:             node = self.root
  191:         
- 192:         if not node:
+ 192:         if not ((not node)):
  193:             return
  194:         
  195:         for n in self.post_order(node=node.left):
  196:             yield n
--------------------------------------------------------------------------------
[0.15986 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_post_order

self = <test_3-5_0-9_291.TestBst object at 0x70408ba17850>
bst_instance = <bst2.Bst object at 0x70408ba16c20>

    def test_post_order(self, bst_instance):
>       assert list(bst_instance.post_order()) == [1, 4, 3, 7, 9, 8, 5]
E       AssertionError

ts-3-5/test_3-5_0-9_291.py:46: AssertionError
   - [#  62] COI bst2: 
--------------------------------------------------------------------------------
  201:     def breadth_first(self):
  202:         '''Breadth first traversal of tree.'''
  203:         q = Queue()
  204:         q.enqueue(self.root)
- 205:         while q.peek():
+ 205:         while not (q.peek()):
  206:             node = q.dequeue()
  207:             yield node.val
  208:             if node.left:
  209:                 q.enqueue(node.left)
--------------------------------------------------------------------------------
[0.16021 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_breadth_first

self = <test_3-5_0-9_291.TestBst object at 0x70408be2b760>
bst_instance = <bst2.Bst object at 0x70408be2a470>

    def test_breadth_first(self, bst_instance):
>       assert list(bst_instance.breadth_first()) == [5, 3, 8, 1, 4, 7, 9]
E       AssertionError

ts-3-5/test_3-5_0-9_291.py:49: AssertionError
   - [#  63] COI bst2: 
--------------------------------------------------------------------------------
  204:         q.enqueue(self.root)
  205:         while q.peek():
  206:             node = q.dequeue()
  207:             yield node.val
- 208:             if node.left:
+ 208:             if not (node.left):
  209:                 q.enqueue(node.left)
  210:             if node.right:
  211:                 q.enqueue(node.right)
  212:     
--------------------------------------------------------------------------------
[0.15677 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_breadth_first

self = <test_3-5_0-9_291.TestBst object at 0x70408c0f40d0>
bst_instance = <bst2.Bst object at 0x70408c0f5b40>

    def test_breadth_first(self, bst_instance):
>       assert list(bst_instance.breadth_first()) == [5, 3, 8, 1, 4, 7, 9]
E       AssertionError

ts-3-5/test_3-5_0-9_291.py:49: AssertionError
   - [#  64] COI bst2: 
--------------------------------------------------------------------------------
  206:             node = q.dequeue()
  207:             yield node.val
  208:             if node.left:
  209:                 q.enqueue(node.left)
- 210:             if node.right:
+ 210:             if not (node.right):
  211:                 q.enqueue(node.right)
  212:     
  213:     def delete(self, val):
  214:         '''Remove a node from the tree.'''
--------------------------------------------------------------------------------
[0.15899 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_breadth_first

self = <test_3-5_0-9_291.TestBst object at 0x70408c15cc10>
bst_instance = <bst2.Bst object at 0x70408c15c2b0>

    def test_breadth_first(self, bst_instance):
>       assert list(bst_instance.breadth_first()) == [5, 3, 8, 1, 4, 7, 9]
E       AssertionError

ts-3-5/test_3-5_0-9_291.py:49: AssertionError
   - [#  65] COI bst2: 
--------------------------------------------------------------------------------
  211:                 q.enqueue(node.right)
  212:     
  213:     def delete(self, val):
  214:         '''Remove a node from the tree.'''
- 215:         if (self._size < 1 or not (self.contains(val))):
+ 215:         if not ((self._size < 1 or not (self.contains(val)))):
  216:             return
  217:         
  218:         node = self.search(val)
  219:         
--------------------------------------------------------------------------------
[0.15574 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_delete

self = <test_3-5_0-9_291.TestBst object at 0x70408c0799c0>
bst_instance = <bst2.Bst object at 0x70408be4bd60>

    def test_delete(self, bst_instance):
        bst_instance.delete(1)
>       assert bst_instance.size() == 6
E       AssertionError

ts-3-5/test_3-5_0-9_291.py:53: AssertionError
   - [#  66] COI bst2: 
--------------------------------------------------------------------------------
  216:             return
  217:         
  218:         node = self.search(val)
  219:         
- 220:         if node._is_leaf():
+ 220:         if not (node._is_leaf()):
  221:             if node.parent:
  222:                 setattr(node.parent, node._side(), None)
  223:             else:
  224:                 self.root = None
--------------------------------------------------------------------------------
[0.15647 s] incompetent

TypeError: bst2:233: TypeError: getattr(): attribute name must be string

   - [#  67] COI bst2: 
--------------------------------------------------------------------------------
  217:         
  218:         node = self.search(val)
  219:         
  220:         if node._is_leaf():
- 221:             if node.parent:
+ 221:             if not (node.parent):
  222:                 setattr(node.parent, node._side(), None)
  223:             else:
  224:                 self.root = None
  225:         
--------------------------------------------------------------------------------
[0.16568 s] survived
   - [#  68] COI bst2: 
--------------------------------------------------------------------------------
  222:                 setattr(node.parent, node._side(), None)
  223:             else:
  224:                 self.root = None
  225:         
- 226:         elif node._is_interior():
+ 226:         elif not (node._is_interior()):
  227:             next_node = self._find_replacement(node)
  228:             self._size += 1
  229:             self.delete(next_node.val)
  230:             node.val = next_node.val
--------------------------------------------------------------------------------
[0.13285 s] survived
   - [#  69] COI bst2: 
--------------------------------------------------------------------------------
  230:             node.val = next_node.val
  231:         else:
  232:             
  233:             child = getattr(node, node._onlychild())
- 234:             if node.parent:
+ 234:             if not (node.parent):
  235:                 child.parent = node.parent
  236:                 setattr(node.parent, node._side(), child)
  237:             else:
  238:                 self.root = child
--------------------------------------------------------------------------------
[0.13460 s] survived
   - [#  70] COI bst2: 
--------------------------------------------------------------------------------
  240:         self._size -= 1
  241:     
  242:     def _find_replacement(self, node):
  243:         '''Find left most node of right subtree.'''
- 244:         if node.right:
+ 244:         if not (node.right):
  245:             return self._findmin(node.right)
  246:         
  247:         elif node.parent:
  248:             if node._side() == 'left':
--------------------------------------------------------------------------------
[0.13360 s] survived
   - [#  71] COI bst2: 
--------------------------------------------------------------------------------
  243:         '''Find left most node of right subtree.'''
  244:         if node.right:
  245:             return self._findmin(node.right)
  246:         
- 247:         elif node.parent:
+ 247:         elif not (node.parent):
  248:             if node._side() == 'left':
  249:                 return self.parent
  250:             else:
  251:                 node.parent.right = None
--------------------------------------------------------------------------------
[0.13368 s] survived
   - [#  72] COI bst2: 
--------------------------------------------------------------------------------
  244:         if node.right:
  245:             return self._findmin(node.right)
  246:         
  247:         elif node.parent:
- 248:             if node._side() == 'left':
+ 248:             if not (node._side() == 'left'):
  249:                 return self.parent
  250:             else:
  251:                 node.parent.right = None
  252:                 tmp = self._find_replacement(node.parent)
--------------------------------------------------------------------------------
[0.13106 s] survived
   - [#  73] COI bst2: 
--------------------------------------------------------------------------------
  254:                 return tmp
  255:     
  256:     def _findmin(self, node):
  257:         '''Find min of subtree, Min is always left most node.'''
- 258:         while node.left:
+ 258:         while not (node.left):
  259:             node = node.left
  260:         return node
--------------------------------------------------------------------------------
[0.13351 s] survived
   - [#  74] LCR bst2: 
--------------------------------------------------------------------------------
   15:         self.height = 1
   16:     
   17:     def _is_leaf(self):
   18:         '''Return true if a leaf.'''
-  19:         return (self.right is None and self.left is None)
+  19:         return (self.right is None or self.left is None)
   20:     
   21:     def _is_interior(self):
   22:         '''Return true if a interior node.'''
   23:         return (self.right is not None and self.left is not None)
--------------------------------------------------------------------------------
[0.13278 s] survived
   - [#  75] LCR bst2: 
--------------------------------------------------------------------------------
   19:         return (self.right is None and self.left is None)
   20:     
   21:     def _is_interior(self):
   22:         '''Return true if a interior node.'''
-  23:         return (self.right is not None and self.left is not None)
+  23:         return (self.right is not None or self.left is not None)
   24:     
   25:     def _onlychild(self):
   26:         '''Return string depending on children.'''
   27:         if (self.left and not (self.right)):
--------------------------------------------------------------------------------
[0.13842 s] survived
   - [#  76] LCR bst2: 
--------------------------------------------------------------------------------
   23:         return (self.right is not None and self.left is not None)
   24:     
   25:     def _onlychild(self):
   26:         '''Return string depending on children.'''
-  27:         if (self.left and not (self.right)):
+  27:         if (self.left or not (self.right)):
   28:             return 'left'
   29:         if (self.right and not (self.left)):
   30:             return 'right'
   31:     
--------------------------------------------------------------------------------
[0.13842 s] survived
   - [#  77] LCR bst2: 
--------------------------------------------------------------------------------
   25:     def _onlychild(self):
   26:         '''Return string depending on children.'''
   27:         if (self.left and not (self.right)):
   28:             return 'left'
-  29:         if (self.right and not (self.left)):
+  29:         if (self.right or not (self.left)):
   30:             return 'right'
   31:     
   32:     def _side(self):
   33:         '''Return if left or right child of parent.'''
--------------------------------------------------------------------------------
[0.13543 s] survived
   - [#  78] LCR bst2: 
--------------------------------------------------------------------------------
  211:                 q.enqueue(node.right)
  212:     
  213:     def delete(self, val):
  214:         '''Remove a node from the tree.'''
- 215:         if (self._size < 1 or not (self.contains(val))):
+ 215:         if (self._size < 1 and not (self.contains(val))):
  216:             return
  217:         
  218:         node = self.search(val)
  219:         
--------------------------------------------------------------------------------
[0.14098 s] survived
   - [#  79] OIL bst2: 
--------------------------------------------------------------------------------
   82:         
   83:         if data:
   84:             for i in data:
   85:                 self.insert(i)
-  86:     
+  86:                 break
   87:     def insert(self, val):
   88:         '''Insert val into BST. If val is already present will be ignored.'''
   89:         if not (self.root):
   90:             self.root = Node(val)
--------------------------------------------------------------------------------
[0.15417 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_insert

self = <test_3-5_0-9_291.TestBst object at 0x70408bf23c10>
bst_instance = <bst2.Bst object at 0x70408c081090>

    def test_insert(self, bst_instance):
        bst_instance.insert(10)
>       assert bst_instance.size() == 8
E       AssertionError

ts-3-5/test_3-5_0-9_291.py:19: AssertionError
   - [#  80] OIL bst2: 
--------------------------------------------------------------------------------
  122:                 return curr
  123:             elif val < curr.val:
  124:                 curr = curr.left
  125:             else:
- 126:                 curr = curr.right
+ 126:                 curr = curr.rightbreak
  127:     
  128:     def size(self):
  129:         '''Return the size of the BST.'''
  130:         return self._size
--------------------------------------------------------------------------------
[0.18903 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_insert

self = <test_3-5_0-9_291.TestBst object at 0x70408bc9ee90>
bst_instance = <bst2.Bst object at 0x70408bc9d360>

    def test_insert(self, bst_instance):
        bst_instance.insert(10)
        assert bst_instance.size() == 8
>       assert bst_instance.search(10).val == 10
E       AttributeError: 'NoneType' object has no attribute 'val'

ts-3-5/test_3-5_0-9_291.py:20: AttributeError
   - [#  81] OIL bst2: 
--------------------------------------------------------------------------------
  166:         yield node.val
  167:         
  168:         for n in self.pre_order(node=node.left):
  169:             yield n
- 170:         for n in self.pre_order(node=node.right):
- 171:             yield n
- 172:     
+ 170:             break
+ 171:         for n in self.pre_order(node=node.right):
+ 172:             yield n
  173:     def in_order(self, node='root'):
  174:         '''Depth first in-order traversal of tree.'''
  175:         if node == 'root':
  176:             node = self.root
--------------------------------------------------------------------------------
[0.15585 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_pre_order

self = <test_3-5_0-9_291.TestBst object at 0x70408c1fc7c0>
bst_instance = <bst2.Bst object at 0x70408c1fe2f0>

    def test_pre_order(self, bst_instance):
>       assert list(bst_instance.pre_order()) == [5, 3, 1, 4, 8, 7, 9]
E       AssertionError

ts-3-5/test_3-5_0-9_291.py:40: AssertionError
   - [#  82] OIL bst2: 
--------------------------------------------------------------------------------
  168:         for n in self.pre_order(node=node.left):
  169:             yield n
  170:         for n in self.pre_order(node=node.right):
  171:             yield n
- 172:     
+ 172:             break
  173:     def in_order(self, node='root'):
  174:         '''Depth first in-order traversal of tree.'''
  175:         if node == 'root':
  176:             node = self.root
--------------------------------------------------------------------------------
[0.16215 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_pre_order

self = <test_3-5_0-9_291.TestBst object at 0x70408bca4df0>
bst_instance = <bst2.Bst object at 0x70408bca74c0>

    def test_pre_order(self, bst_instance):
>       assert list(bst_instance.pre_order()) == [5, 3, 1, 4, 8, 7, 9]
E       AssertionError

ts-3-5/test_3-5_0-9_291.py:40: AssertionError
   - [#  83] OIL bst2: 
--------------------------------------------------------------------------------
  179:             return
  180:         
  181:         for n in self.in_order(node=node.left):
  182:             yield n
- 183:         yield node.val
- 184:         for n in self.in_order(node=node.right):
- 185:             yield n
- 186:     
+ 183:             break
+ 184:         yield node.val
+ 185:         for n in self.in_order(node=node.right):
+ 186:             yield n
  187:     def post_order(self, node='root'):
  188:         '''Depth frist post_order traversal of tree.'''
  189:         if node == 'root':
  190:             node = self.root
--------------------------------------------------------------------------------
[0.16573 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_in_order

self = <test_3-5_0-9_291.TestBst object at 0x70408c0ff880>
bst_instance = <bst2.Bst object at 0x70408c0fe560>

    def test_in_order(self, bst_instance):
>       assert list(bst_instance.in_order()) == [1, 3, 4, 5, 7, 8, 9]
E       AssertionError

ts-3-5/test_3-5_0-9_291.py:43: AssertionError
   - [#  84] OIL bst2: 
--------------------------------------------------------------------------------
  182:             yield n
  183:         yield node.val
  184:         for n in self.in_order(node=node.right):
  185:             yield n
- 186:     
+ 186:             break
  187:     def post_order(self, node='root'):
  188:         '''Depth frist post_order traversal of tree.'''
  189:         if node == 'root':
  190:             node = self.root
--------------------------------------------------------------------------------
[0.16047 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_in_order

self = <test_3-5_0-9_291.TestBst object at 0x70408bf9c8e0>
bst_instance = <bst2.Bst object at 0x70408bf9c790>

    def test_in_order(self, bst_instance):
>       assert list(bst_instance.in_order()) == [1, 3, 4, 5, 7, 8, 9]
E       AssertionError

ts-3-5/test_3-5_0-9_291.py:43: AssertionError
   - [#  85] OIL bst2: 
--------------------------------------------------------------------------------
  193:             return
  194:         
  195:         for n in self.post_order(node=node.left):
  196:             yield n
- 197:         for n in self.post_order(node=node.right):
- 198:             yield n
- 199:         yield node.val
- 200:     
+ 197:             break
+ 198:         for n in self.post_order(node=node.right):
+ 199:             yield n
+ 200:         yield node.val
  201:     def breadth_first(self):
  202:         '''Breadth first traversal of tree.'''
  203:         q = Queue()
  204:         q.enqueue(self.root)
--------------------------------------------------------------------------------
[0.16388 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_post_order

self = <test_3-5_0-9_291.TestBst object at 0x70408b912230>
bst_instance = <bst2.Bst object at 0x70408b911840>

    def test_post_order(self, bst_instance):
>       assert list(bst_instance.post_order()) == [1, 4, 3, 7, 9, 8, 5]
E       AssertionError

ts-3-5/test_3-5_0-9_291.py:46: AssertionError
   - [#  86] OIL bst2: 
--------------------------------------------------------------------------------
  195:         for n in self.post_order(node=node.left):
  196:             yield n
  197:         for n in self.post_order(node=node.right):
  198:             yield n
- 199:         yield node.val
- 200:     
+ 199:             break
+ 200:         yield node.val
  201:     def breadth_first(self):
  202:         '''Breadth first traversal of tree.'''
  203:         q = Queue()
  204:         q.enqueue(self.root)
--------------------------------------------------------------------------------
[0.16838 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_post_order

self = <test_3-5_0-9_291.TestBst object at 0x70408c1feb60>
bst_instance = <bst2.Bst object at 0x70408c1fe110>

    def test_post_order(self, bst_instance):
>       assert list(bst_instance.post_order()) == [1, 4, 3, 7, 9, 8, 5]
E       AssertionError

ts-3-5/test_3-5_0-9_291.py:46: AssertionError
   - [#  87] OIL bst2: 
--------------------------------------------------------------------------------
  208:             if node.left:
  209:                 q.enqueue(node.left)
  210:             if node.right:
  211:                 q.enqueue(node.right)
- 212:     
+ 212:             break
  213:     def delete(self, val):
  214:         '''Remove a node from the tree.'''
  215:         if (self._size < 1 or not (self.contains(val))):
  216:             return
--------------------------------------------------------------------------------
[0.16607 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_breadth_first

self = <test_3-5_0-9_291.TestBst object at 0x70408be4abc0>
bst_instance = <bst2.Bst object at 0x70408be49f30>

    def test_breadth_first(self, bst_instance):
>       assert list(bst_instance.breadth_first()) == [5, 3, 8, 1, 4, 7, 9]
E       AssertionError

ts-3-5/test_3-5_0-9_291.py:49: AssertionError
   - [#  88] OIL bst2: 
--------------------------------------------------------------------------------
  256:     def _findmin(self, node):
  257:         '''Find min of subtree, Min is always left most node.'''
  258:         while node.left:
  259:             node = node.left
- 260:         return node
+ 260:             break
+ 261:         return node
--------------------------------------------------------------------------------
[0.14007 s] survived
   - [#  89] RIL bst2: 
--------------------------------------------------------------------------------
   80:         self._size = 0
   81:         self.root = None
   82:         
   83:         if data:
-  84:             for i in data:
+  84:             for i in reversed(data):
   85:                 self.insert(i)
   86:     
   87:     def insert(self, val):
   88:         '''Insert val into BST. If val is already present will be ignored.'''
--------------------------------------------------------------------------------
[0.19040 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_depth

self = <test_3-5_0-9_291.TestBst object at 0x70408bfb8610>
bst_instance = <bst2.Bst object at 0x70408bad6980>

    def test_depth(self, bst_instance):
>       assert bst_instance.depth() == 3
E       AssertionError

ts-3-5/test_3-5_0-9_291.py:30: AssertionError
   - [#  90] RIL bst2: 
--------------------------------------------------------------------------------
  164:             return
  165:         
  166:         yield node.val
  167:         
- 168:         for n in self.pre_order(node=node.left):
+ 168:         for n in reversed(self.pre_order(node=node.left)):
  169:             yield n
  170:         for n in self.pre_order(node=node.right):
  171:             yield n
  172:     
--------------------------------------------------------------------------------
[0.15403 s] incompetent

TypeError: bst2:168: TypeError: 'generator' object is not reversible

   - [#  91] RIL bst2: 
--------------------------------------------------------------------------------
  166:         yield node.val
  167:         
  168:         for n in self.pre_order(node=node.left):
  169:             yield n
- 170:         for n in self.pre_order(node=node.right):
+ 170:         for n in reversed(self.pre_order(node=node.right)):
  171:             yield n
  172:     
  173:     def in_order(self, node='root'):
  174:         '''Depth first in-order traversal of tree.'''
--------------------------------------------------------------------------------
[0.16494 s] incompetent

TypeError: bst2:170: TypeError: 'generator' object is not reversible

   - [#  92] RIL bst2: 
--------------------------------------------------------------------------------
  177:         
  178:         if not node:
  179:             return
  180:         
- 181:         for n in self.in_order(node=node.left):
+ 181:         for n in reversed(self.in_order(node=node.left)):
  182:             yield n
  183:         yield node.val
  184:         for n in self.in_order(node=node.right):
  185:             yield n
--------------------------------------------------------------------------------
[0.16284 s] incompetent

TypeError: bst2:181: TypeError: 'generator' object is not reversible

   - [#  93] RIL bst2: 
--------------------------------------------------------------------------------
  180:         
  181:         for n in self.in_order(node=node.left):
  182:             yield n
  183:         yield node.val
- 184:         for n in self.in_order(node=node.right):
+ 184:         for n in reversed(self.in_order(node=node.right)):
  185:             yield n
  186:     
  187:     def post_order(self, node='root'):
  188:         '''Depth frist post_order traversal of tree.'''
--------------------------------------------------------------------------------
[0.16620 s] incompetent

TypeError: bst2:184: TypeError: 'generator' object is not reversible

   - [#  94] RIL bst2: 
--------------------------------------------------------------------------------
  191:         
  192:         if not node:
  193:             return
  194:         
- 195:         for n in self.post_order(node=node.left):
+ 195:         for n in reversed(self.post_order(node=node.left)):
  196:             yield n
  197:         for n in self.post_order(node=node.right):
  198:             yield n
  199:         yield node.val
--------------------------------------------------------------------------------
[0.16093 s] incompetent

TypeError: bst2:195: TypeError: 'generator' object is not reversible

   - [#  95] RIL bst2: 
--------------------------------------------------------------------------------
  193:             return
  194:         
  195:         for n in self.post_order(node=node.left):
  196:             yield n
- 197:         for n in self.post_order(node=node.right):
+ 197:         for n in reversed(self.post_order(node=node.right)):
  198:             yield n
  199:         yield node.val
  200:     
  201:     def breadth_first(self):
--------------------------------------------------------------------------------
[0.16491 s] incompetent

TypeError: bst2:197: TypeError: 'generator' object is not reversible

   - [#  96] ROR bst2: 
--------------------------------------------------------------------------------
   31:     
   32:     def _side(self):
   33:         '''Return if left or right child of parent.'''
   34:         if self.parent:
-  35:             return 'left' if self.parent.left == self else 'right'
+  35:             return 'left' if self.parent.left != self else 'right'
   36: 
   37: 
   38: class Bst(object):
   39:     '''Binary Search Tree.
--------------------------------------------------------------------------------
[0.16361 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_delete

self = <test_3-5_0-9_291.TestBst object at 0x70408c0c6920>
bst_instance = <bst2.Bst object at 0x70408c0c6380>

    def test_delete(self, bst_instance):
        bst_instance.delete(1)
        assert bst_instance.size() == 6
>       assert bst_instance.search(1) is None
E       AssertionError

ts-3-5/test_3-5_0-9_291.py:54: AssertionError
   - [#  97] ROR bst2: 
--------------------------------------------------------------------------------
   93:             self._step(val, self.root)
   94:     
   95:     def _step(self, val, curr):
   96:         '''Decide left or right and returns height.'''
-  97:         if val < curr.val:
+  97:         if val > curr.val:
   98:             curr = self._set_child(curr, 'left', val)
   99:         elif val > curr.val:
  100:             curr = self._set_child(curr, 'right', val)
  101:         return curr.height
--------------------------------------------------------------------------------
[0.15526 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_insert

self = <test_3-5_0-9_291.TestBst object at 0x70408ba1aec0>
bst_instance = <bst2.Bst object at 0x70408bfebf10>

    def test_insert(self, bst_instance):
        bst_instance.insert(10)
>       assert bst_instance.size() == 8
E       AssertionError

ts-3-5/test_3-5_0-9_291.py:19: AssertionError
   - [#  98] ROR bst2: 
--------------------------------------------------------------------------------
   93:             self._step(val, self.root)
   94:     
   95:     def _step(self, val, curr):
   96:         '''Decide left or right and returns height.'''
-  97:         if val < curr.val:
+  97:         if val <= curr.val:
   98:             curr = self._set_child(curr, 'left', val)
   99:         elif val > curr.val:
  100:             curr = self._set_child(curr, 'right', val)
  101:         return curr.height
--------------------------------------------------------------------------------
[0.14016 s] survived
   - [#  99] ROR bst2: 
--------------------------------------------------------------------------------
   95:     def _step(self, val, curr):
   96:         '''Decide left or right and returns height.'''
   97:         if val < curr.val:
   98:             curr = self._set_child(curr, 'left', val)
-  99:         elif val > curr.val:
+  99:         elif val < curr.val:
  100:             curr = self._set_child(curr, 'right', val)
  101:         return curr.height
  102:     
  103:     def _set_child(self, curr, side, val):
--------------------------------------------------------------------------------
[0.15568 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_insert

self = <test_3-5_0-9_291.TestBst object at 0x70408bad2770>
bst_instance = <bst2.Bst object at 0x70408bad3dc0>

    def test_insert(self, bst_instance):
        bst_instance.insert(10)
>       assert bst_instance.size() == 8
E       AssertionError

ts-3-5/test_3-5_0-9_291.py:19: AssertionError
   - [# 100] ROR bst2: 
--------------------------------------------------------------------------------
   95:     def _step(self, val, curr):
   96:         '''Decide left or right and returns height.'''
   97:         if val < curr.val:
   98:             curr = self._set_child(curr, 'left', val)
-  99:         elif val > curr.val:
+  99:         elif val >= curr.val:
  100:             curr = self._set_child(curr, 'right', val)
  101:         return curr.height
  102:     
  103:     def _set_child(self, curr, side, val):
--------------------------------------------------------------------------------
[0.14499 s] survived
   - [# 101] ROR bst2: 
--------------------------------------------------------------------------------
  104:         '''Helping.'''
  105:         child = getattr(curr, side)
  106:         if child:
  107:             count = self._step(val, child)
- 108:             if curr.height <= count:
+ 108:             if curr.height >= count:
  109:                 curr.height += 1
  110:         else:
  111:             setattr(curr, side, Node(val, curr))
  112:             self._size += 1
--------------------------------------------------------------------------------
[0.16246 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_depth

self = <test_3-5_0-9_291.TestBst object at 0x70408ba5a500>
bst_instance = <bst2.Bst object at 0x70408ba5a7a0>

    def test_depth(self, bst_instance):
>       assert bst_instance.depth() == 3
E       AssertionError

ts-3-5/test_3-5_0-9_291.py:30: AssertionError
   - [# 102] ROR bst2: 
--------------------------------------------------------------------------------
  104:         '''Helping.'''
  105:         child = getattr(curr, side)
  106:         if child:
  107:             count = self._step(val, child)
- 108:             if curr.height <= count:
+ 108:             if curr.height < count:
  109:                 curr.height += 1
  110:         else:
  111:             setattr(curr, side, Node(val, curr))
  112:             self._size += 1
--------------------------------------------------------------------------------
[0.15493 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_depth

self = <test_3-5_0-9_291.TestBst object at 0x70408ba3ad40>
bst_instance = <bst2.Bst object at 0x70408ba39f60>

    def test_depth(self, bst_instance):
>       assert bst_instance.depth() == 3
E       AssertionError

ts-3-5/test_3-5_0-9_291.py:30: AssertionError
   - [# 103] ROR bst2: 
--------------------------------------------------------------------------------
  109:                 curr.height += 1
  110:         else:
  111:             setattr(curr, side, Node(val, curr))
  112:             self._size += 1
- 113:             if curr.height == 1:
+ 113:             if curr.height != 1:
  114:                 curr.height += 1
  115:         return curr
  116:     
  117:     def search(self, val):
--------------------------------------------------------------------------------
[0.18600 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_depth

self = <test_3-5_0-9_291.TestBst object at 0x70408ba5c9a0>
bst_instance = <bst2.Bst object at 0x70408ba5c7c0>

    def test_depth(self, bst_instance):
>       assert bst_instance.depth() == 3
E       AssertionError

ts-3-5/test_3-5_0-9_291.py:30: AssertionError
   - [# 104] ROR bst2: 
--------------------------------------------------------------------------------
  117:     def search(self, val):
  118:         '''Return the node containing val.'''
  119:         curr = self.root
  120:         while curr:
- 121:             if curr.val == val:
+ 121:             if curr.val != val:
  122:                 return curr
  123:             elif val < curr.val:
  124:                 curr = curr.left
  125:             else:
--------------------------------------------------------------------------------
[0.15216 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_insert

self = <test_3-5_0-9_291.TestBst object at 0x70408bc3e950>
bst_instance = <bst2.Bst object at 0x70408bc3ef50>

    def test_insert(self, bst_instance):
        bst_instance.insert(10)
        assert bst_instance.size() == 8
>       assert bst_instance.search(10).val == 10
E       AssertionError

ts-3-5/test_3-5_0-9_291.py:20: AssertionError
   - [# 105] ROR bst2: 
--------------------------------------------------------------------------------
  119:         curr = self.root
  120:         while curr:
  121:             if curr.val == val:
  122:                 return curr
- 123:             elif val < curr.val:
+ 123:             elif val > curr.val:
  124:                 curr = curr.left
  125:             else:
  126:                 curr = curr.right
  127:     
--------------------------------------------------------------------------------
[0.15776 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_insert

self = <test_3-5_0-9_291.TestBst object at 0x70408bbea770>
bst_instance = <bst2.Bst object at 0x70408bbe8af0>

    def test_insert(self, bst_instance):
        bst_instance.insert(10)
        assert bst_instance.size() == 8
>       assert bst_instance.search(10).val == 10
E       AttributeError: 'NoneType' object has no attribute 'val'

ts-3-5/test_3-5_0-9_291.py:20: AttributeError
   - [# 106] ROR bst2: 
--------------------------------------------------------------------------------
  119:         curr = self.root
  120:         while curr:
  121:             if curr.val == val:
  122:                 return curr
- 123:             elif val < curr.val:
+ 123:             elif val <= curr.val:
  124:                 curr = curr.left
  125:             else:
  126:                 curr = curr.right
  127:     
--------------------------------------------------------------------------------
[0.13318 s] survived
   - [# 107] ROR bst2: 
--------------------------------------------------------------------------------
  156:         return leftbranch - rightbranch
  157:     
  158:     def pre_order(self, node='root'):
  159:         '''Depth first pre-order traversal of tree.'''
- 160:         if node == 'root':
+ 160:         if node != 'root':
  161:             node = self.root
  162:         
  163:         if not node:
  164:             return
--------------------------------------------------------------------------------
[0.15814 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_pre_order

self = <test_3-5_0-9_291.TestBst object at 0x70408bb8fac0>
bst_instance = <bst2.Bst object at 0x70408be74370>

    def test_pre_order(self, bst_instance):
>       assert list(bst_instance.pre_order()) == [5, 3, 1, 4, 8, 7, 9]

ts-3-5/test_3-5_0-9_291.py:40: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x70408be74370>, node = 'root'

>   ???
E   AttributeError: 'str' object has no attribute 'val'

bst2:166: AttributeError
   - [# 108] ROR bst2: 
--------------------------------------------------------------------------------
  171:             yield n
  172:     
  173:     def in_order(self, node='root'):
  174:         '''Depth first in-order traversal of tree.'''
- 175:         if node == 'root':
+ 175:         if node != 'root':
  176:             node = self.root
  177:         
  178:         if not node:
  179:             return
--------------------------------------------------------------------------------
[0.15694 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_in_order

self = <test_3-5_0-9_291.TestBst object at 0x70408c1f1cc0>
bst_instance = <bst2.Bst object at 0x70408c1f2fe0>

    def test_in_order(self, bst_instance):
>       assert list(bst_instance.in_order()) == [1, 3, 4, 5, 7, 8, 9]

ts-3-5/test_3-5_0-9_291.py:43: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x70408c1f2fe0>, node = 'root'

>   ???
E   AttributeError: 'str' object has no attribute 'left'

bst2:181: AttributeError
   - [# 109] ROR bst2: 
--------------------------------------------------------------------------------
  185:             yield n
  186:     
  187:     def post_order(self, node='root'):
  188:         '''Depth frist post_order traversal of tree.'''
- 189:         if node == 'root':
+ 189:         if node != 'root':
  190:             node = self.root
  191:         
  192:         if not node:
  193:             return
--------------------------------------------------------------------------------
[0.15867 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_post_order

self = <test_3-5_0-9_291.TestBst object at 0x70408b911b70>
bst_instance = <bst2.Bst object at 0x70408b912500>

    def test_post_order(self, bst_instance):
>       assert list(bst_instance.post_order()) == [1, 4, 3, 7, 9, 8, 5]

ts-3-5/test_3-5_0-9_291.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x70408b912500>, node = 'root'

>   ???
E   AttributeError: 'str' object has no attribute 'left'

bst2:195: AttributeError
   - [# 110] ROR bst2: 
--------------------------------------------------------------------------------
  211:                 q.enqueue(node.right)
  212:     
  213:     def delete(self, val):
  214:         '''Remove a node from the tree.'''
- 215:         if (self._size < 1 or not (self.contains(val))):
+ 215:         if (self._size > 1 or not (self.contains(val))):
  216:             return
  217:         
  218:         node = self.search(val)
  219:         
--------------------------------------------------------------------------------
[0.16558 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_delete

self = <test_3-5_0-9_291.TestBst object at 0x70408bbb1990>
bst_instance = <bst2.Bst object at 0x70408bbb0040>

    def test_delete(self, bst_instance):
        bst_instance.delete(1)
>       assert bst_instance.size() == 6
E       AssertionError

ts-3-5/test_3-5_0-9_291.py:53: AssertionError
   - [# 111] ROR bst2: 
--------------------------------------------------------------------------------
  211:                 q.enqueue(node.right)
  212:     
  213:     def delete(self, val):
  214:         '''Remove a node from the tree.'''
- 215:         if (self._size < 1 or not (self.contains(val))):
+ 215:         if (self._size <= 1 or not (self.contains(val))):
  216:             return
  217:         
  218:         node = self.search(val)
  219:         
--------------------------------------------------------------------------------
[0.14099 s] survived
   - [# 112] ROR bst2: 
--------------------------------------------------------------------------------
  244:         if node.right:
  245:             return self._findmin(node.right)
  246:         
  247:         elif node.parent:
- 248:             if node._side() == 'left':
+ 248:             if node._side() != 'left':
  249:                 return self.parent
  250:             else:
  251:                 node.parent.right = None
  252:                 tmp = self._find_replacement(node.parent)
--------------------------------------------------------------------------------
[0.16711 s] survived
   - [# 113] SDI bst2: 
--------------------------------------------------------------------------------
    5: 
    6: class Node(object):
    7:     '''Node, or leaf of the BST.'''
    8:     
-   9:     def __init__(self, val=None, parent=None):
-  10:         '''Create node object.'''
-  11:         self.val = val
-  12:         self.right = None
-  13:         self.left = None
-  14:         self.parent = parent
-  15:         self.height = 1
-  16:     
+   9:     @staticmethod
+  10:     def __init__(self, val=None, parent=None):
+  11:         '''Create node object.'''
+  12:         self.val = val
+  13:         self.right = None
+  14:         self.left = None
+  15:         self.parent = parent
+  16:         self.height = 1
   17:     def _is_leaf(self):
   18:         '''Return true if a leaf.'''
   19:         return (self.right is None and self.left is None)
   20:     
--------------------------------------------------------------------------------
[0.15976 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_insert

self = <test_3-5_0-9_291.TestBst object at 0x70408bc3cbb0>

    @pytest.fixture
    def bst_instance(self):
>       return Bst([5, 3, 8, 1, 4, 7, 9])

ts-3-5/test_3-5_0-9_291.py:15: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
bst2:85: in __init__
    ???
bst2:90: in insert
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = 5, val = None, parent = None

>   ???
E   AttributeError: 'int' object has no attribute 'val'

bst2:12: AttributeError
   - [# 114] SDI bst2: 
--------------------------------------------------------------------------------
   13:         self.left = None
   14:         self.parent = parent
   15:         self.height = 1
   16:     
-  17:     def _is_leaf(self):
-  18:         '''Return true if a leaf.'''
-  19:         return (self.right is None and self.left is None)
-  20:     
+  17:     @staticmethod
+  18:     def _is_leaf(self):
+  19:         '''Return true if a leaf.'''
+  20:         return (self.right is None and self.left is None)
   21:     def _is_interior(self):
   22:         '''Return true if a interior node.'''
   23:         return (self.right is not None and self.left is not None)
   24:     
--------------------------------------------------------------------------------
[0.16549 s] incompetent

TypeError: bst2:220: TypeError: Node._is_leaf() missing 1 required positional argument: 'self'

   - [# 115] SDI bst2: 
--------------------------------------------------------------------------------
   17:     def _is_leaf(self):
   18:         '''Return true if a leaf.'''
   19:         return (self.right is None and self.left is None)
   20:     
-  21:     def _is_interior(self):
-  22:         '''Return true if a interior node.'''
-  23:         return (self.right is not None and self.left is not None)
-  24:     
+  21:     @staticmethod
+  22:     def _is_interior(self):
+  23:         '''Return true if a interior node.'''
+  24:         return (self.right is not None and self.left is not None)
   25:     def _onlychild(self):
   26:         '''Return string depending on children.'''
   27:         if (self.left and not (self.right)):
   28:             return 'left'
--------------------------------------------------------------------------------
[0.16720 s] incompetent

TypeError: /home/lucca/teste/python_experiments2/bst2/ts-3-5/test_3-5_0-9_291.py:64: TypeError: Node._is_interior() missing 1 required positional argument: 'self'

   - [# 116] SDI bst2: 
--------------------------------------------------------------------------------
   21:     def _is_interior(self):
   22:         '''Return true if a interior node.'''
   23:         return (self.right is not None and self.left is not None)
   24:     
-  25:     def _onlychild(self):
-  26:         '''Return string depending on children.'''
-  27:         if (self.left and not (self.right)):
-  28:             return 'left'
-  29:         if (self.right and not (self.left)):
-  30:             return 'right'
-  31:     
+  25:     @staticmethod
+  26:     def _onlychild(self):
+  27:         '''Return string depending on children.'''
+  28:         if (self.left and not (self.right)):
+  29:             return 'left'
+  30:         if (self.right and not (self.left)):
+  31:             return 'right'
   32:     def _side(self):
   33:         '''Return if left or right child of parent.'''
   34:         if self.parent:
   35:             return 'left' if self.parent.left == self else 'right'
--------------------------------------------------------------------------------
[0.19975 s] incompetent

TypeError: /home/lucca/teste/python_experiments2/bst2/ts-3-5/test_3-5_0-9_291.py:69: TypeError: Node._onlychild() missing 1 required positional argument: 'self'

   - [# 117] SDI bst2: 
--------------------------------------------------------------------------------
   28:             return 'left'
   29:         if (self.right and not (self.left)):
   30:             return 'right'
   31:     
-  32:     def _side(self):
-  33:         '''Return if left or right child of parent.'''
-  34:         if self.parent:
-  35:             return 'left' if self.parent.left == self else 'right'
-  36: 
+  32:     @staticmethod
+  33:     def _side(self):
+  34:         '''Return if left or right child of parent.'''
+  35:         if self.parent:
+  36:             return 'left' if self.parent.left == self else 'right'
   37: 
   38: class Bst(object):
   39:     '''Binary Search Tree.
   40: 
--------------------------------------------------------------------------------
[0.16275 s] incompetent

TypeError: bst2:222: TypeError: Node._side() missing 1 required positional argument: 'self'

   - [# 118] SDI bst2: 
--------------------------------------------------------------------------------
   74:     using breadth frist traversal, one at a time.
   75: 
   76:     '''
   77:     
-  78:     def __init__(self, data=None):
-  79:         '''Initialize tree.'''
-  80:         self._size = 0
-  81:         self.root = None
-  82:         
-  83:         if data:
-  84:             for i in data:
-  85:                 self.insert(i)
-  86:     
+  78:     @staticmethod
+  79:     def __init__(self, data=None):
+  80:         '''Initialize tree.'''
+  81:         self._size = 0
+  82:         self.root = None
+  83:         
+  84:         if data:
+  85:             for i in data:
+  86:                 self.insert(i)
   87:     def insert(self, val):
   88:         '''Insert val into BST. If val is already present will be ignored.'''
   89:         if not (self.root):
   90:             self.root = Node(val)
--------------------------------------------------------------------------------
[0.16081 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_insert

self = <test_3-5_0-9_291.TestBst object at 0x70408c15e8c0>

    @pytest.fixture
    def bst_instance(self):
>       return Bst([5, 3, 8, 1, 4, 7, 9])

ts-3-5/test_3-5_0-9_291.py:15: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = [5, 3, 8, 1, 4, 7, ...], data = None

>   ???
E   AttributeError: 'list' object has no attribute '_size'

bst2:81: AttributeError
   - [# 119] SDI bst2: 
--------------------------------------------------------------------------------
   83:         if data:
   84:             for i in data:
   85:                 self.insert(i)
   86:     
-  87:     def insert(self, val):
-  88:         '''Insert val into BST. If val is already present will be ignored.'''
-  89:         if not (self.root):
-  90:             self.root = Node(val)
-  91:             self._size += 1
-  92:         else:
-  93:             self._step(val, self.root)
-  94:     
+  87:     @staticmethod
+  88:     def insert(self, val):
+  89:         '''Insert val into BST. If val is already present will be ignored.'''
+  90:         if not (self.root):
+  91:             self.root = Node(val)
+  92:             self._size += 1
+  93:         else:
+  94:             self._step(val, self.root)
   95:     def _step(self, val, curr):
   96:         '''Decide left or right and returns height.'''
   97:         if val < curr.val:
   98:             curr = self._set_child(curr, 'left', val)
--------------------------------------------------------------------------------
[0.16294 s] incompetent

TypeError: bst2:85: TypeError: Bst.insert() missing 1 required positional argument: 'val'

   - [# 120] SDI bst2: 
--------------------------------------------------------------------------------
   91:             self._size += 1
   92:         else:
   93:             self._step(val, self.root)
   94:     
-  95:     def _step(self, val, curr):
-  96:         '''Decide left or right and returns height.'''
-  97:         if val < curr.val:
-  98:             curr = self._set_child(curr, 'left', val)
-  99:         elif val > curr.val:
- 100:             curr = self._set_child(curr, 'right', val)
- 101:         return curr.height
- 102:     
+  95:     @staticmethod
+  96:     def _step(self, val, curr):
+  97:         '''Decide left or right and returns height.'''
+  98:         if val < curr.val:
+  99:             curr = self._set_child(curr, 'left', val)
+ 100:         elif val > curr.val:
+ 101:             curr = self._set_child(curr, 'right', val)
+ 102:         return curr.height
  103:     def _set_child(self, curr, side, val):
  104:         '''Helping.'''
  105:         child = getattr(curr, side)
  106:         if child:
--------------------------------------------------------------------------------
[0.16195 s] incompetent

TypeError: bst2:93: TypeError: Bst._step() missing 1 required positional argument: 'curr'

   - [# 121] SDI bst2: 
--------------------------------------------------------------------------------
   99:         elif val > curr.val:
  100:             curr = self._set_child(curr, 'right', val)
  101:         return curr.height
  102:     
- 103:     def _set_child(self, curr, side, val):
- 104:         '''Helping.'''
- 105:         child = getattr(curr, side)
- 106:         if child:
- 107:             count = self._step(val, child)
- 108:             if curr.height <= count:
- 109:                 curr.height += 1
- 110:         else:
- 111:             setattr(curr, side, Node(val, curr))
- 112:             self._size += 1
- 113:             if curr.height == 1:
- 114:                 curr.height += 1
- 115:         return curr
- 116:     
+ 103:     @staticmethod
+ 104:     def _set_child(self, curr, side, val):
+ 105:         '''Helping.'''
+ 106:         child = getattr(curr, side)
+ 107:         if child:
+ 108:             count = self._step(val, child)
+ 109:             if curr.height <= count:
+ 110:                 curr.height += 1
+ 111:         else:
+ 112:             setattr(curr, side, Node(val, curr))
+ 113:             self._size += 1
+ 114:             if curr.height == 1:
+ 115:                 curr.height += 1
+ 116:         return curr
  117:     def search(self, val):
  118:         '''Return the node containing val.'''
  119:         curr = self.root
  120:         while curr:
--------------------------------------------------------------------------------
[0.15431 s] incompetent

TypeError: bst2:98: TypeError: Bst._set_child() missing 1 required positional argument: 'val'

   - [# 122] SDI bst2: 
--------------------------------------------------------------------------------
  113:             if curr.height == 1:
  114:                 curr.height += 1
  115:         return curr
  116:     
- 117:     def search(self, val):
- 118:         '''Return the node containing val.'''
- 119:         curr = self.root
- 120:         while curr:
- 121:             if curr.val == val:
- 122:                 return curr
- 123:             elif val < curr.val:
- 124:                 curr = curr.left
- 125:             else:
- 126:                 curr = curr.right
- 127:     
+ 117:     @staticmethod
+ 118:     def search(self, val):
+ 119:         '''Return the node containing val.'''
+ 120:         curr = self.root
+ 121:         while curr:
+ 122:             if curr.val == val:
+ 123:                 return curr
+ 124:             elif val < curr.val:
+ 125:                 curr = curr.left
+ 126:             else:
+ 127:                 curr = curr.right
  128:     def size(self):
  129:         '''Return the size of the BST.'''
  130:         return self._size
  131:     
--------------------------------------------------------------------------------
[0.15470 s] incompetent

TypeError: /home/lucca/teste/python_experiments2/bst2/ts-3-5/test_3-5_0-9_291.py:20: TypeError: Bst.search() missing 1 required positional argument: 'val'

   - [# 123] SDI bst2: 
--------------------------------------------------------------------------------
  124:                 curr = curr.left
  125:             else:
  126:                 curr = curr.right
  127:     
- 128:     def size(self):
- 129:         '''Return the size of the BST.'''
- 130:         return self._size
- 131:     
+ 128:     @staticmethod
+ 129:     def size(self):
+ 130:         '''Return the size of the BST.'''
+ 131:         return self._size
  132:     def depth(self):
  133:         '''Return depth of the BST, representing total levels.'''
  134:         return 0 if not (self.root) else self.root.height
  135:     
--------------------------------------------------------------------------------
[0.15376 s] incompetent

TypeError: /home/lucca/teste/python_experiments2/bst2/ts-3-5/test_3-5_0-9_291.py:19: TypeError: Bst.size() missing 1 required positional argument: 'self'

   - [# 124] SDI bst2: 
--------------------------------------------------------------------------------
  128:     def size(self):
  129:         '''Return the size of the BST.'''
  130:         return self._size
  131:     
- 132:     def depth(self):
- 133:         '''Return depth of the BST, representing total levels.'''
- 134:         return 0 if not (self.root) else self.root.height
- 135:     
+ 132:     @staticmethod
+ 133:     def depth(self):
+ 134:         '''Return depth of the BST, representing total levels.'''
+ 135:         return 0 if not (self.root) else self.root.height
  136:     def contains(self, val):
  137:         '''Return true if val is in the bst.'''
  138:         return self.search(val) is not None
  139:     
--------------------------------------------------------------------------------
[0.15677 s] incompetent

TypeError: /home/lucca/teste/python_experiments2/bst2/ts-3-5/test_3-5_0-9_291.py:30: TypeError: Bst.depth() missing 1 required positional argument: 'self'

   - [# 125] SDI bst2: 
--------------------------------------------------------------------------------
  132:     def depth(self):
  133:         '''Return depth of the BST, representing total levels.'''
  134:         return 0 if not (self.root) else self.root.height
  135:     
- 136:     def contains(self, val):
- 137:         '''Return true if val is in the bst.'''
- 138:         return self.search(val) is not None
- 139:     
+ 136:     @staticmethod
+ 137:     def contains(self, val):
+ 138:         '''Return true if val is in the bst.'''
+ 139:         return self.search(val) is not None
  140:     def balance(self, tree=None):
  141:         '''Return an integer of how well the tree is balanced.
  142: 
  143:         Trees which are higher on the left than the right should return a
--------------------------------------------------------------------------------
[0.18261 s] incompetent

TypeError: /home/lucca/teste/python_experiments2/bst2/ts-3-5/test_3-5_0-9_291.py:33: TypeError: Bst.contains() missing 1 required positional argument: 'val'

   - [# 126] SDI bst2: 
--------------------------------------------------------------------------------
  136:     def contains(self, val):
  137:         '''Return true if val is in the bst.'''
  138:         return self.search(val) is not None
  139:     
- 140:     def balance(self, tree=None):
- 141:         '''Return an integer of how well the tree is balanced.
- 142: 
- 143:         Trees which are higher on the left than the right should return a
- 144:         positive value, trees which are higher on the right than the left
- 145:         should return a negative value. An ideally-balanced tree should
- 146:         return 0.
- 147:         '''
- 148:         if not tree:
- 149:             tree = self.root
- 150:             if not tree:
- 151:                 return 0
- 152:         
- 153:         leftbranch = 0 if not (tree.left) else tree.left.height
- 154:         rightbranch = 0 if not (tree.right) else tree.right.height
- 155:         
- 156:         return leftbranch - rightbranch
- 157:     
+ 140:     @staticmethod
+ 141:     def balance(self, tree=None):
+ 142:         '''Return an integer of how well the tree is balanced.
+ 143: 
+ 144:         Trees which are higher on the left than the right should return a
+ 145:         positive value, trees which are higher on the right than the left
+ 146:         should return a negative value. An ideally-balanced tree should
+ 147:         return 0.
+ 148:         '''
+ 149:         if not tree:
+ 150:             tree = self.root
+ 151:             if not tree:
+ 152:                 return 0
+ 153:         
+ 154:         leftbranch = 0 if not (tree.left) else tree.left.height
+ 155:         rightbranch = 0 if not (tree.right) else tree.right.height
+ 156:         
+ 157:         return leftbranch - rightbranch
  158:     def pre_order(self, node='root'):
  159:         '''Depth first pre-order traversal of tree.'''
  160:         if node == 'root':
  161:             node = self.root
--------------------------------------------------------------------------------
[0.15486 s] incompetent

TypeError: /home/lucca/teste/python_experiments2/bst2/ts-3-5/test_3-5_0-9_291.py:37: TypeError: Bst.balance() missing 1 required positional argument: 'self'

   - [# 127] SDI bst2: 
--------------------------------------------------------------------------------
  154:         rightbranch = 0 if not (tree.right) else tree.right.height
  155:         
  156:         return leftbranch - rightbranch
  157:     
- 158:     def pre_order(self, node='root'):
- 159:         '''Depth first pre-order traversal of tree.'''
- 160:         if node == 'root':
- 161:             node = self.root
- 162:         
- 163:         if not node:
- 164:             return
- 165:         
- 166:         yield node.val
- 167:         
- 168:         for n in self.pre_order(node=node.left):
- 169:             yield n
- 170:         for n in self.pre_order(node=node.right):
- 171:             yield n
- 172:     
+ 158:     @staticmethod
+ 159:     def pre_order(self, node='root'):
+ 160:         '''Depth first pre-order traversal of tree.'''
+ 161:         if node == 'root':
+ 162:             node = self.root
+ 163:         
+ 164:         if not node:
+ 165:             return
+ 166:         
+ 167:         yield node.val
+ 168:         
+ 169:         for n in self.pre_order(node=node.left):
+ 170:             yield n
+ 171:         for n in self.pre_order(node=node.right):
+ 172:             yield n
  173:     def in_order(self, node='root'):
  174:         '''Depth first in-order traversal of tree.'''
  175:         if node == 'root':
  176:             node = self.root
--------------------------------------------------------------------------------
[0.15999 s] incompetent

TypeError: /home/lucca/teste/python_experiments2/bst2/ts-3-5/test_3-5_0-9_291.py:40: TypeError: Bst.pre_order() missing 1 required positional argument: 'self'

   - [# 128] SDI bst2: 
--------------------------------------------------------------------------------
  169:             yield n
  170:         for n in self.pre_order(node=node.right):
  171:             yield n
  172:     
- 173:     def in_order(self, node='root'):
- 174:         '''Depth first in-order traversal of tree.'''
- 175:         if node == 'root':
- 176:             node = self.root
- 177:         
- 178:         if not node:
- 179:             return
- 180:         
- 181:         for n in self.in_order(node=node.left):
- 182:             yield n
- 183:         yield node.val
- 184:         for n in self.in_order(node=node.right):
- 185:             yield n
- 186:     
+ 173:     @staticmethod
+ 174:     def in_order(self, node='root'):
+ 175:         '''Depth first in-order traversal of tree.'''
+ 176:         if node == 'root':
+ 177:             node = self.root
+ 178:         
+ 179:         if not node:
+ 180:             return
+ 181:         
+ 182:         for n in self.in_order(node=node.left):
+ 183:             yield n
+ 184:         yield node.val
+ 185:         for n in self.in_order(node=node.right):
+ 186:             yield n
  187:     def post_order(self, node='root'):
  188:         '''Depth frist post_order traversal of tree.'''
  189:         if node == 'root':
  190:             node = self.root
--------------------------------------------------------------------------------
[0.16145 s] incompetent

TypeError: /home/lucca/teste/python_experiments2/bst2/ts-3-5/test_3-5_0-9_291.py:43: TypeError: Bst.in_order() missing 1 required positional argument: 'self'

   - [# 129] SDI bst2: 
--------------------------------------------------------------------------------
  183:         yield node.val
  184:         for n in self.in_order(node=node.right):
  185:             yield n
  186:     
- 187:     def post_order(self, node='root'):
- 188:         '''Depth frist post_order traversal of tree.'''
- 189:         if node == 'root':
- 190:             node = self.root
- 191:         
- 192:         if not node:
- 193:             return
- 194:         
- 195:         for n in self.post_order(node=node.left):
- 196:             yield n
- 197:         for n in self.post_order(node=node.right):
- 198:             yield n
- 199:         yield node.val
- 200:     
+ 187:     @staticmethod
+ 188:     def post_order(self, node='root'):
+ 189:         '''Depth frist post_order traversal of tree.'''
+ 190:         if node == 'root':
+ 191:             node = self.root
+ 192:         
+ 193:         if not node:
+ 194:             return
+ 195:         
+ 196:         for n in self.post_order(node=node.left):
+ 197:             yield n
+ 198:         for n in self.post_order(node=node.right):
+ 199:             yield n
+ 200:         yield node.val
  201:     def breadth_first(self):
  202:         '''Breadth first traversal of tree.'''
  203:         q = Queue()
  204:         q.enqueue(self.root)
--------------------------------------------------------------------------------
[0.19133 s] incompetent

TypeError: /home/lucca/teste/python_experiments2/bst2/ts-3-5/test_3-5_0-9_291.py:46: TypeError: Bst.post_order() missing 1 required positional argument: 'self'

   - [# 130] SDI bst2: 
--------------------------------------------------------------------------------
  197:         for n in self.post_order(node=node.right):
  198:             yield n
  199:         yield node.val
  200:     
- 201:     def breadth_first(self):
- 202:         '''Breadth first traversal of tree.'''
- 203:         q = Queue()
- 204:         q.enqueue(self.root)
- 205:         while q.peek():
- 206:             node = q.dequeue()
- 207:             yield node.val
- 208:             if node.left:
- 209:                 q.enqueue(node.left)
- 210:             if node.right:
- 211:                 q.enqueue(node.right)
- 212:     
+ 201:     @staticmethod
+ 202:     def breadth_first(self):
+ 203:         '''Breadth first traversal of tree.'''
+ 204:         q = Queue()
+ 205:         q.enqueue(self.root)
+ 206:         while q.peek():
+ 207:             node = q.dequeue()
+ 208:             yield node.val
+ 209:             if node.left:
+ 210:                 q.enqueue(node.left)
+ 211:             if node.right:
+ 212:                 q.enqueue(node.right)
  213:     def delete(self, val):
  214:         '''Remove a node from the tree.'''
  215:         if (self._size < 1 or not (self.contains(val))):
  216:             return
--------------------------------------------------------------------------------
[0.15980 s] incompetent

TypeError: /home/lucca/teste/python_experiments2/bst2/ts-3-5/test_3-5_0-9_291.py:49: TypeError: Bst.breadth_first() missing 1 required positional argument: 'self'

   - [# 131] SDI bst2: 
--------------------------------------------------------------------------------
  209:                 q.enqueue(node.left)
  210:             if node.right:
  211:                 q.enqueue(node.right)
  212:     
- 213:     def delete(self, val):
- 214:         '''Remove a node from the tree.'''
- 215:         if (self._size < 1 or not (self.contains(val))):
- 216:             return
- 217:         
- 218:         node = self.search(val)
- 219:         
- 220:         if node._is_leaf():
- 221:             if node.parent:
- 222:                 setattr(node.parent, node._side(), None)
- 223:             else:
- 224:                 self.root = None
- 225:         
- 226:         elif node._is_interior():
- 227:             next_node = self._find_replacement(node)
- 228:             self._size += 1
- 229:             self.delete(next_node.val)
- 230:             node.val = next_node.val
- 231:         else:
- 232:             
- 233:             child = getattr(node, node._onlychild())
- 234:             if node.parent:
- 235:                 child.parent = node.parent
- 236:                 setattr(node.parent, node._side(), child)
- 237:             else:
- 238:                 self.root = child
- 239:         
- 240:         self._size -= 1
- 241:     
+ 213:     @staticmethod
+ 214:     def delete(self, val):
+ 215:         '''Remove a node from the tree.'''
+ 216:         if (self._size < 1 or not (self.contains(val))):
+ 217:             return
+ 218:         
+ 219:         node = self.search(val)
+ 220:         
+ 221:         if node._is_leaf():
+ 222:             if node.parent:
+ 223:                 setattr(node.parent, node._side(), None)
+ 224:             else:
+ 225:                 self.root = None
+ 226:         
+ 227:         elif node._is_interior():
+ 228:             next_node = self._find_replacement(node)
+ 229:             self._size += 1
+ 230:             self.delete(next_node.val)
+ 231:             node.val = next_node.val
+ 232:         else:
+ 233:             
+ 234:             child = getattr(node, node._onlychild())
+ 235:             if node.parent:
+ 236:                 child.parent = node.parent
+ 237:                 setattr(node.parent, node._side(), child)
+ 238:             else:
+ 239:                 self.root = child
+ 240:         
+ 241:         self._size -= 1
  242:     def _find_replacement(self, node):
  243:         '''Find left most node of right subtree.'''
  244:         if node.right:
  245:             return self._findmin(node.right)
--------------------------------------------------------------------------------
[0.16006 s] incompetent

TypeError: /home/lucca/teste/python_experiments2/bst2/ts-3-5/test_3-5_0-9_291.py:52: TypeError: Bst.delete() missing 1 required positional argument: 'val'

   - [# 132] SDI bst2: 
--------------------------------------------------------------------------------
  238:                 self.root = child
  239:         
  240:         self._size -= 1
  241:     
- 242:     def _find_replacement(self, node):
- 243:         '''Find left most node of right subtree.'''
- 244:         if node.right:
- 245:             return self._findmin(node.right)
- 246:         
- 247:         elif node.parent:
- 248:             if node._side() == 'left':
- 249:                 return self.parent
- 250:             else:
- 251:                 node.parent.right = None
- 252:                 tmp = self._find_replacement(node.parent)
- 253:                 node.parent.right = node
- 254:                 return tmp
- 255:     
+ 242:     @staticmethod
+ 243:     def _find_replacement(self, node):
+ 244:         '''Find left most node of right subtree.'''
+ 245:         if node.right:
+ 246:             return self._findmin(node.right)
+ 247:         
+ 248:         elif node.parent:
+ 249:             if node._side() == 'left':
+ 250:                 return self.parent
+ 251:             else:
+ 252:                 node.parent.right = None
+ 253:                 tmp = self._find_replacement(node.parent)
+ 254:                 node.parent.right = node
+ 255:                 return tmp
  256:     def _findmin(self, node):
  257:         '''Find min of subtree, Min is always left most node.'''
  258:         while node.left:
  259:             node = node.left
--------------------------------------------------------------------------------
[0.13530 s] survived
   - [# 133] SDI bst2: 
--------------------------------------------------------------------------------
  252:                 tmp = self._find_replacement(node.parent)
  253:                 node.parent.right = node
  254:                 return tmp
  255:     
- 256:     def _findmin(self, node):
- 257:         '''Find min of subtree, Min is always left most node.'''
- 258:         while node.left:
- 259:             node = node.left
- 260:         return node
+ 256:     @staticmethod
+ 257:     def _findmin(self, node):
+ 258:         '''Find min of subtree, Min is always left most node.'''
+ 259:         while node.left:
+ 260:             node = node.left
+ 261:         return node
--------------------------------------------------------------------------------
[0.13653 s] survived
   - [# 134] SDL bst2: 
--------------------------------------------------------------------------------
    7:     '''Node, or leaf of the BST.'''
    8:     
    9:     def __init__(self, val=None, parent=None):
   10:         '''Create node object.'''
-  11:         self.val = val
+  11:         pass
   12:         self.right = None
   13:         self.left = None
   14:         self.parent = parent
   15:         self.height = 1
--------------------------------------------------------------------------------
[0.15563 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_insert

self = <test_3-5_0-9_291.TestBst object at 0x70408c0948b0>

    @pytest.fixture
    def bst_instance(self):
>       return Bst([5, 3, 8, 1, 4, 7, 9])

ts-3-5/test_3-5_0-9_291.py:15: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
bst2:85: in __init__
    ???
bst2:93: in insert
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x70408c094fd0>, val = 3
curr = <bst2.Node object at 0x70408c096380>

>   ???
E   AttributeError: 'Node' object has no attribute 'val'

bst2:97: AttributeError
   - [# 135] SDL bst2: 
--------------------------------------------------------------------------------
    8:     
    9:     def __init__(self, val=None, parent=None):
   10:         '''Create node object.'''
   11:         self.val = val
-  12:         self.right = None
+  12:         pass
   13:         self.left = None
   14:         self.parent = parent
   15:         self.height = 1
   16:     
--------------------------------------------------------------------------------
[0.15769 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_insert

self = <test_3-5_0-9_291.TestBst object at 0x70408c108340>

    @pytest.fixture
    def bst_instance(self):
>       return Bst([5, 3, 8, 1, 4, 7, 9])

ts-3-5/test_3-5_0-9_291.py:15: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
bst2:85: in __init__
    ???
bst2:93: in insert
    ???
bst2:100: in _step
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x70408c10b520>
curr = <bst2.Node object at 0x70408c10bbe0>, side = 'right', val = 8

>   ???
E   AttributeError: 'Node' object has no attribute 'right'. Did you mean: 'height'?

bst2:105: AttributeError
   - [# 136] SDL bst2: 
--------------------------------------------------------------------------------
    9:     def __init__(self, val=None, parent=None):
   10:         '''Create node object.'''
   11:         self.val = val
   12:         self.right = None
-  13:         self.left = None
+  13:         pass
   14:         self.parent = parent
   15:         self.height = 1
   16:     
   17:     def _is_leaf(self):
--------------------------------------------------------------------------------
[0.16072 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_insert

self = <test_3-5_0-9_291.TestBst object at 0x70408bf53250>

    @pytest.fixture
    def bst_instance(self):
>       return Bst([5, 3, 8, 1, 4, 7, 9])

ts-3-5/test_3-5_0-9_291.py:15: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
bst2:85: in __init__
    ???
bst2:93: in insert
    ???
bst2:98: in _step
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x70408bf51d50>
curr = <bst2.Node object at 0x70408bf51540>, side = 'left', val = 3

>   ???
E   AttributeError: 'Node' object has no attribute 'left'

bst2:105: AttributeError
   - [# 137] SDL bst2: 
--------------------------------------------------------------------------------
   10:         '''Create node object.'''
   11:         self.val = val
   12:         self.right = None
   13:         self.left = None
-  14:         self.parent = parent
+  14:         pass
   15:         self.height = 1
   16:     
   17:     def _is_leaf(self):
   18:         '''Return true if a leaf.'''
--------------------------------------------------------------------------------
[0.15859 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_delete

self = <test_3-5_0-9_291.TestBst object at 0x70408ba149d0>
bst_instance = <bst2.Bst object at 0x70408ba14310>

    def test_delete(self, bst_instance):
>       bst_instance.delete(1)

ts-3-5/test_3-5_0-9_291.py:52: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x70408ba14310>, val = 1

>   ???
E   AttributeError: 'Node' object has no attribute 'parent'

bst2:221: AttributeError
   - [# 138] SDL bst2: 
--------------------------------------------------------------------------------
   11:         self.val = val
   12:         self.right = None
   13:         self.left = None
   14:         self.parent = parent
-  15:         self.height = 1
+  15:         pass
   16:     
   17:     def _is_leaf(self):
   18:         '''Return true if a leaf.'''
   19:         return (self.right is None and self.left is None)
--------------------------------------------------------------------------------
[0.18708 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_insert

self = <test_3-5_0-9_291.TestBst object at 0x70408be47490>

    @pytest.fixture
    def bst_instance(self):
>       return Bst([5, 3, 8, 1, 4, 7, 9])

ts-3-5/test_3-5_0-9_291.py:15: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
bst2:85: in __init__
    ???
bst2:93: in insert
    ???
bst2:98: in _step
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x70408be46a10>
curr = <bst2.Node object at 0x70408be47af0>, side = 'left', val = 3

>   ???
E   AttributeError: 'Node' object has no attribute 'height'. Did you mean: 'right'?

bst2:113: AttributeError
   - [# 139] SDL bst2: 
--------------------------------------------------------------------------------
   15:         self.height = 1
   16:     
   17:     def _is_leaf(self):
   18:         '''Return true if a leaf.'''
-  19:         return (self.right is None and self.left is None)
+  19:         pass
   20:     
   21:     def _is_interior(self):
   22:         '''Return true if a interior node.'''
   23:         return (self.right is not None and self.left is not None)
--------------------------------------------------------------------------------
[0.15678 s] incompetent

TypeError: bst2:233: TypeError: getattr(): attribute name must be string

   - [# 140] SDL bst2: 
--------------------------------------------------------------------------------
   19:         return (self.right is None and self.left is None)
   20:     
   21:     def _is_interior(self):
   22:         '''Return true if a interior node.'''
-  23:         return (self.right is not None and self.left is not None)
+  23:         pass
   24:     
   25:     def _onlychild(self):
   26:         '''Return string depending on children.'''
   27:         if (self.left and not (self.right)):
--------------------------------------------------------------------------------
[0.16291 s] killed by ts-3-5/test_3-5_0-9_291.py::TestNode::test_is_interior

self = <test_3-5_0-9_291.TestNode object at 0x70408ba687c0>

    def test_is_interior(self):
        node = Node(5)
>       assert node._is_interior() is False
E       AssertionError

ts-3-5/test_3-5_0-9_291.py:64: AssertionError
   - [# 141] SDL bst2: 
--------------------------------------------------------------------------------
   24:     
   25:     def _onlychild(self):
   26:         '''Return string depending on children.'''
   27:         if (self.left and not (self.right)):
-  28:             return 'left'
+  28:             pass
   29:         if (self.right and not (self.left)):
   30:             return 'right'
   31:     
   32:     def _side(self):
--------------------------------------------------------------------------------
[0.16797 s] killed by ts-3-5/test_3-5_0-9_291.py::TestNode::test_onlychild

self = <test_3-5_0-9_291.TestNode object at 0x70408c12d8d0>

    def test_onlychild(self):
        node = Node(5)
        node.left = Node(3)
>       assert node._onlychild() == 'left'
E       AssertionError

ts-3-5/test_3-5_0-9_291.py:69: AssertionError
   - [# 142] SDL bst2: 
--------------------------------------------------------------------------------
   26:         '''Return string depending on children.'''
   27:         if (self.left and not (self.right)):
   28:             return 'left'
   29:         if (self.right and not (self.left)):
-  30:             return 'right'
+  30:             pass
   31:     
   32:     def _side(self):
   33:         '''Return if left or right child of parent.'''
   34:         if self.parent:
--------------------------------------------------------------------------------
[0.13423 s] survived
   - [# 143] SDL bst2: 
--------------------------------------------------------------------------------
   31:     
   32:     def _side(self):
   33:         '''Return if left or right child of parent.'''
   34:         if self.parent:
-  35:             return 'left' if self.parent.left == self else 'right'
+  35:             pass
   36: 
   37: 
   38: class Bst(object):
   39:     '''Binary Search Tree.
--------------------------------------------------------------------------------
[0.16347 s] incompetent

TypeError: bst2:222: TypeError: attribute name must be string, not 'NoneType'

   - [# 144] SDL bst2: 
--------------------------------------------------------------------------------
   76:     '''
   77:     
   78:     def __init__(self, data=None):
   79:         '''Initialize tree.'''
-  80:         self._size = 0
+  80:         pass
   81:         self.root = None
   82:         
   83:         if data:
   84:             for i in data:
--------------------------------------------------------------------------------
[0.15534 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_insert

self = <test_3-5_0-9_291.TestBst object at 0x70408bc41fc0>

    @pytest.fixture
    def bst_instance(self):
>       return Bst([5, 3, 8, 1, 4, 7, 9])

ts-3-5/test_3-5_0-9_291.py:15: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
bst2:85: in __init__
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x70408bc40460>, val = 5

>   ???
E   AttributeError: 'Bst' object has no attribute '_size'. Did you mean: 'size'?

bst2:91: AttributeError
   - [# 145] SDL bst2: 
--------------------------------------------------------------------------------
   77:     
   78:     def __init__(self, data=None):
   79:         '''Initialize tree.'''
   80:         self._size = 0
-  81:         self.root = None
+  81:         pass
   82:         
   83:         if data:
   84:             for i in data:
   85:                 self.insert(i)
--------------------------------------------------------------------------------
[0.15349 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_insert

self = <test_3-5_0-9_291.TestBst object at 0x70408bc08f70>

    @pytest.fixture
    def bst_instance(self):
>       return Bst([5, 3, 8, 1, 4, 7, 9])

ts-3-5/test_3-5_0-9_291.py:15: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
bst2:85: in __init__
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x70408bc09090>, val = 5

>   ???
E   AttributeError: 'Bst' object has no attribute 'root'

bst2:89: AttributeError
   - [# 146] SDL bst2: 
--------------------------------------------------------------------------------
   81:         self.root = None
   82:         
   83:         if data:
   84:             for i in data:
-  85:                 self.insert(i)
+  85:                 pass
   86:     
   87:     def insert(self, val):
   88:         '''Insert val into BST. If val is already present will be ignored.'''
   89:         if not (self.root):
--------------------------------------------------------------------------------
[0.15225 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_insert

self = <test_3-5_0-9_291.TestBst object at 0x70408ba91420>
bst_instance = <bst2.Bst object at 0x70408ba91540>

    def test_insert(self, bst_instance):
        bst_instance.insert(10)
>       assert bst_instance.size() == 8
E       AssertionError

ts-3-5/test_3-5_0-9_291.py:19: AssertionError
   - [# 147] SDL bst2: 
--------------------------------------------------------------------------------
   86:     
   87:     def insert(self, val):
   88:         '''Insert val into BST. If val is already present will be ignored.'''
   89:         if not (self.root):
-  90:             self.root = Node(val)
+  90:             pass
   91:             self._size += 1
   92:         else:
   93:             self._step(val, self.root)
   94:     
--------------------------------------------------------------------------------
[0.18585 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_insert

self = <test_3-5_0-9_291.TestBst object at 0x70408bae1960>
bst_instance = <bst2.Bst object at 0x70408bfe1ff0>

    def test_insert(self, bst_instance):
        bst_instance.insert(10)
        assert bst_instance.size() == 8
>       assert bst_instance.search(10).val == 10
E       AttributeError: 'NoneType' object has no attribute 'val'

ts-3-5/test_3-5_0-9_291.py:20: AttributeError
   - [# 148] SDL bst2: 
--------------------------------------------------------------------------------
   89:         if not (self.root):
   90:             self.root = Node(val)
   91:             self._size += 1
   92:         else:
-  93:             self._step(val, self.root)
+  93:             pass
   94:     
   95:     def _step(self, val, curr):
   96:         '''Decide left or right and returns height.'''
   97:         if val < curr.val:
--------------------------------------------------------------------------------
[0.14856 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_insert

self = <test_3-5_0-9_291.TestBst object at 0x70408bc3f220>
bst_instance = <bst2.Bst object at 0x70408bc3c7c0>

    def test_insert(self, bst_instance):
        bst_instance.insert(10)
>       assert bst_instance.size() == 8
E       AssertionError

ts-3-5/test_3-5_0-9_291.py:19: AssertionError
   - [# 149] SDL bst2: 
--------------------------------------------------------------------------------
   94:     
   95:     def _step(self, val, curr):
   96:         '''Decide left or right and returns height.'''
   97:         if val < curr.val:
-  98:             curr = self._set_child(curr, 'left', val)
+  98:             pass
   99:         elif val > curr.val:
  100:             curr = self._set_child(curr, 'right', val)
  101:         return curr.height
  102:     
--------------------------------------------------------------------------------
[0.15051 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_insert

self = <test_3-5_0-9_291.TestBst object at 0x70408be19330>
bst_instance = <bst2.Bst object at 0x70408c0baa40>

    def test_insert(self, bst_instance):
        bst_instance.insert(10)
>       assert bst_instance.size() == 8
E       AssertionError

ts-3-5/test_3-5_0-9_291.py:19: AssertionError
   - [# 150] SDL bst2: 
--------------------------------------------------------------------------------
   96:         '''Decide left or right and returns height.'''
   97:         if val < curr.val:
   98:             curr = self._set_child(curr, 'left', val)
   99:         elif val > curr.val:
- 100:             curr = self._set_child(curr, 'right', val)
+ 100:             pass
  101:         return curr.height
  102:     
  103:     def _set_child(self, curr, side, val):
  104:         '''Helping.'''
--------------------------------------------------------------------------------
[0.14944 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_insert

self = <test_3-5_0-9_291.TestBst object at 0x70408c0a1030>
bst_instance = <bst2.Bst object at 0x70408c0a1150>

    def test_insert(self, bst_instance):
        bst_instance.insert(10)
>       assert bst_instance.size() == 8
E       AssertionError

ts-3-5/test_3-5_0-9_291.py:19: AssertionError
   - [# 151] SDL bst2: 
--------------------------------------------------------------------------------
   97:         if val < curr.val:
   98:             curr = self._set_child(curr, 'left', val)
   99:         elif val > curr.val:
  100:             curr = self._set_child(curr, 'right', val)
- 101:         return curr.height
+ 101:         pass
  102:     
  103:     def _set_child(self, curr, side, val):
  104:         '''Helping.'''
  105:         child = getattr(curr, side)
--------------------------------------------------------------------------------
[0.15389 s] incompetent

TypeError: bst2:108: TypeError: '<=' not supported between instances of 'int' and 'NoneType'

   - [# 152] SDL bst2: 
--------------------------------------------------------------------------------
  101:         return curr.height
  102:     
  103:     def _set_child(self, curr, side, val):
  104:         '''Helping.'''
- 105:         child = getattr(curr, side)
+ 105:         pass
  106:         if child:
  107:             count = self._step(val, child)
  108:             if curr.height <= count:
  109:                 curr.height += 1
--------------------------------------------------------------------------------
[0.15585 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_insert

self = <test_3-5_0-9_291.TestBst object at 0x70408bd7f970>

    @pytest.fixture
    def bst_instance(self):
>       return Bst([5, 3, 8, 1, 4, 7, 9])

ts-3-5/test_3-5_0-9_291.py:15: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
bst2:85: in __init__
    ???
bst2:93: in insert
    ???
bst2:98: in _step
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x70408bd7e7a0>
curr = <bst2.Node object at 0x70408bd7c100>, side = 'left', val = 3

>   ???
E   NameError: name 'child' is not defined

bst2:106: NameError
   - [# 153] SDL bst2: 
--------------------------------------------------------------------------------
  103:     def _set_child(self, curr, side, val):
  104:         '''Helping.'''
  105:         child = getattr(curr, side)
  106:         if child:
- 107:             count = self._step(val, child)
+ 107:             pass
  108:             if curr.height <= count:
  109:                 curr.height += 1
  110:         else:
  111:             setattr(curr, side, Node(val, curr))
--------------------------------------------------------------------------------
[0.15785 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_insert

self = <test_3-5_0-9_291.TestBst object at 0x70408bca6350>

    @pytest.fixture
    def bst_instance(self):
>       return Bst([5, 3, 8, 1, 4, 7, 9])

ts-3-5/test_3-5_0-9_291.py:15: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
bst2:85: in __init__
    ???
bst2:93: in insert
    ???
bst2:98: in _step
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x70408bca4f10>
curr = <bst2.Node object at 0x70408bca54b0>, side = 'left', val = 1

>   ???
E   NameError: name 'count' is not defined

bst2:108: NameError
   - [# 154] SDL bst2: 
--------------------------------------------------------------------------------
  107:             count = self._step(val, child)
  108:             if curr.height <= count:
  109:                 curr.height += 1
  110:         else:
- 111:             setattr(curr, side, Node(val, curr))
+ 111:             pass
  112:             self._size += 1
  113:             if curr.height == 1:
  114:                 curr.height += 1
  115:         return curr
--------------------------------------------------------------------------------
[0.15912 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_insert

self = <test_3-5_0-9_291.TestBst object at 0x70408c0b8a00>
bst_instance = <bst2.Bst object at 0x70408c1fedd0>

    def test_insert(self, bst_instance):
        bst_instance.insert(10)
        assert bst_instance.size() == 8
>       assert bst_instance.search(10).val == 10
E       AttributeError: 'NoneType' object has no attribute 'val'

ts-3-5/test_3-5_0-9_291.py:20: AttributeError
   - [# 155] SDL bst2: 
--------------------------------------------------------------------------------
  111:             setattr(curr, side, Node(val, curr))
  112:             self._size += 1
  113:             if curr.height == 1:
  114:                 curr.height += 1
- 115:         return curr
+ 115:         pass
  116:     
  117:     def search(self, val):
  118:         '''Return the node containing val.'''
  119:         curr = self.root
--------------------------------------------------------------------------------
[0.15632 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_insert

self = <test_3-5_0-9_291.TestBst object at 0x70408bcef790>

    @pytest.fixture
    def bst_instance(self):
>       return Bst([5, 3, 8, 1, 4, 7, 9])

ts-3-5/test_3-5_0-9_291.py:15: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
bst2:85: in __init__
    ???
bst2:93: in insert
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x70408bcef6a0>, val = 3, curr = None

>   ???
E   AttributeError: 'NoneType' object has no attribute 'height'

bst2:101: AttributeError
   - [# 156] SDL bst2: 
--------------------------------------------------------------------------------
  115:         return curr
  116:     
  117:     def search(self, val):
  118:         '''Return the node containing val.'''
- 119:         curr = self.root
+ 119:         pass
  120:         while curr:
  121:             if curr.val == val:
  122:                 return curr
  123:             elif val < curr.val:
--------------------------------------------------------------------------------
[0.18330 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_insert

self = <test_3-5_0-9_291.TestBst object at 0x70408bafa7d0>
bst_instance = <bst2.Bst object at 0x70408bafa8f0>

    def test_insert(self, bst_instance):
        bst_instance.insert(10)
        assert bst_instance.size() == 8
>       assert bst_instance.search(10).val == 10

ts-3-5/test_3-5_0-9_291.py:20: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x70408bafa8f0>, val = 10

>   ???
E   UnboundLocalError: local variable 'curr' referenced before assignment

bst2:120: UnboundLocalError
   - [# 157] SDL bst2: 
--------------------------------------------------------------------------------
  118:         '''Return the node containing val.'''
  119:         curr = self.root
  120:         while curr:
  121:             if curr.val == val:
- 122:                 return curr
+ 122:                 pass
  123:             elif val < curr.val:
  124:                 curr = curr.left
  125:             else:
  126:                 curr = curr.right
--------------------------------------------------------------------------------
[5.00647 s] timeout
   - [# 158] SDL bst2: 
--------------------------------------------------------------------------------
  120:         while curr:
  121:             if curr.val == val:
  122:                 return curr
  123:             elif val < curr.val:
- 124:                 curr = curr.left
+ 124:                 pass
  125:             else:
  126:                 curr = curr.right
  127:     
  128:     def size(self):
--------------------------------------------------------------------------------
[5.00687 s] timeout
   - [# 159] SDL bst2: 
--------------------------------------------------------------------------------
  122:                 return curr
  123:             elif val < curr.val:
  124:                 curr = curr.left
  125:             else:
- 126:                 curr = curr.right
+ 126:                 pass
  127:     
  128:     def size(self):
  129:         '''Return the size of the BST.'''
  130:         return self._size
--------------------------------------------------------------------------------
[5.00601 s] timeout
   - [# 160] SDL bst2: 
--------------------------------------------------------------------------------
  126:                 curr = curr.right
  127:     
  128:     def size(self):
  129:         '''Return the size of the BST.'''
- 130:         return self._size
+ 130:         pass
  131:     
  132:     def depth(self):
  133:         '''Return depth of the BST, representing total levels.'''
  134:         return 0 if not (self.root) else self.root.height
--------------------------------------------------------------------------------
[0.14474 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_insert

self = <test_3-5_0-9_291.TestBst object at 0x70408c032da0>
bst_instance = <bst2.Bst object at 0x70408c032ec0>

    def test_insert(self, bst_instance):
        bst_instance.insert(10)
>       assert bst_instance.size() == 8
E       AssertionError

ts-3-5/test_3-5_0-9_291.py:19: AssertionError
   - [# 161] SDL bst2: 
--------------------------------------------------------------------------------
  130:         return self._size
  131:     
  132:     def depth(self):
  133:         '''Return depth of the BST, representing total levels.'''
- 134:         return 0 if not (self.root) else self.root.height
+ 134:         pass
  135:     
  136:     def contains(self, val):
  137:         '''Return true if val is in the bst.'''
  138:         return self.search(val) is not None
--------------------------------------------------------------------------------
[0.18366 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_depth

self = <test_3-5_0-9_291.TestBst object at 0x70408ba5e0e0>
bst_instance = <bst2.Bst object at 0x70408ba5cdc0>

    def test_depth(self, bst_instance):
>       assert bst_instance.depth() == 3
E       AssertionError

ts-3-5/test_3-5_0-9_291.py:30: AssertionError
   - [# 162] SDL bst2: 
--------------------------------------------------------------------------------
  134:         return 0 if not (self.root) else self.root.height
  135:     
  136:     def contains(self, val):
  137:         '''Return true if val is in the bst.'''
- 138:         return self.search(val) is not None
+ 138:         pass
  139:     
  140:     def balance(self, tree=None):
  141:         '''Return an integer of how well the tree is balanced.
  142: 
--------------------------------------------------------------------------------
[0.14912 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_contains

self = <test_3-5_0-9_291.TestBst object at 0x70408bc3f160>
bst_instance = <bst2.Bst object at 0x70408bc3eb30>

    def test_contains(self, bst_instance):
>       assert bst_instance.contains(7) is True
E       AssertionError

ts-3-5/test_3-5_0-9_291.py:33: AssertionError
   - [# 163] SDL bst2: 
--------------------------------------------------------------------------------
  145:         should return a negative value. An ideally-balanced tree should
  146:         return 0.
  147:         '''
  148:         if not tree:
- 149:             tree = self.root
+ 149:             pass
  150:             if not tree:
  151:                 return 0
  152:         
  153:         leftbranch = 0 if not (tree.left) else tree.left.height
--------------------------------------------------------------------------------
[0.13288 s] survived
   - [# 164] SDL bst2: 
--------------------------------------------------------------------------------
  147:         '''
  148:         if not tree:
  149:             tree = self.root
  150:             if not tree:
- 151:                 return 0
+ 151:                 pass
  152:         
  153:         leftbranch = 0 if not (tree.left) else tree.left.height
  154:         rightbranch = 0 if not (tree.right) else tree.right.height
  155:         
--------------------------------------------------------------------------------
[0.13478 s] survived
   - [# 165] SDL bst2: 
--------------------------------------------------------------------------------
  149:             tree = self.root
  150:             if not tree:
  151:                 return 0
  152:         
- 153:         leftbranch = 0 if not (tree.left) else tree.left.height
+ 153:         pass
  154:         rightbranch = 0 if not (tree.right) else tree.right.height
  155:         
  156:         return leftbranch - rightbranch
  157:     
--------------------------------------------------------------------------------
[0.15518 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_balance

self = <test_3-5_0-9_291.TestBst object at 0x70408bbcfa60>
bst_instance = <bst2.Bst object at 0x70408bc90a90>

    def test_balance(self, bst_instance):
>       assert bst_instance.balance() == 0

ts-3-5/test_3-5_0-9_291.py:37: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x70408bc90a90>
tree = <bst2.Node object at 0x70408bc91ed0>

>   ???
E   NameError: name 'leftbranch' is not defined

bst2:156: NameError
   - [# 166] SDL bst2: 
--------------------------------------------------------------------------------
  150:             if not tree:
  151:                 return 0
  152:         
  153:         leftbranch = 0 if not (tree.left) else tree.left.height
- 154:         rightbranch = 0 if not (tree.right) else tree.right.height
+ 154:         pass
  155:         
  156:         return leftbranch - rightbranch
  157:     
  158:     def pre_order(self, node='root'):
--------------------------------------------------------------------------------
[0.15632 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_balance

self = <test_3-5_0-9_291.TestBst object at 0x70408c0f6770>
bst_instance = <bst2.Bst object at 0x70408c0f56c0>

    def test_balance(self, bst_instance):
>       assert bst_instance.balance() == 0

ts-3-5/test_3-5_0-9_291.py:37: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x70408c0f56c0>
tree = <bst2.Node object at 0x70408c3d36a0>

>   ???
E   NameError: name 'rightbranch' is not defined

bst2:156: NameError
   - [# 167] SDL bst2: 
--------------------------------------------------------------------------------
  152:         
  153:         leftbranch = 0 if not (tree.left) else tree.left.height
  154:         rightbranch = 0 if not (tree.right) else tree.right.height
  155:         
- 156:         return leftbranch - rightbranch
+ 156:         pass
  157:     
  158:     def pre_order(self, node='root'):
  159:         '''Depth first pre-order traversal of tree.'''
  160:         if node == 'root':
--------------------------------------------------------------------------------
[0.15414 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_balance

self = <test_3-5_0-9_291.TestBst object at 0x70408ba1bd60>
bst_instance = <bst2.Bst object at 0x70408ba19480>

    def test_balance(self, bst_instance):
>       assert bst_instance.balance() == 0
E       AssertionError

ts-3-5/test_3-5_0-9_291.py:37: AssertionError
   - [# 168] SDL bst2: 
--------------------------------------------------------------------------------
  157:     
  158:     def pre_order(self, node='root'):
  159:         '''Depth first pre-order traversal of tree.'''
  160:         if node == 'root':
- 161:             node = self.root
+ 161:             pass
  162:         
  163:         if not node:
  164:             return
  165:         
--------------------------------------------------------------------------------
[0.15710 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_pre_order

self = <test_3-5_0-9_291.TestBst object at 0x70408c06d180>
bst_instance = <bst2.Bst object at 0x70408c06c6d0>

    def test_pre_order(self, bst_instance):
>       assert list(bst_instance.pre_order()) == [5, 3, 1, 4, 8, 7, 9]

ts-3-5/test_3-5_0-9_291.py:40: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x70408c06c6d0>, node = 'root'

>   ???
E   AttributeError: 'str' object has no attribute 'val'

bst2:166: AttributeError
   - [# 169] SDL bst2: 
--------------------------------------------------------------------------------
  160:         if node == 'root':
  161:             node = self.root
  162:         
  163:         if not node:
- 164:             return
+ 164:             pass
  165:         
  166:         yield node.val
  167:         
  168:         for n in self.pre_order(node=node.left):
--------------------------------------------------------------------------------
[0.15547 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_pre_order

self = <test_3-5_0-9_291.TestBst object at 0x70408be47bb0>
bst_instance = <bst2.Bst object at 0x70408be45c30>

    def test_pre_order(self, bst_instance):
>       assert list(bst_instance.pre_order()) == [5, 3, 1, 4, 8, 7, 9]

ts-3-5/test_3-5_0-9_291.py:40: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
bst2:168: in pre_order
    ???
bst2:168: in pre_order
    ???
bst2:168: in pre_order
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x70408be45c30>, node = None

>   ???
E   AttributeError: 'NoneType' object has no attribute 'val'

bst2:166: AttributeError
   - [# 170] SDL bst2: 
--------------------------------------------------------------------------------
  162:         
  163:         if not node:
  164:             return
  165:         
- 166:         yield node.val
+ 166:         pass
  167:         
  168:         for n in self.pre_order(node=node.left):
  169:             yield n
  170:         for n in self.pre_order(node=node.right):
--------------------------------------------------------------------------------
[0.18355 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_pre_order

self = <test_3-5_0-9_291.TestBst object at 0x70408bc9b910>
bst_instance = <bst2.Bst object at 0x70408bc6e9e0>

    def test_pre_order(self, bst_instance):
>       assert list(bst_instance.pre_order()) == [5, 3, 1, 4, 8, 7, 9]
E       AssertionError

ts-3-5/test_3-5_0-9_291.py:40: AssertionError
   - [# 171] SDL bst2: 
--------------------------------------------------------------------------------
  165:         
  166:         yield node.val
  167:         
  168:         for n in self.pre_order(node=node.left):
- 169:             yield n
+ 169:             pass
  170:         for n in self.pre_order(node=node.right):
  171:             yield n
  172:     
  173:     def in_order(self, node='root'):
--------------------------------------------------------------------------------
[0.15769 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_pre_order

self = <test_3-5_0-9_291.TestBst object at 0x70408c13bb80>
bst_instance = <bst2.Bst object at 0x70408c138220>

    def test_pre_order(self, bst_instance):
>       assert list(bst_instance.pre_order()) == [5, 3, 1, 4, 8, 7, 9]
E       AssertionError

ts-3-5/test_3-5_0-9_291.py:40: AssertionError
   - [# 172] SDL bst2: 
--------------------------------------------------------------------------------
  167:         
  168:         for n in self.pre_order(node=node.left):
  169:             yield n
  170:         for n in self.pre_order(node=node.right):
- 171:             yield n
+ 171:             pass
  172:     
  173:     def in_order(self, node='root'):
  174:         '''Depth first in-order traversal of tree.'''
  175:         if node == 'root':
--------------------------------------------------------------------------------
[0.15466 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_pre_order

self = <test_3-5_0-9_291.TestBst object at 0x70408bca7910>
bst_instance = <bst2.Bst object at 0x70408bca6350>

    def test_pre_order(self, bst_instance):
>       assert list(bst_instance.pre_order()) == [5, 3, 1, 4, 8, 7, 9]
E       AssertionError

ts-3-5/test_3-5_0-9_291.py:40: AssertionError
   - [# 173] SDL bst2: 
--------------------------------------------------------------------------------
  172:     
  173:     def in_order(self, node='root'):
  174:         '''Depth first in-order traversal of tree.'''
  175:         if node == 'root':
- 176:             node = self.root
+ 176:             pass
  177:         
  178:         if not node:
  179:             return
  180:         
--------------------------------------------------------------------------------
[0.15933 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_in_order

self = <test_3-5_0-9_291.TestBst object at 0x70408ba69db0>
bst_instance = <bst2.Bst object at 0x70408ba68850>

    def test_in_order(self, bst_instance):
>       assert list(bst_instance.in_order()) == [1, 3, 4, 5, 7, 8, 9]

ts-3-5/test_3-5_0-9_291.py:43: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x70408ba68850>, node = 'root'

>   ???
E   AttributeError: 'str' object has no attribute 'left'

bst2:181: AttributeError
   - [# 174] SDL bst2: 
--------------------------------------------------------------------------------
  175:         if node == 'root':
  176:             node = self.root
  177:         
  178:         if not node:
- 179:             return
+ 179:             pass
  180:         
  181:         for n in self.in_order(node=node.left):
  182:             yield n
  183:         yield node.val
--------------------------------------------------------------------------------
[0.15883 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_in_order

self = <test_3-5_0-9_291.TestBst object at 0x70408bb4a1d0>
bst_instance = <bst2.Bst object at 0x70408bb4a9e0>

    def test_in_order(self, bst_instance):
>       assert list(bst_instance.in_order()) == [1, 3, 4, 5, 7, 8, 9]

ts-3-5/test_3-5_0-9_291.py:43: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
bst2:181: in in_order
    ???
bst2:181: in in_order
    ???
bst2:181: in in_order
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x70408bb4a9e0>, node = None

>   ???
E   AttributeError: 'NoneType' object has no attribute 'left'

bst2:181: AttributeError
   - [# 175] SDL bst2: 
--------------------------------------------------------------------------------
  178:         if not node:
  179:             return
  180:         
  181:         for n in self.in_order(node=node.left):
- 182:             yield n
+ 182:             pass
  183:         yield node.val
  184:         for n in self.in_order(node=node.right):
  185:             yield n
  186:     
--------------------------------------------------------------------------------
[0.15793 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_in_order

self = <test_3-5_0-9_291.TestBst object at 0x70408c0c4f70>
bst_instance = <bst2.Bst object at 0x70408bbeb670>

    def test_in_order(self, bst_instance):
>       assert list(bst_instance.in_order()) == [1, 3, 4, 5, 7, 8, 9]
E       AssertionError

ts-3-5/test_3-5_0-9_291.py:43: AssertionError
   - [# 176] SDL bst2: 
--------------------------------------------------------------------------------
  179:             return
  180:         
  181:         for n in self.in_order(node=node.left):
  182:             yield n
- 183:         yield node.val
+ 183:         pass
  184:         for n in self.in_order(node=node.right):
  185:             yield n
  186:     
  187:     def post_order(self, node='root'):
--------------------------------------------------------------------------------
[0.15821 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_in_order

self = <test_3-5_0-9_291.TestBst object at 0x70408ba5ddb0>
bst_instance = <bst2.Bst object at 0x70408c3c8070>

    def test_in_order(self, bst_instance):
>       assert list(bst_instance.in_order()) == [1, 3, 4, 5, 7, 8, 9]
E       AssertionError

ts-3-5/test_3-5_0-9_291.py:43: AssertionError
   - [# 177] SDL bst2: 
--------------------------------------------------------------------------------
  181:         for n in self.in_order(node=node.left):
  182:             yield n
  183:         yield node.val
  184:         for n in self.in_order(node=node.right):
- 185:             yield n
+ 185:             pass
  186:     
  187:     def post_order(self, node='root'):
  188:         '''Depth frist post_order traversal of tree.'''
  189:         if node == 'root':
--------------------------------------------------------------------------------
[0.16017 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_in_order

self = <test_3-5_0-9_291.TestBst object at 0x70408bbafee0>
bst_instance = <bst2.Bst object at 0x70408bced960>

    def test_in_order(self, bst_instance):
>       assert list(bst_instance.in_order()) == [1, 3, 4, 5, 7, 8, 9]
E       AssertionError

ts-3-5/test_3-5_0-9_291.py:43: AssertionError
   - [# 178] SDL bst2: 
--------------------------------------------------------------------------------
  186:     
  187:     def post_order(self, node='root'):
  188:         '''Depth frist post_order traversal of tree.'''
  189:         if node == 'root':
- 190:             node = self.root
+ 190:             pass
  191:         
  192:         if not node:
  193:             return
  194:         
--------------------------------------------------------------------------------
[0.15787 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_post_order

self = <test_3-5_0-9_291.TestBst object at 0x70408ba3b400>
bst_instance = <bst2.Bst object at 0x70408ba3a590>

    def test_post_order(self, bst_instance):
>       assert list(bst_instance.post_order()) == [1, 4, 3, 7, 9, 8, 5]

ts-3-5/test_3-5_0-9_291.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x70408ba3a590>, node = 'root'

>   ???
E   AttributeError: 'str' object has no attribute 'left'

bst2:195: AttributeError
   - [# 179] SDL bst2: 
--------------------------------------------------------------------------------
  189:         if node == 'root':
  190:             node = self.root
  191:         
  192:         if not node:
- 193:             return
+ 193:             pass
  194:         
  195:         for n in self.post_order(node=node.left):
  196:             yield n
  197:         for n in self.post_order(node=node.right):
--------------------------------------------------------------------------------
[0.19226 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_post_order

self = <test_3-5_0-9_291.TestBst object at 0x70408bf9e050>
bst_instance = <bst2.Bst object at 0x70408bf9eb00>

    def test_post_order(self, bst_instance):
>       assert list(bst_instance.post_order()) == [1, 4, 3, 7, 9, 8, 5]

ts-3-5/test_3-5_0-9_291.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
bst2:195: in post_order
    ???
bst2:195: in post_order
    ???
bst2:195: in post_order
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x70408bf9eb00>, node = None

>   ???
E   AttributeError: 'NoneType' object has no attribute 'left'

bst2:195: AttributeError
   - [# 180] SDL bst2: 
--------------------------------------------------------------------------------
  192:         if not node:
  193:             return
  194:         
  195:         for n in self.post_order(node=node.left):
- 196:             yield n
+ 196:             pass
  197:         for n in self.post_order(node=node.right):
  198:             yield n
  199:         yield node.val
  200:     
--------------------------------------------------------------------------------
[0.15751 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_post_order

self = <test_3-5_0-9_291.TestBst object at 0x70408c3c8eb0>
bst_instance = <bst2.Bst object at 0x70408c3cbeb0>

    def test_post_order(self, bst_instance):
>       assert list(bst_instance.post_order()) == [1, 4, 3, 7, 9, 8, 5]
E       AssertionError

ts-3-5/test_3-5_0-9_291.py:46: AssertionError
   - [# 181] SDL bst2: 
--------------------------------------------------------------------------------
  194:         
  195:         for n in self.post_order(node=node.left):
  196:             yield n
  197:         for n in self.post_order(node=node.right):
- 198:             yield n
+ 198:             pass
  199:         yield node.val
  200:     
  201:     def breadth_first(self):
  202:         '''Breadth first traversal of tree.'''
--------------------------------------------------------------------------------
[0.15851 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_post_order

self = <test_3-5_0-9_291.TestBst object at 0x70408bbeac20>
bst_instance = <bst2.Bst object at 0x70408bbea740>

    def test_post_order(self, bst_instance):
>       assert list(bst_instance.post_order()) == [1, 4, 3, 7, 9, 8, 5]
E       AssertionError

ts-3-5/test_3-5_0-9_291.py:46: AssertionError
   - [# 182] SDL bst2: 
--------------------------------------------------------------------------------
  195:         for n in self.post_order(node=node.left):
  196:             yield n
  197:         for n in self.post_order(node=node.right):
  198:             yield n
- 199:         yield node.val
+ 199:         pass
  200:     
  201:     def breadth_first(self):
  202:         '''Breadth first traversal of tree.'''
  203:         q = Queue()
--------------------------------------------------------------------------------
[0.15100 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_post_order

self = <test_3-5_0-9_291.TestBst object at 0x70408bb1a710>
bst_instance = <bst2.Bst object at 0x70408bb19ae0>

    def test_post_order(self, bst_instance):
>       assert list(bst_instance.post_order()) == [1, 4, 3, 7, 9, 8, 5]
E       AssertionError

ts-3-5/test_3-5_0-9_291.py:46: AssertionError
   - [# 183] SDL bst2: 
--------------------------------------------------------------------------------
  199:         yield node.val
  200:     
  201:     def breadth_first(self):
  202:         '''Breadth first traversal of tree.'''
- 203:         q = Queue()
+ 203:         pass
  204:         q.enqueue(self.root)
  205:         while q.peek():
  206:             node = q.dequeue()
  207:             yield node.val
--------------------------------------------------------------------------------
[0.15267 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_breadth_first

self = <test_3-5_0-9_291.TestBst object at 0x70408bb3bf70>
bst_instance = <bst2.Bst object at 0x70408bb3bfa0>

    def test_breadth_first(self, bst_instance):
>       assert list(bst_instance.breadth_first()) == [5, 3, 8, 1, 4, 7, 9]

ts-3-5/test_3-5_0-9_291.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x70408bb3bfa0>

>   ???
E   NameError: name 'q' is not defined

bst2:204: NameError
   - [# 184] SDL bst2: 
--------------------------------------------------------------------------------
  200:     
  201:     def breadth_first(self):
  202:         '''Breadth first traversal of tree.'''
  203:         q = Queue()
- 204:         q.enqueue(self.root)
+ 204:         pass
  205:         while q.peek():
  206:             node = q.dequeue()
  207:             yield node.val
  208:             if node.left:
--------------------------------------------------------------------------------
[0.15927 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_breadth_first

self = <test_3-5_0-9_291.TestBst object at 0x70408beb8a00>
bst_instance = <bst2.Bst object at 0x70408bebba60>

    def test_breadth_first(self, bst_instance):
>       assert list(bst_instance.breadth_first()) == [5, 3, 8, 1, 4, 7, 9]
E       AssertionError

ts-3-5/test_3-5_0-9_291.py:49: AssertionError
   - [# 185] SDL bst2: 
--------------------------------------------------------------------------------
  202:         '''Breadth first traversal of tree.'''
  203:         q = Queue()
  204:         q.enqueue(self.root)
  205:         while q.peek():
- 206:             node = q.dequeue()
+ 206:             pass
  207:             yield node.val
  208:             if node.left:
  209:                 q.enqueue(node.left)
  210:             if node.right:
--------------------------------------------------------------------------------
[0.16242 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_breadth_first

self = <test_3-5_0-9_291.TestBst object at 0x70408bf532e0>
bst_instance = <bst2.Bst object at 0x70408bf537c0>

    def test_breadth_first(self, bst_instance):
>       assert list(bst_instance.breadth_first()) == [5, 3, 8, 1, 4, 7, 9]

ts-3-5/test_3-5_0-9_291.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x70408bf537c0>

>   ???
E   NameError: name 'node' is not defined

bst2:207: NameError
   - [# 186] SDL bst2: 
--------------------------------------------------------------------------------
  203:         q = Queue()
  204:         q.enqueue(self.root)
  205:         while q.peek():
  206:             node = q.dequeue()
- 207:             yield node.val
+ 207:             pass
  208:             if node.left:
  209:                 q.enqueue(node.left)
  210:             if node.right:
  211:                 q.enqueue(node.right)
--------------------------------------------------------------------------------
[0.16061 s] incompetent

TypeError: /home/lucca/teste/python_experiments2/bst2/ts-3-5/test_3-5_0-9_291.py:49: TypeError: 'NoneType' object is not iterable

   - [# 187] SDL bst2: 
--------------------------------------------------------------------------------
  205:         while q.peek():
  206:             node = q.dequeue()
  207:             yield node.val
  208:             if node.left:
- 209:                 q.enqueue(node.left)
+ 209:                 pass
  210:             if node.right:
  211:                 q.enqueue(node.right)
  212:     
  213:     def delete(self, val):
--------------------------------------------------------------------------------
[0.15958 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_breadth_first

self = <test_3-5_0-9_291.TestBst object at 0x70408bf9a980>
bst_instance = <bst2.Bst object at 0x70408bf9bf40>

    def test_breadth_first(self, bst_instance):
>       assert list(bst_instance.breadth_first()) == [5, 3, 8, 1, 4, 7, 9]
E       AssertionError

ts-3-5/test_3-5_0-9_291.py:49: AssertionError
   - [# 188] SDL bst2: 
--------------------------------------------------------------------------------
  207:             yield node.val
  208:             if node.left:
  209:                 q.enqueue(node.left)
  210:             if node.right:
- 211:                 q.enqueue(node.right)
+ 211:                 pass
  212:     
  213:     def delete(self, val):
  214:         '''Remove a node from the tree.'''
  215:         if (self._size < 1 or not (self.contains(val))):
--------------------------------------------------------------------------------
[0.16006 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_breadth_first

self = <test_3-5_0-9_291.TestBst object at 0x70408bee8d30>
bst_instance = <bst2.Bst object at 0x70408bee8a30>

    def test_breadth_first(self, bst_instance):
>       assert list(bst_instance.breadth_first()) == [5, 3, 8, 1, 4, 7, 9]
E       AssertionError

ts-3-5/test_3-5_0-9_291.py:49: AssertionError
   - [# 189] SDL bst2: 
--------------------------------------------------------------------------------
  212:     
  213:     def delete(self, val):
  214:         '''Remove a node from the tree.'''
  215:         if (self._size < 1 or not (self.contains(val))):
- 216:             return
+ 216:             pass
  217:         
  218:         node = self.search(val)
  219:         
  220:         if node._is_leaf():
--------------------------------------------------------------------------------
[0.13150 s] survived
   - [# 190] SDL bst2: 
--------------------------------------------------------------------------------
  214:         '''Remove a node from the tree.'''
  215:         if (self._size < 1 or not (self.contains(val))):
  216:             return
  217:         
- 218:         node = self.search(val)
+ 218:         pass
  219:         
  220:         if node._is_leaf():
  221:             if node.parent:
  222:                 setattr(node.parent, node._side(), None)
--------------------------------------------------------------------------------
[0.15919 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_delete

self = <test_3-5_0-9_291.TestBst object at 0x70408c2f3a00>
bst_instance = <bst2.Bst object at 0x70408c2f10c0>

    def test_delete(self, bst_instance):
>       bst_instance.delete(1)

ts-3-5/test_3-5_0-9_291.py:52: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x70408c2f10c0>, val = 1

>   ???
E   NameError: name 'node' is not defined

bst2:220: NameError
   - [# 191] SDL bst2: 
--------------------------------------------------------------------------------
  218:         node = self.search(val)
  219:         
  220:         if node._is_leaf():
  221:             if node.parent:
- 222:                 setattr(node.parent, node._side(), None)
+ 222:                 pass
  223:             else:
  224:                 self.root = None
  225:         
  226:         elif node._is_interior():
--------------------------------------------------------------------------------
[0.16009 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_delete

self = <test_3-5_0-9_291.TestBst object at 0x70408bf31ed0>
bst_instance = <bst2.Bst object at 0x70408bf30970>

    def test_delete(self, bst_instance):
        bst_instance.delete(1)
        assert bst_instance.size() == 6
>       assert bst_instance.search(1) is None
E       AssertionError

ts-3-5/test_3-5_0-9_291.py:54: AssertionError
   - [# 192] SDL bst2: 
--------------------------------------------------------------------------------
  220:         if node._is_leaf():
  221:             if node.parent:
  222:                 setattr(node.parent, node._side(), None)
  223:             else:
- 224:                 self.root = None
+ 224:                 pass
  225:         
  226:         elif node._is_interior():
  227:             next_node = self._find_replacement(node)
  228:             self._size += 1
--------------------------------------------------------------------------------
[0.13167 s] survived
   - [# 193] SDL bst2: 
--------------------------------------------------------------------------------
  223:             else:
  224:                 self.root = None
  225:         
  226:         elif node._is_interior():
- 227:             next_node = self._find_replacement(node)
+ 227:             pass
  228:             self._size += 1
  229:             self.delete(next_node.val)
  230:             node.val = next_node.val
  231:         else:
--------------------------------------------------------------------------------
[0.16663 s] survived
   - [# 194] SDL bst2: 
--------------------------------------------------------------------------------
  225:         
  226:         elif node._is_interior():
  227:             next_node = self._find_replacement(node)
  228:             self._size += 1
- 229:             self.delete(next_node.val)
+ 229:             pass
  230:             node.val = next_node.val
  231:         else:
  232:             
  233:             child = getattr(node, node._onlychild())
--------------------------------------------------------------------------------
[0.14079 s] survived
   - [# 195] SDL bst2: 
--------------------------------------------------------------------------------
  226:         elif node._is_interior():
  227:             next_node = self._find_replacement(node)
  228:             self._size += 1
  229:             self.delete(next_node.val)
- 230:             node.val = next_node.val
+ 230:             pass
  231:         else:
  232:             
  233:             child = getattr(node, node._onlychild())
  234:             if node.parent:
--------------------------------------------------------------------------------
[0.13779 s] survived
   - [# 196] SDL bst2: 
--------------------------------------------------------------------------------
  229:             self.delete(next_node.val)
  230:             node.val = next_node.val
  231:         else:
  232:             
- 233:             child = getattr(node, node._onlychild())
+ 233:             pass
  234:             if node.parent:
  235:                 child.parent = node.parent
  236:                 setattr(node.parent, node._side(), child)
  237:             else:
--------------------------------------------------------------------------------
[0.13677 s] survived
   - [# 197] SDL bst2: 
--------------------------------------------------------------------------------
  231:         else:
  232:             
  233:             child = getattr(node, node._onlychild())
  234:             if node.parent:
- 235:                 child.parent = node.parent
+ 235:                 pass
  236:                 setattr(node.parent, node._side(), child)
  237:             else:
  238:                 self.root = child
  239:         
--------------------------------------------------------------------------------
[0.14838 s] survived
   - [# 198] SDL bst2: 
--------------------------------------------------------------------------------
  232:             
  233:             child = getattr(node, node._onlychild())
  234:             if node.parent:
  235:                 child.parent = node.parent
- 236:                 setattr(node.parent, node._side(), child)
+ 236:                 pass
  237:             else:
  238:                 self.root = child
  239:         
  240:         self._size -= 1
--------------------------------------------------------------------------------
[0.12920 s] survived
   - [# 199] SDL bst2: 
--------------------------------------------------------------------------------
  234:             if node.parent:
  235:                 child.parent = node.parent
  236:                 setattr(node.parent, node._side(), child)
  237:             else:
- 238:                 self.root = child
+ 238:                 pass
  239:         
  240:         self._size -= 1
  241:     
  242:     def _find_replacement(self, node):
--------------------------------------------------------------------------------
[0.12465 s] survived
   - [# 200] SDL bst2: 
--------------------------------------------------------------------------------
  241:     
  242:     def _find_replacement(self, node):
  243:         '''Find left most node of right subtree.'''
  244:         if node.right:
- 245:             return self._findmin(node.right)
+ 245:             pass
  246:         
  247:         elif node.parent:
  248:             if node._side() == 'left':
  249:                 return self.parent
--------------------------------------------------------------------------------
[0.12716 s] survived
   - [# 201] SDL bst2: 
--------------------------------------------------------------------------------
  245:             return self._findmin(node.right)
  246:         
  247:         elif node.parent:
  248:             if node._side() == 'left':
- 249:                 return self.parent
+ 249:                 pass
  250:             else:
  251:                 node.parent.right = None
  252:                 tmp = self._find_replacement(node.parent)
  253:                 node.parent.right = node
--------------------------------------------------------------------------------
[0.12591 s] survived
   - [# 202] SDL bst2: 
--------------------------------------------------------------------------------
  247:         elif node.parent:
  248:             if node._side() == 'left':
  249:                 return self.parent
  250:             else:
- 251:                 node.parent.right = None
+ 251:                 pass
  252:                 tmp = self._find_replacement(node.parent)
  253:                 node.parent.right = node
  254:                 return tmp
  255:     
--------------------------------------------------------------------------------
[0.15899 s] survived
   - [# 203] SDL bst2: 
--------------------------------------------------------------------------------
  248:             if node._side() == 'left':
  249:                 return self.parent
  250:             else:
  251:                 node.parent.right = None
- 252:                 tmp = self._find_replacement(node.parent)
+ 252:                 pass
  253:                 node.parent.right = node
  254:                 return tmp
  255:     
  256:     def _findmin(self, node):
--------------------------------------------------------------------------------
[0.12497 s] survived
   - [# 204] SDL bst2: 
--------------------------------------------------------------------------------
  249:                 return self.parent
  250:             else:
  251:                 node.parent.right = None
  252:                 tmp = self._find_replacement(node.parent)
- 253:                 node.parent.right = node
+ 253:                 pass
  254:                 return tmp
  255:     
  256:     def _findmin(self, node):
  257:         '''Find min of subtree, Min is always left most node.'''
--------------------------------------------------------------------------------
[0.12599 s] survived
   - [# 205] SDL bst2: 
--------------------------------------------------------------------------------
  250:             else:
  251:                 node.parent.right = None
  252:                 tmp = self._find_replacement(node.parent)
  253:                 node.parent.right = node
- 254:                 return tmp
+ 254:                 pass
  255:     
  256:     def _findmin(self, node):
  257:         '''Find min of subtree, Min is always left most node.'''
  258:         while node.left:
--------------------------------------------------------------------------------
[0.12566 s] survived
   - [# 206] SDL bst2: 
--------------------------------------------------------------------------------
  255:     
  256:     def _findmin(self, node):
  257:         '''Find min of subtree, Min is always left most node.'''
  258:         while node.left:
- 259:             node = node.left
+ 259:             pass
  260:         return node
--------------------------------------------------------------------------------
[0.12447 s] survived
   - [# 207] SDL bst2: 
--------------------------------------------------------------------------------
  256:     def _findmin(self, node):
  257:         '''Find min of subtree, Min is always left most node.'''
  258:         while node.left:
  259:             node = node.left
- 260:         return node
+ 260:         pass
--------------------------------------------------------------------------------
[0.13544 s] survived
   - [# 208] SVD bst2: 
--------------------------------------------------------------------------------
    7:     '''Node, or leaf of the BST.'''
    8:     
    9:     def __init__(self, val=None, parent=None):
   10:         '''Create node object.'''
-  11:         self.val = val
+  11:         val = val
   12:         self.right = None
   13:         self.left = None
   14:         self.parent = parent
   15:         self.height = 1
--------------------------------------------------------------------------------
[0.00000 s] incompetent

ValueError: expression must have Store context but has Load instead

   - [# 209] SVD bst2: 
--------------------------------------------------------------------------------
    8:     
    9:     def __init__(self, val=None, parent=None):
   10:         '''Create node object.'''
   11:         self.val = val
-  12:         self.right = None
+  12:         right = None
   13:         self.left = None
   14:         self.parent = parent
   15:         self.height = 1
   16:     
--------------------------------------------------------------------------------
[0.00000 s] incompetent

ValueError: expression must have Store context but has Load instead

   - [# 210] SVD bst2: 
--------------------------------------------------------------------------------
    9:     def __init__(self, val=None, parent=None):
   10:         '''Create node object.'''
   11:         self.val = val
   12:         self.right = None
-  13:         self.left = None
+  13:         left = None
   14:         self.parent = parent
   15:         self.height = 1
   16:     
   17:     def _is_leaf(self):
--------------------------------------------------------------------------------
[0.00000 s] incompetent

ValueError: expression must have Store context but has Load instead

   - [# 211] SVD bst2: 
--------------------------------------------------------------------------------
   10:         '''Create node object.'''
   11:         self.val = val
   12:         self.right = None
   13:         self.left = None
-  14:         self.parent = parent
+  14:         parent = parent
   15:         self.height = 1
   16:     
   17:     def _is_leaf(self):
   18:         '''Return true if a leaf.'''
--------------------------------------------------------------------------------
[0.00000 s] incompetent

ValueError: expression must have Store context but has Load instead

   - [# 212] SVD bst2: 
--------------------------------------------------------------------------------
   11:         self.val = val
   12:         self.right = None
   13:         self.left = None
   14:         self.parent = parent
-  15:         self.height = 1
+  15:         height = 1
   16:     
   17:     def _is_leaf(self):
   18:         '''Return true if a leaf.'''
   19:         return (self.right is None and self.left is None)
--------------------------------------------------------------------------------
[0.00000 s] incompetent

ValueError: expression must have Store context but has Load instead

   - [# 213] SVD bst2: 
--------------------------------------------------------------------------------
   15:         self.height = 1
   16:     
   17:     def _is_leaf(self):
   18:         '''Return true if a leaf.'''
-  19:         return (self.right is None and self.left is None)
+  19:         return (right is None and self.left is None)
   20:     
   21:     def _is_interior(self):
   22:         '''Return true if a interior node.'''
   23:         return (self.right is not None and self.left is not None)
--------------------------------------------------------------------------------
[0.15968 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_delete

self = <test_3-5_0-9_291.TestBst object at 0x70408bc40ca0>
bst_instance = <bst2.Bst object at 0x70408bc41270>

    def test_delete(self, bst_instance):
>       bst_instance.delete(1)

ts-3-5/test_3-5_0-9_291.py:52: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
bst2:220: in delete
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Node object at 0x70408c2ac8b0>

>   ???
E   NameError: name 'right' is not defined

bst2:19: NameError
   - [# 214] SVD bst2: 
--------------------------------------------------------------------------------
   15:         self.height = 1
   16:     
   17:     def _is_leaf(self):
   18:         '''Return true if a leaf.'''
-  19:         return (self.right is None and self.left is None)
+  19:         return (self.right is None and left is None)
   20:     
   21:     def _is_interior(self):
   22:         '''Return true if a interior node.'''
   23:         return (self.right is not None and self.left is not None)
--------------------------------------------------------------------------------
[0.16465 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_delete

self = <test_3-5_0-9_291.TestBst object at 0x70408bcec6a0>
bst_instance = <bst2.Bst object at 0x70408bcedd50>

    def test_delete(self, bst_instance):
>       bst_instance.delete(1)

ts-3-5/test_3-5_0-9_291.py:52: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
bst2:220: in delete
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Node object at 0x70408c0903d0>

>   ???
E   NameError: name 'left' is not defined

bst2:19: NameError
   - [# 215] SVD bst2: 
--------------------------------------------------------------------------------
   19:         return (self.right is None and self.left is None)
   20:     
   21:     def _is_interior(self):
   22:         '''Return true if a interior node.'''
-  23:         return (self.right is not None and self.left is not None)
+  23:         return (right is not None and self.left is not None)
   24:     
   25:     def _onlychild(self):
   26:         '''Return string depending on children.'''
   27:         if (self.left and not (self.right)):
--------------------------------------------------------------------------------
[0.16543 s] killed by ts-3-5/test_3-5_0-9_291.py::TestNode::test_is_interior

self = <test_3-5_0-9_291.TestNode object at 0x70408be6c100>

    def test_is_interior(self):
        node = Node(5)
>       assert node._is_interior() is False

ts-3-5/test_3-5_0-9_291.py:64: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Node object at 0x70408c0ea410>

>   ???
E   NameError: name 'right' is not defined

bst2:23: NameError
   - [# 216] SVD bst2: 
--------------------------------------------------------------------------------
   19:         return (self.right is None and self.left is None)
   20:     
   21:     def _is_interior(self):
   22:         '''Return true if a interior node.'''
-  23:         return (self.right is not None and self.left is not None)
+  23:         return (self.right is not None and left is not None)
   24:     
   25:     def _onlychild(self):
   26:         '''Return string depending on children.'''
   27:         if (self.left and not (self.right)):
--------------------------------------------------------------------------------
[0.16292 s] survived
   - [# 217] SVD bst2: 
--------------------------------------------------------------------------------
   23:         return (self.right is not None and self.left is not None)
   24:     
   25:     def _onlychild(self):
   26:         '''Return string depending on children.'''
-  27:         if (self.left and not (self.right)):
+  27:         if (left and not (self.right)):
   28:             return 'left'
   29:         if (self.right and not (self.left)):
   30:             return 'right'
   31:     
--------------------------------------------------------------------------------
[0.18248 s] killed by ts-3-5/test_3-5_0-9_291.py::TestNode::test_onlychild

self = <test_3-5_0-9_291.TestNode object at 0x70408be193f0>

    def test_onlychild(self):
        node = Node(5)
        node.left = Node(3)
>       assert node._onlychild() == 'left'

ts-3-5/test_3-5_0-9_291.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Node object at 0x70408be18ca0>

>   ???
E   NameError: name 'left' is not defined

bst2:27: NameError
   - [# 218] SVD bst2: 
--------------------------------------------------------------------------------
   23:         return (self.right is not None and self.left is not None)
   24:     
   25:     def _onlychild(self):
   26:         '''Return string depending on children.'''
-  27:         if (self.left and not (self.right)):
+  27:         if (self.left and not right):
   28:             return 'left'
   29:         if (self.right and not (self.left)):
   30:             return 'right'
   31:     
--------------------------------------------------------------------------------
[0.14987 s] killed by ts-3-5/test_3-5_0-9_291.py::TestNode::test_onlychild

self = <test_3-5_0-9_291.TestNode object at 0x70408c108460>

    def test_onlychild(self):
        node = Node(5)
        node.left = Node(3)
>       assert node._onlychild() == 'left'

ts-3-5/test_3-5_0-9_291.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Node object at 0x70408c108a00>

>   ???
E   NameError: name 'right' is not defined

bst2:27: NameError
   - [# 219] SVD bst2: 
--------------------------------------------------------------------------------
   25:     def _onlychild(self):
   26:         '''Return string depending on children.'''
   27:         if (self.left and not (self.right)):
   28:             return 'left'
-  29:         if (self.right and not (self.left)):
+  29:         if (right and not (self.left)):
   30:             return 'right'
   31:     
   32:     def _side(self):
   33:         '''Return if left or right child of parent.'''
--------------------------------------------------------------------------------
[0.13733 s] survived
   - [# 220] SVD bst2: 
--------------------------------------------------------------------------------
   25:     def _onlychild(self):
   26:         '''Return string depending on children.'''
   27:         if (self.left and not (self.right)):
   28:             return 'left'
-  29:         if (self.right and not (self.left)):
+  29:         if (self.right and not left):
   30:             return 'right'
   31:     
   32:     def _side(self):
   33:         '''Return if left or right child of parent.'''
--------------------------------------------------------------------------------
[0.13042 s] survived
   - [# 221] SVD bst2: 
--------------------------------------------------------------------------------
   30:             return 'right'
   31:     
   32:     def _side(self):
   33:         '''Return if left or right child of parent.'''
-  34:         if self.parent:
+  34:         if parent:
   35:             return 'left' if self.parent.left == self else 'right'
   36: 
   37: 
   38: class Bst(object):
--------------------------------------------------------------------------------
[0.15045 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_delete

self = <test_3-5_0-9_291.TestBst object at 0x70408c1f3a60>
bst_instance = <bst2.Bst object at 0x70408c1f0d30>

    def test_delete(self, bst_instance):
>       bst_instance.delete(1)

ts-3-5/test_3-5_0-9_291.py:52: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
bst2:222: in delete
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Node object at 0x70408c1f25c0>

>   ???
E   NameError: name 'parent' is not defined

bst2:34: NameError
   - [# 222] SVD bst2: 
--------------------------------------------------------------------------------
   31:     
   32:     def _side(self):
   33:         '''Return if left or right child of parent.'''
   34:         if self.parent:
-  35:             return 'left' if self.parent.left == self else 'right'
+  35:             return 'left' if parent.left == self else 'right'
   36: 
   37: 
   38: class Bst(object):
   39:     '''Binary Search Tree.
--------------------------------------------------------------------------------
[0.15030 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_delete

self = <test_3-5_0-9_291.TestBst object at 0x70408c12cd30>
bst_instance = <bst2.Bst object at 0x70408c12c4c0>

    def test_delete(self, bst_instance):
>       bst_instance.delete(1)

ts-3-5/test_3-5_0-9_291.py:52: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
bst2:222: in delete
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Node object at 0x70408c12dc30>

>   ???
E   NameError: name 'parent' is not defined

bst2:35: NameError
   - [# 223] SVD bst2: 
--------------------------------------------------------------------------------
   76:     '''
   77:     
   78:     def __init__(self, data=None):
   79:         '''Initialize tree.'''
-  80:         self._size = 0
+  80:         _size = 0
   81:         self.root = None
   82:         
   83:         if data:
   84:             for i in data:
--------------------------------------------------------------------------------
[0.00000 s] incompetent

ValueError: expression must have Store context but has Load instead

   - [# 224] SVD bst2: 
--------------------------------------------------------------------------------
   77:     
   78:     def __init__(self, data=None):
   79:         '''Initialize tree.'''
   80:         self._size = 0
-  81:         self.root = None
+  81:         root = None
   82:         
   83:         if data:
   84:             for i in data:
   85:                 self.insert(i)
--------------------------------------------------------------------------------
[0.00000 s] incompetent

ValueError: expression must have Store context but has Load instead

   - [# 225] SVD bst2: 
--------------------------------------------------------------------------------
   81:         self.root = None
   82:         
   83:         if data:
   84:             for i in data:
-  85:                 self.insert(i)
+  85:                 insert(i)
   86:     
   87:     def insert(self, val):
   88:         '''Insert val into BST. If val is already present will be ignored.'''
   89:         if not (self.root):
--------------------------------------------------------------------------------
[0.17483 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_insert

self = <test_3-5_0-9_291.TestBst object at 0x70408c013c40>

    @pytest.fixture
    def bst_instance(self):
>       return Bst([5, 3, 8, 1, 4, 7, 9])

ts-3-5/test_3-5_0-9_291.py:15: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x70408c011f90>, data = [5, 3, 8, 1, 4, 7, ...]

>   ???
E   NameError: name 'insert' is not defined

bst2:85: NameError
   - [# 226] SVD bst2: 
--------------------------------------------------------------------------------
   85:                 self.insert(i)
   86:     
   87:     def insert(self, val):
   88:         '''Insert val into BST. If val is already present will be ignored.'''
-  89:         if not (self.root):
+  89:         if not root:
   90:             self.root = Node(val)
   91:             self._size += 1
   92:         else:
   93:             self._step(val, self.root)
--------------------------------------------------------------------------------
[0.14821 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_insert

self = <test_3-5_0-9_291.TestBst object at 0x70408c0f4730>

    @pytest.fixture
    def bst_instance(self):
>       return Bst([5, 3, 8, 1, 4, 7, 9])

ts-3-5/test_3-5_0-9_291.py:15: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
bst2:85: in __init__
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x70408c0f4be0>, val = 5

>   ???
E   NameError: name 'root' is not defined

bst2:89: NameError
   - [# 227] SVD bst2: 
--------------------------------------------------------------------------------
   86:     
   87:     def insert(self, val):
   88:         '''Insert val into BST. If val is already present will be ignored.'''
   89:         if not (self.root):
-  90:             self.root = Node(val)
+  90:             root = Node(val)
   91:             self._size += 1
   92:         else:
   93:             self._step(val, self.root)
   94:     
--------------------------------------------------------------------------------
[0.00000 s] incompetent

ValueError: expression must have Store context but has Load instead

   - [# 228] SVD bst2: 
--------------------------------------------------------------------------------
   87:     def insert(self, val):
   88:         '''Insert val into BST. If val is already present will be ignored.'''
   89:         if not (self.root):
   90:             self.root = Node(val)
-  91:             self._size += 1
+  91:             _size += 1
   92:         else:
   93:             self._step(val, self.root)
   94:     
   95:     def _step(self, val, curr):
--------------------------------------------------------------------------------
[0.00000 s] incompetent

ValueError: expression must have Store context but has Load instead

   - [# 229] SVD bst2: 
--------------------------------------------------------------------------------
   89:         if not (self.root):
   90:             self.root = Node(val)
   91:             self._size += 1
   92:         else:
-  93:             self._step(val, self.root)
+  93:             _step(val, self.root)
   94:     
   95:     def _step(self, val, curr):
   96:         '''Decide left or right and returns height.'''
   97:         if val < curr.val:
--------------------------------------------------------------------------------
[0.14605 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_insert

self = <test_3-5_0-9_291.TestBst object at 0x70408bccfeb0>

    @pytest.fixture
    def bst_instance(self):
>       return Bst([5, 3, 8, 1, 4, 7, 9])

ts-3-5/test_3-5_0-9_291.py:15: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
bst2:85: in __init__
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x70408be954e0>, val = 3

>   ???
E   NameError: name '_step' is not defined

bst2:93: NameError
   - [# 230] SVD bst2: 
--------------------------------------------------------------------------------
   89:         if not (self.root):
   90:             self.root = Node(val)
   91:             self._size += 1
   92:         else:
-  93:             self._step(val, self.root)
+  93:             self._step(val, root)
   94:     
   95:     def _step(self, val, curr):
   96:         '''Decide left or right and returns height.'''
   97:         if val < curr.val:
--------------------------------------------------------------------------------
[0.14662 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_insert

self = <test_3-5_0-9_291.TestBst object at 0x70408bc3f340>

    @pytest.fixture
    def bst_instance(self):
>       return Bst([5, 3, 8, 1, 4, 7, 9])

ts-3-5/test_3-5_0-9_291.py:15: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
bst2:85: in __init__
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x70408bc3fc40>, val = 3

>   ???
E   NameError: name 'root' is not defined

bst2:93: NameError
   - [# 231] SVD bst2: 
--------------------------------------------------------------------------------
   94:     
   95:     def _step(self, val, curr):
   96:         '''Decide left or right and returns height.'''
   97:         if val < curr.val:
-  98:             curr = self._set_child(curr, 'left', val)
+  98:             curr = _set_child(curr, 'left', val)
   99:         elif val > curr.val:
  100:             curr = self._set_child(curr, 'right', val)
  101:         return curr.height
  102:     
--------------------------------------------------------------------------------
[0.14893 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_insert

self = <test_3-5_0-9_291.TestBst object at 0x70408be4ba60>

    @pytest.fixture
    def bst_instance(self):
>       return Bst([5, 3, 8, 1, 4, 7, 9])

ts-3-5/test_3-5_0-9_291.py:15: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
bst2:85: in __init__
    ???
bst2:93: in insert
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x70408bad3520>, val = 3
curr = <bst2.Node object at 0x70408bad1de0>

>   ???
E   NameError: name '_set_child' is not defined

bst2:98: NameError
   - [# 232] SVD bst2: 
--------------------------------------------------------------------------------
   96:         '''Decide left or right and returns height.'''
   97:         if val < curr.val:
   98:             curr = self._set_child(curr, 'left', val)
   99:         elif val > curr.val:
- 100:             curr = self._set_child(curr, 'right', val)
+ 100:             curr = _set_child(curr, 'right', val)
  101:         return curr.height
  102:     
  103:     def _set_child(self, curr, side, val):
  104:         '''Helping.'''
--------------------------------------------------------------------------------
[0.14747 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_insert

self = <test_3-5_0-9_291.TestBst object at 0x70408bf222f0>

    @pytest.fixture
    def bst_instance(self):
>       return Bst([5, 3, 8, 1, 4, 7, 9])

ts-3-5/test_3-5_0-9_291.py:15: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
bst2:85: in __init__
    ???
bst2:93: in insert
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x70408bf20340>, val = 8
curr = <bst2.Node object at 0x70408bf21db0>

>   ???
E   NameError: name '_set_child' is not defined

bst2:100: NameError
   - [# 233] SVD bst2: 
--------------------------------------------------------------------------------
  103:     def _set_child(self, curr, side, val):
  104:         '''Helping.'''
  105:         child = getattr(curr, side)
  106:         if child:
- 107:             count = self._step(val, child)
+ 107:             count = _step(val, child)
  108:             if curr.height <= count:
  109:                 curr.height += 1
  110:         else:
  111:             setattr(curr, side, Node(val, curr))
--------------------------------------------------------------------------------
[0.15414 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_insert

self = <test_3-5_0-9_291.TestBst object at 0x70408bcf6620>

    @pytest.fixture
    def bst_instance(self):
>       return Bst([5, 3, 8, 1, 4, 7, 9])

ts-3-5/test_3-5_0-9_291.py:15: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
bst2:85: in __init__
    ???
bst2:93: in insert
    ???
bst2:98: in _step
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x70408bcf6740>
curr = <bst2.Node object at 0x70408ba94190>, side = 'left', val = 1

>   ???
E   NameError: name '_step' is not defined

bst2:107: NameError
   - [# 234] SVD bst2: 
--------------------------------------------------------------------------------
  108:             if curr.height <= count:
  109:                 curr.height += 1
  110:         else:
  111:             setattr(curr, side, Node(val, curr))
- 112:             self._size += 1
+ 112:             _size += 1
  113:             if curr.height == 1:
  114:                 curr.height += 1
  115:         return curr
  116:     
--------------------------------------------------------------------------------
[0.00000 s] incompetent

ValueError: expression must have Store context but has Load instead

   - [# 235] SVD bst2: 
--------------------------------------------------------------------------------
  115:         return curr
  116:     
  117:     def search(self, val):
  118:         '''Return the node containing val.'''
- 119:         curr = self.root
+ 119:         curr = root
  120:         while curr:
  121:             if curr.val == val:
  122:                 return curr
  123:             elif val < curr.val:
--------------------------------------------------------------------------------
[0.14366 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_insert

self = <test_3-5_0-9_291.TestBst object at 0x70408bbe8e20>
bst_instance = <bst2.Bst object at 0x70408bbe9c30>

    def test_insert(self, bst_instance):
        bst_instance.insert(10)
        assert bst_instance.size() == 8
>       assert bst_instance.search(10).val == 10

ts-3-5/test_3-5_0-9_291.py:20: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x70408bbe9c30>, val = 10

>   ???
E   NameError: name 'root' is not defined

bst2:119: NameError
   - [# 236] SVD bst2: 
--------------------------------------------------------------------------------
  126:                 curr = curr.right
  127:     
  128:     def size(self):
  129:         '''Return the size of the BST.'''
- 130:         return self._size
+ 130:         return _size
  131:     
  132:     def depth(self):
  133:         '''Return depth of the BST, representing total levels.'''
  134:         return 0 if not (self.root) else self.root.height
--------------------------------------------------------------------------------
[0.17582 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_insert

self = <test_3-5_0-9_291.TestBst object at 0x70408c1f3af0>
bst_instance = <bst2.Bst object at 0x70408c1f39d0>

    def test_insert(self, bst_instance):
        bst_instance.insert(10)
>       assert bst_instance.size() == 8

ts-3-5/test_3-5_0-9_291.py:19: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x70408c1f39d0>

>   ???
E   NameError: name '_size' is not defined

bst2:130: NameError
   - [# 237] SVD bst2: 
--------------------------------------------------------------------------------
  130:         return self._size
  131:     
  132:     def depth(self):
  133:         '''Return depth of the BST, representing total levels.'''
- 134:         return 0 if not (self.root) else self.root.height
+ 134:         return 0 if not root else self.root.height
  135:     
  136:     def contains(self, val):
  137:         '''Return true if val is in the bst.'''
  138:         return self.search(val) is not None
--------------------------------------------------------------------------------
[0.14813 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_depth

self = <test_3-5_0-9_291.TestBst object at 0x70408bf761d0>
bst_instance = <bst2.Bst object at 0x70408bf753f0>

    def test_depth(self, bst_instance):
>       assert bst_instance.depth() == 3

ts-3-5/test_3-5_0-9_291.py:30: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x70408bf753f0>

>   ???
E   NameError: name 'root' is not defined

bst2:134: NameError
   - [# 238] SVD bst2: 
--------------------------------------------------------------------------------
  130:         return self._size
  131:     
  132:     def depth(self):
  133:         '''Return depth of the BST, representing total levels.'''
- 134:         return 0 if not (self.root) else self.root.height
+ 134:         return 0 if not (self.root) else root.height
  135:     
  136:     def contains(self, val):
  137:         '''Return true if val is in the bst.'''
  138:         return self.search(val) is not None
--------------------------------------------------------------------------------
[0.14907 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_depth

self = <test_3-5_0-9_291.TestBst object at 0x70408c09b6a0>
bst_instance = <bst2.Bst object at 0x70408bcf44f0>

    def test_depth(self, bst_instance):
>       assert bst_instance.depth() == 3

ts-3-5/test_3-5_0-9_291.py:30: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x70408bcf44f0>

>   ???
E   NameError: name 'root' is not defined

bst2:134: NameError
   - [# 239] SVD bst2: 
--------------------------------------------------------------------------------
  134:         return 0 if not (self.root) else self.root.height
  135:     
  136:     def contains(self, val):
  137:         '''Return true if val is in the bst.'''
- 138:         return self.search(val) is not None
+ 138:         return search(val) is not None
  139:     
  140:     def balance(self, tree=None):
  141:         '''Return an integer of how well the tree is balanced.
  142: 
--------------------------------------------------------------------------------
[0.15320 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_contains

self = <test_3-5_0-9_291.TestBst object at 0x70408c12ce20>
bst_instance = <bst2.Bst object at 0x70408c12dea0>

    def test_contains(self, bst_instance):
>       assert bst_instance.contains(7) is True

ts-3-5/test_3-5_0-9_291.py:33: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x70408c12dea0>, val = 7

>   ???
E   NameError: name 'search' is not defined

bst2:138: NameError
   - [# 240] SVD bst2: 
--------------------------------------------------------------------------------
  145:         should return a negative value. An ideally-balanced tree should
  146:         return 0.
  147:         '''
  148:         if not tree:
- 149:             tree = self.root
+ 149:             tree = root
  150:             if not tree:
  151:                 return 0
  152:         
  153:         leftbranch = 0 if not (tree.left) else tree.left.height
--------------------------------------------------------------------------------
[0.15955 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_balance

self = <test_3-5_0-9_291.TestBst object at 0x70408c13b820>
bst_instance = <bst2.Bst object at 0x70408c13ba30>

    def test_balance(self, bst_instance):
>       assert bst_instance.balance() == 0

ts-3-5/test_3-5_0-9_291.py:37: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x70408c13ba30>, tree = None

>   ???
E   NameError: name 'root' is not defined

bst2:149: NameError
   - [# 241] SVD bst2: 
--------------------------------------------------------------------------------
  157:     
  158:     def pre_order(self, node='root'):
  159:         '''Depth first pre-order traversal of tree.'''
  160:         if node == 'root':
- 161:             node = self.root
+ 161:             node = root
  162:         
  163:         if not node:
  164:             return
  165:         
--------------------------------------------------------------------------------
[0.16130 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_pre_order

self = <test_3-5_0-9_291.TestBst object at 0x70408bca4820>
bst_instance = <bst2.Bst object at 0x70408c3ccc40>

    def test_pre_order(self, bst_instance):
>       assert list(bst_instance.pre_order()) == [5, 3, 1, 4, 8, 7, 9]

ts-3-5/test_3-5_0-9_291.py:40: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x70408c3ccc40>, node = 'root'

>   ???
E   NameError: name 'root' is not defined

bst2:161: NameError
   - [# 242] SVD bst2: 
--------------------------------------------------------------------------------
  164:             return
  165:         
  166:         yield node.val
  167:         
- 168:         for n in self.pre_order(node=node.left):
+ 168:         for n in pre_order(node=node.left):
  169:             yield n
  170:         for n in self.pre_order(node=node.right):
  171:             yield n
  172:     
--------------------------------------------------------------------------------
[0.15679 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_pre_order

self = <test_3-5_0-9_291.TestBst object at 0x70408c06f1f0>
bst_instance = <bst2.Bst object at 0x70408c06e530>

    def test_pre_order(self, bst_instance):
>       assert list(bst_instance.pre_order()) == [5, 3, 1, 4, 8, 7, 9]

ts-3-5/test_3-5_0-9_291.py:40: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x70408c06e530>
node = <bst2.Node object at 0x70408bb45180>

>   ???
E   NameError: name 'pre_order' is not defined

bst2:168: NameError
   - [# 243] SVD bst2: 
--------------------------------------------------------------------------------
  166:         yield node.val
  167:         
  168:         for n in self.pre_order(node=node.left):
  169:             yield n
- 170:         for n in self.pre_order(node=node.right):
+ 170:         for n in pre_order(node=node.right):
  171:             yield n
  172:     
  173:     def in_order(self, node='root'):
  174:         '''Depth first in-order traversal of tree.'''
--------------------------------------------------------------------------------
[0.16083 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_pre_order

self = <test_3-5_0-9_291.TestBst object at 0x70408c0d0910>
bst_instance = <bst2.Bst object at 0x70408c0d0250>

    def test_pre_order(self, bst_instance):
>       assert list(bst_instance.pre_order()) == [5, 3, 1, 4, 8, 7, 9]

ts-3-5/test_3-5_0-9_291.py:40: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
bst2:168: in pre_order
    ???
bst2:168: in pre_order
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x70408c0d0250>
node = <bst2.Node object at 0x70408c0d1fc0>

>   ???
E   NameError: name 'pre_order' is not defined

bst2:170: NameError
   - [# 244] SVD bst2: 
--------------------------------------------------------------------------------
  172:     
  173:     def in_order(self, node='root'):
  174:         '''Depth first in-order traversal of tree.'''
  175:         if node == 'root':
- 176:             node = self.root
+ 176:             node = root
  177:         
  178:         if not node:
  179:             return
  180:         
--------------------------------------------------------------------------------
[0.15566 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_in_order

self = <test_3-5_0-9_291.TestBst object at 0x70408c108940>
bst_instance = <bst2.Bst object at 0x70408c10b910>

    def test_in_order(self, bst_instance):
>       assert list(bst_instance.in_order()) == [1, 3, 4, 5, 7, 8, 9]

ts-3-5/test_3-5_0-9_291.py:43: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x70408c10b910>, node = 'root'

>   ???
E   NameError: name 'root' is not defined

bst2:176: NameError
   - [# 245] SVD bst2: 
--------------------------------------------------------------------------------
  177:         
  178:         if not node:
  179:             return
  180:         
- 181:         for n in self.in_order(node=node.left):
+ 181:         for n in in_order(node=node.left):
  182:             yield n
  183:         yield node.val
  184:         for n in self.in_order(node=node.right):
  185:             yield n
--------------------------------------------------------------------------------
[0.16310 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_in_order

self = <test_3-5_0-9_291.TestBst object at 0x70408c1fd450>
bst_instance = <bst2.Bst object at 0x70408c1fcb20>

    def test_in_order(self, bst_instance):
>       assert list(bst_instance.in_order()) == [1, 3, 4, 5, 7, 8, 9]

ts-3-5/test_3-5_0-9_291.py:43: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x70408c1fcb20>
node = <bst2.Node object at 0x70408c1f1750>

>   ???
E   NameError: name 'in_order' is not defined

bst2:181: NameError
   - [# 246] SVD bst2: 
--------------------------------------------------------------------------------
  180:         
  181:         for n in self.in_order(node=node.left):
  182:             yield n
  183:         yield node.val
- 184:         for n in self.in_order(node=node.right):
+ 184:         for n in in_order(node=node.right):
  185:             yield n
  186:     
  187:     def post_order(self, node='root'):
  188:         '''Depth frist post_order traversal of tree.'''
--------------------------------------------------------------------------------
[0.16560 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_in_order

self = <test_3-5_0-9_291.TestBst object at 0x70408c12c460>
bst_instance = <bst2.Bst object at 0x70408c12c310>

    def test_in_order(self, bst_instance):
>       assert list(bst_instance.in_order()) == [1, 3, 4, 5, 7, 8, 9]

ts-3-5/test_3-5_0-9_291.py:43: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
bst2:181: in in_order
    ???
bst2:181: in in_order
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x70408c12c310>
node = <bst2.Node object at 0x70408c12d7b0>

>   ???
E   NameError: name 'in_order' is not defined

bst2:184: NameError
   - [# 247] SVD bst2: 
--------------------------------------------------------------------------------
  186:     
  187:     def post_order(self, node='root'):
  188:         '''Depth frist post_order traversal of tree.'''
  189:         if node == 'root':
- 190:             node = self.root
+ 190:             node = root
  191:         
  192:         if not node:
  193:             return
  194:         
--------------------------------------------------------------------------------
[0.16124 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_post_order

self = <test_3-5_0-9_291.TestBst object at 0x70408bdf8850>
bst_instance = <bst2.Bst object at 0x70408bdf8550>

    def test_post_order(self, bst_instance):
>       assert list(bst_instance.post_order()) == [1, 4, 3, 7, 9, 8, 5]

ts-3-5/test_3-5_0-9_291.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x70408bdf8550>, node = 'root'

>   ???
E   NameError: name 'root' is not defined

bst2:190: NameError
   - [# 248] SVD bst2: 
--------------------------------------------------------------------------------
  191:         
  192:         if not node:
  193:             return
  194:         
- 195:         for n in self.post_order(node=node.left):
+ 195:         for n in post_order(node=node.left):
  196:             yield n
  197:         for n in self.post_order(node=node.right):
  198:             yield n
  199:         yield node.val
--------------------------------------------------------------------------------
[0.19597 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_post_order

self = <test_3-5_0-9_291.TestBst object at 0x70408be967a0>
bst_instance = <bst2.Bst object at 0x70408be97b80>

    def test_post_order(self, bst_instance):
>       assert list(bst_instance.post_order()) == [1, 4, 3, 7, 9, 8, 5]

ts-3-5/test_3-5_0-9_291.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x70408be97b80>
node = <bst2.Node object at 0x70408c12f010>

>   ???
E   NameError: name 'post_order' is not defined

bst2:195: NameError
   - [# 249] SVD bst2: 
--------------------------------------------------------------------------------
  193:             return
  194:         
  195:         for n in self.post_order(node=node.left):
  196:             yield n
- 197:         for n in self.post_order(node=node.right):
+ 197:         for n in post_order(node=node.right):
  198:             yield n
  199:         yield node.val
  200:     
  201:     def breadth_first(self):
--------------------------------------------------------------------------------
[0.15856 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_post_order

self = <test_3-5_0-9_291.TestBst object at 0x70408b910730>
bst_instance = <bst2.Bst object at 0x70408b910220>

    def test_post_order(self, bst_instance):
>       assert list(bst_instance.post_order()) == [1, 4, 3, 7, 9, 8, 5]

ts-3-5/test_3-5_0-9_291.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
bst2:195: in post_order
    ???
bst2:195: in post_order
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x70408b910220>
node = <bst2.Node object at 0x70408bca5330>

>   ???
E   NameError: name 'post_order' is not defined

bst2:197: NameError
   - [# 250] SVD bst2: 
--------------------------------------------------------------------------------
  200:     
  201:     def breadth_first(self):
  202:         '''Breadth first traversal of tree.'''
  203:         q = Queue()
- 204:         q.enqueue(self.root)
+ 204:         q.enqueue(root)
  205:         while q.peek():
  206:             node = q.dequeue()
  207:             yield node.val
  208:             if node.left:
--------------------------------------------------------------------------------
[0.16323 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_breadth_first

self = <test_3-5_0-9_291.TestBst object at 0x70408bbaf010>
bst_instance = <bst2.Bst object at 0x70408bbaf700>

    def test_breadth_first(self, bst_instance):
>       assert list(bst_instance.breadth_first()) == [5, 3, 8, 1, 4, 7, 9]

ts-3-5/test_3-5_0-9_291.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x70408bbaf700>

>   ???
E   NameError: name 'root' is not defined

bst2:204: NameError
   - [# 251] SVD bst2: 
--------------------------------------------------------------------------------
  211:                 q.enqueue(node.right)
  212:     
  213:     def delete(self, val):
  214:         '''Remove a node from the tree.'''
- 215:         if (self._size < 1 or not (self.contains(val))):
+ 215:         if (_size < 1 or not (self.contains(val))):
  216:             return
  217:         
  218:         node = self.search(val)
  219:         
--------------------------------------------------------------------------------
[0.15960 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_delete

self = <test_3-5_0-9_291.TestBst object at 0x70408bcc54b0>
bst_instance = <bst2.Bst object at 0x70408bcc51b0>

    def test_delete(self, bst_instance):
>       bst_instance.delete(1)

ts-3-5/test_3-5_0-9_291.py:52: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x70408bcc51b0>, val = 1

>   ???
E   NameError: name '_size' is not defined

bst2:215: NameError
   - [# 252] SVD bst2: 
--------------------------------------------------------------------------------
  211:                 q.enqueue(node.right)
  212:     
  213:     def delete(self, val):
  214:         '''Remove a node from the tree.'''
- 215:         if (self._size < 1 or not (self.contains(val))):
+ 215:         if (self._size < 1 or not (contains(val))):
  216:             return
  217:         
  218:         node = self.search(val)
  219:         
--------------------------------------------------------------------------------
[0.15743 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_delete

self = <test_3-5_0-9_291.TestBst object at 0x70408bdf96c0>
bst_instance = <bst2.Bst object at 0x70408bdf80d0>

    def test_delete(self, bst_instance):
>       bst_instance.delete(1)

ts-3-5/test_3-5_0-9_291.py:52: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x70408bdf80d0>, val = 1

>   ???
E   NameError: name 'contains' is not defined

bst2:215: NameError
   - [# 253] SVD bst2: 
--------------------------------------------------------------------------------
  214:         '''Remove a node from the tree.'''
  215:         if (self._size < 1 or not (self.contains(val))):
  216:             return
  217:         
- 218:         node = self.search(val)
+ 218:         node = search(val)
  219:         
  220:         if node._is_leaf():
  221:             if node.parent:
  222:                 setattr(node.parent, node._side(), None)
--------------------------------------------------------------------------------
[0.15965 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_delete

self = <test_3-5_0-9_291.TestBst object at 0x70408be19540>
bst_instance = <bst2.Bst object at 0x70408be18d60>

    def test_delete(self, bst_instance):
>       bst_instance.delete(1)

ts-3-5/test_3-5_0-9_291.py:52: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <bst2.Bst object at 0x70408be18d60>, val = 1

>   ???
E   NameError: name 'search' is not defined

bst2:218: NameError
   - [# 254] SVD bst2: 
--------------------------------------------------------------------------------
  220:         if node._is_leaf():
  221:             if node.parent:
  222:                 setattr(node.parent, node._side(), None)
  223:             else:
- 224:                 self.root = None
+ 224:                 root = None
  225:         
  226:         elif node._is_interior():
  227:             next_node = self._find_replacement(node)
  228:             self._size += 1
--------------------------------------------------------------------------------
[0.00000 s] incompetent

ValueError: expression must have Store context but has Load instead

   - [# 255] SVD bst2: 
--------------------------------------------------------------------------------
  223:             else:
  224:                 self.root = None
  225:         
  226:         elif node._is_interior():
- 227:             next_node = self._find_replacement(node)
+ 227:             next_node = _find_replacement(node)
  228:             self._size += 1
  229:             self.delete(next_node.val)
  230:             node.val = next_node.val
  231:         else:
--------------------------------------------------------------------------------
[0.13710 s] survived
   - [# 256] SVD bst2: 
--------------------------------------------------------------------------------
  224:                 self.root = None
  225:         
  226:         elif node._is_interior():
  227:             next_node = self._find_replacement(node)
- 228:             self._size += 1
+ 228:             _size += 1
  229:             self.delete(next_node.val)
  230:             node.val = next_node.val
  231:         else:
  232:             
--------------------------------------------------------------------------------
[0.00000 s] incompetent

ValueError: expression must have Store context but has Load instead

   - [# 257] SVD bst2: 
--------------------------------------------------------------------------------
  225:         
  226:         elif node._is_interior():
  227:             next_node = self._find_replacement(node)
  228:             self._size += 1
- 229:             self.delete(next_node.val)
+ 229:             delete(next_node.val)
  230:             node.val = next_node.val
  231:         else:
  232:             
  233:             child = getattr(node, node._onlychild())
--------------------------------------------------------------------------------
[0.16907 s] survived
   - [# 258] SVD bst2: 
--------------------------------------------------------------------------------
  234:             if node.parent:
  235:                 child.parent = node.parent
  236:                 setattr(node.parent, node._side(), child)
  237:             else:
- 238:                 self.root = child
+ 238:                 root = child
  239:         
  240:         self._size -= 1
  241:     
  242:     def _find_replacement(self, node):
--------------------------------------------------------------------------------
[0.00000 s] incompetent

ValueError: expression must have Store context but has Load instead

   - [# 259] SVD bst2: 
--------------------------------------------------------------------------------
  236:                 setattr(node.parent, node._side(), child)
  237:             else:
  238:                 self.root = child
  239:         
- 240:         self._size -= 1
+ 240:         _size -= 1
  241:     
  242:     def _find_replacement(self, node):
  243:         '''Find left most node of right subtree.'''
  244:         if node.right:
--------------------------------------------------------------------------------
[0.00000 s] incompetent

ValueError: expression must have Store context but has Load instead

   - [# 260] SVD bst2: 
--------------------------------------------------------------------------------
  241:     
  242:     def _find_replacement(self, node):
  243:         '''Find left most node of right subtree.'''
  244:         if node.right:
- 245:             return self._findmin(node.right)
+ 245:             return _findmin(node.right)
  246:         
  247:         elif node.parent:
  248:             if node._side() == 'left':
  249:                 return self.parent
--------------------------------------------------------------------------------
[0.13650 s] survived
   - [# 261] SVD bst2: 
--------------------------------------------------------------------------------
  245:             return self._findmin(node.right)
  246:         
  247:         elif node.parent:
  248:             if node._side() == 'left':
- 249:                 return self.parent
+ 249:                 return parent
  250:             else:
  251:                 node.parent.right = None
  252:                 tmp = self._find_replacement(node.parent)
  253:                 node.parent.right = node
--------------------------------------------------------------------------------
[0.13687 s] survived
   - [# 262] SVD bst2: 
--------------------------------------------------------------------------------
  248:             if node._side() == 'left':
  249:                 return self.parent
  250:             else:
  251:                 node.parent.right = None
- 252:                 tmp = self._find_replacement(node.parent)
+ 252:                 tmp = _find_replacement(node.parent)
  253:                 node.parent.right = node
  254:                 return tmp
  255:     
  256:     def _findmin(self, node):
--------------------------------------------------------------------------------
[0.13024 s] survived
   - [# 263] ZIL bst2: 
--------------------------------------------------------------------------------
   81:         self.root = None
   82:         
   83:         if data:
   84:             for i in data:
-  85:                 self.insert(i)
+  85:                 break
   86:     
   87:     def insert(self, val):
   88:         '''Insert val into BST. If val is already present will be ignored.'''
   89:         if not (self.root):
--------------------------------------------------------------------------------
[0.15276 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_insert

self = <test_3-5_0-9_291.TestBst object at 0x70408c0bb640>
bst_instance = <bst2.Bst object at 0x70408c3c8340>

    def test_insert(self, bst_instance):
        bst_instance.insert(10)
>       assert bst_instance.size() == 8
E       AssertionError

ts-3-5/test_3-5_0-9_291.py:19: AssertionError
   - [# 264] ZIL bst2: 
--------------------------------------------------------------------------------
  117:     def search(self, val):
  118:         '''Return the node containing val.'''
  119:         curr = self.root
  120:         while curr:
- 121:             if curr.val == val:
- 122:                 return curr
- 123:             elif val < curr.val:
- 124:                 curr = curr.left
- 125:             else:
- 126:                 curr = curr.right
+ 121:             break
+ 122:     
+ 123:     
+ 124:     
+ 125:     
+ 126:     
  127:     
  128:     def size(self):
  129:         '''Return the size of the BST.'''
  130:         return self._size
--------------------------------------------------------------------------------
[0.14387 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_insert

self = <test_3-5_0-9_291.TestBst object at 0x70408bc10d90>
bst_instance = <bst2.Bst object at 0x70408bc10ca0>

    def test_insert(self, bst_instance):
        bst_instance.insert(10)
        assert bst_instance.size() == 8
>       assert bst_instance.search(10).val == 10
E       AttributeError: 'NoneType' object has no attribute 'val'

ts-3-5/test_3-5_0-9_291.py:20: AttributeError
   - [# 265] ZIL bst2: 
--------------------------------------------------------------------------------
  165:         
  166:         yield node.val
  167:         
  168:         for n in self.pre_order(node=node.left):
- 169:             yield n
+ 169:             break
  170:         for n in self.pre_order(node=node.right):
  171:             yield n
  172:     
  173:     def in_order(self, node='root'):
--------------------------------------------------------------------------------
[0.14871 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_pre_order

self = <test_3-5_0-9_291.TestBst object at 0x70408be68a60>
bst_instance = <bst2.Bst object at 0x70408be68760>

    def test_pre_order(self, bst_instance):
>       assert list(bst_instance.pre_order()) == [5, 3, 1, 4, 8, 7, 9]
E       AssertionError

ts-3-5/test_3-5_0-9_291.py:40: AssertionError
   - [# 266] ZIL bst2: 
--------------------------------------------------------------------------------
  167:         
  168:         for n in self.pre_order(node=node.left):
  169:             yield n
  170:         for n in self.pre_order(node=node.right):
- 171:             yield n
+ 171:             break
  172:     
  173:     def in_order(self, node='root'):
  174:         '''Depth first in-order traversal of tree.'''
  175:         if node == 'root':
--------------------------------------------------------------------------------
[0.18976 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_pre_order

self = <test_3-5_0-9_291.TestBst object at 0x70408bde5ab0>
bst_instance = <bst2.Bst object at 0x70408bdeb850>

    def test_pre_order(self, bst_instance):
>       assert list(bst_instance.pre_order()) == [5, 3, 1, 4, 8, 7, 9]
E       AssertionError

ts-3-5/test_3-5_0-9_291.py:40: AssertionError
   - [# 267] ZIL bst2: 
--------------------------------------------------------------------------------
  178:         if not node:
  179:             return
  180:         
  181:         for n in self.in_order(node=node.left):
- 182:             yield n
+ 182:             break
  183:         yield node.val
  184:         for n in self.in_order(node=node.right):
  185:             yield n
  186:     
--------------------------------------------------------------------------------
[0.15688 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_in_order

self = <test_3-5_0-9_291.TestBst object at 0x70408c0f5d80>
bst_instance = <bst2.Bst object at 0x70408c0f7b80>

    def test_in_order(self, bst_instance):
>       assert list(bst_instance.in_order()) == [1, 3, 4, 5, 7, 8, 9]
E       AssertionError

ts-3-5/test_3-5_0-9_291.py:43: AssertionError
   - [# 268] ZIL bst2: 
--------------------------------------------------------------------------------
  181:         for n in self.in_order(node=node.left):
  182:             yield n
  183:         yield node.val
  184:         for n in self.in_order(node=node.right):
- 185:             yield n
+ 185:             break
  186:     
  187:     def post_order(self, node='root'):
  188:         '''Depth frist post_order traversal of tree.'''
  189:         if node == 'root':
--------------------------------------------------------------------------------
[0.16544 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_in_order

self = <test_3-5_0-9_291.TestBst object at 0x70408bc3ece0>
bst_instance = <bst2.Bst object at 0x70408be49e10>

    def test_in_order(self, bst_instance):
>       assert list(bst_instance.in_order()) == [1, 3, 4, 5, 7, 8, 9]
E       AssertionError

ts-3-5/test_3-5_0-9_291.py:43: AssertionError
   - [# 269] ZIL bst2: 
--------------------------------------------------------------------------------
  192:         if not node:
  193:             return
  194:         
  195:         for n in self.post_order(node=node.left):
- 196:             yield n
+ 196:             break
  197:         for n in self.post_order(node=node.right):
  198:             yield n
  199:         yield node.val
  200:     
--------------------------------------------------------------------------------
[0.15895 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_post_order

self = <test_3-5_0-9_291.TestBst object at 0x70408bb87a90>
bst_instance = <bst2.Bst object at 0x70408bb87790>

    def test_post_order(self, bst_instance):
>       assert list(bst_instance.post_order()) == [1, 4, 3, 7, 9, 8, 5]
E       AssertionError

ts-3-5/test_3-5_0-9_291.py:46: AssertionError
   - [# 270] ZIL bst2: 
--------------------------------------------------------------------------------
  194:         
  195:         for n in self.post_order(node=node.left):
  196:             yield n
  197:         for n in self.post_order(node=node.right):
- 198:             yield n
+ 198:             break
  199:         yield node.val
  200:     
  201:     def breadth_first(self):
  202:         '''Breadth first traversal of tree.'''
--------------------------------------------------------------------------------
[0.16145 s] killed by ts-3-5/test_3-5_0-9_291.py::TestBst::test_post_order

self = <test_3-5_0-9_291.TestBst object at 0x70408bfcd840>
bst_instance = <bst2.Bst object at 0x70408bfcc9d0>

    def test_post_order(self, bst_instance):
>       assert list(bst_instance.post_order()) == [1, 4, 3, 7, 9, 8, 5]
E       AssertionError

ts-3-5/test_3-5_0-9_291.py:46: AssertionError
   - [# 271] ZIL bst2: 
--------------------------------------------------------------------------------
  202:         '''Breadth first traversal of tree.'''
  203:         q = Queue()
  204:         q.enqueue(self.root)
  205:         while q.peek():
- 206:             node = q.dequeue()
- 207:             yield node.val
- 208:             if node.left:
- 209:                 q.enqueue(node.left)
- 210:             if node.right:
- 211:                 q.enqueue(node.right)
+ 206:             break
+ 207:     
+ 208:     
+ 209:     
+ 210:     
+ 211:     
  212:     
  213:     def delete(self, val):
  214:         '''Remove a node from the tree.'''
  215:         if (self._size < 1 or not (self.contains(val))):
--------------------------------------------------------------------------------
[0.16008 s] incompetent

TypeError: /home/lucca/teste/python_experiments2/bst2/ts-3-5/test_3-5_0-9_291.py:49: TypeError: 'NoneType' object is not iterable

   - [# 272] ZIL bst2: 
--------------------------------------------------------------------------------
  255:     
  256:     def _findmin(self, node):
  257:         '''Find min of subtree, Min is always left most node.'''
  258:         while node.left:
- 259:             node = node.left
+ 259:             break
  260:         return node
--------------------------------------------------------------------------------
[0.14132 s] survived
[*] Mutation score [93.15586 s]: 75.1%
   - all: 272
   - killed: 166 (61.0%)
   - survived: 56 (20.6%)
   - incompetent: 47 (17.3%)
   - timeout: 3 (1.1%)
